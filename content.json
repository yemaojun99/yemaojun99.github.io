{"meta":{"title":"夜猫君","subtitle":"","description":"夜猫君","author":"夜猫君","url":"https://www.yemaojun.top","root":"/"},"pages":[{"title":"","date":"2023-12-08T15:49:49.943Z","updated":"2023-12-08T15:48:58.783Z","comments":true,"path":"google0c09d974cf9248ad.html","permalink":"https://www.yemaojun.top/google0c09d974cf9248ad.html","excerpt":"","text":"google-site-verification: google0c09d974cf9248ad.html"},{"title":"SAP增强","date":"2023-02-23T13:58:05.000Z","updated":"2023-02-23T13:58:59.300Z","comments":true,"path":"categories/index-1.html","permalink":"https://www.yemaojun.top/categories/index-1.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-11-08T05:34:15.935Z","updated":"2024-11-08T05:34:15.935Z","comments":true,"path":"friends/index.html","permalink":"https://www.yemaojun.top/friends/index.html","excerpt":"朋友们的地址：","text":"朋友们的地址： 先简单把友链放上来，后面有时间的话在美化一下。 叶随风 Seele_1018"},{"title":"ABAP基础","date":"2023-02-23T13:59:37.000Z","updated":"2023-02-23T13:59:57.049Z","comments":true,"path":"categories/index-2.html","permalink":"https://www.yemaojun.top/categories/index-2.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-07-22T08:03:53.000Z","updated":"2023-07-17T01:39:44.882Z","comments":false,"path":"categories/index.html","permalink":"https://www.yemaojun.top/categories/index.html","excerpt":"","text":""},{"title":"OOALV","date":"2023-02-23T14:00:35.000Z","updated":"2023-02-23T14:00:52.765Z","comments":true,"path":"categories/index-3.html","permalink":"https://www.yemaojun.top/categories/index-3.html","excerpt":"","text":""},{"title":"ABAP","date":"2023-02-23T13:53:58.000Z","updated":"2023-02-23T13:55:43.839Z","comments":true,"path":"tags/index-1.html","permalink":"https://www.yemaojun.top/tags/index-1.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-07-22T08:08:28.000Z","updated":"2023-07-17T01:47:58.807Z","comments":false,"path":"tags/index.html","permalink":"https://www.yemaojun.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-06-28T09:09:38.259Z","updated":"2023-06-28T09:09:38.259Z","comments":true,"path":"Custom/Custom CSS/logo.css","permalink":"https://www.yemaojun.top/Custom/Custom%20CSS/logo.css","excerpt":"","text":"#navlogo { border-radius: 50%; }"},{"title":"","date":"2023-08-03T06:29:35.475Z","updated":"2023-08-03T06:29:35.475Z","comments":true,"path":"Custom/Custom JS/Dynamic-Title.js","permalink":"https://www.yemaojun.top/Custom/Custom%20JS/Dynamic-Title.js","excerpt":"","text":"var OriginTitle = document.title; document.addEventListener('visibilitychange', function () { if (document.hidden) { document.title = '╭(°A°`)╮ 你去哪了? 快回来!!!'; setTimeout(function () { if(document.hidden){ document.title = OriginTitle; } }, 4000); }else { document.title = 'ヾ(❀╹◡╹)ﾉ~ 你终于回来了 ~'; setTimeout(function () { if(!document.hidden){ document.title = OriginTitle; } }, 2000); } });"},{"title":"","date":"2023-06-28T08:48:27.523Z","updated":"2023-06-28T08:48:27.523Z","comments":true,"path":"Custom/Custom JS/Dynamic-Subtitle.js","permalink":"https://www.yemaojun.top/Custom/Custom%20JS/Dynamic-Subtitle.js","excerpt":"","text":"var binft = function (r) { var isTransparent = true; function getRandomColor() { if(isTransparent){ isTransparent = false; //此处修改字体颜色,最后的 0 和 1 不要改 return \"rgba(255,255,255,0)\" }else{ isTransparent = true; return \"rgba(255,255,255,1)\" } } function n(r) { for (var n = document.createDocumentFragment(), i = 0; r > i; i++) { var oneword = document.createElement(\"span\"); oneword.textContent = \"_\"; // 此处是末尾字符,如果想用光标样式可以改为\"|\" oneword.style.color = getRandomColor(); n.appendChild(oneword); } return n } function i() { var t = wordList[c.skillI]; c.step ? c.step-- : (c.step = refreshDelayTime, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = showTotalWordDelayTime) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % wordList.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(maxLength, maxLength + c.prefixP) : Math.min(maxLength, t.length - c.skillP))), setTimeout(i, d) } var l = \"\", //此处改成你自己的诗词 wordList = [ \"一只悠闲的夜猫子\", \"一只胖胖的夜猫子\", \"一只摸鱼的夜猫子\", \"一只搬砖的夜猫子\", \"一只睡觉的夜猫子\", ].map(function (r) { return r + \"\" }), showTotalWordDelayTime = 2, refreshDelayTime = 1, maxLength = 1, d = 75, c = { text: \"\", prefixP: -maxLength, skillI: 0, skillP: 0, direction: \"forward\", delay: showTotalWordDelayTime, step: refreshDelayTime }; i() }; binft(document.getElementById('binft'));"}],"posts":[{"title":"第五章 Adobe-Form打印Address","slug":"Adobe-Form/5.Adobe-Form打印Address/Adobe-Form打印Address","date":"2024-11-11T13:41:56.000Z","updated":"2024-11-11T13:46:29.933Z","comments":true,"path":"2024/11/11/Adobe-Form/5.Adobe-Form打印Address/Adobe-Form打印Address/","link":"","permalink":"https://www.yemaojun.top/2024/11/11/Adobe-Form/5.Adobe-Form%E6%89%93%E5%8D%B0Address/Adobe-Form%E6%89%93%E5%8D%B0Address/","excerpt":"Adobe Form的第五篇学习笔记。这篇笔记内容比较少，但是很常用。在Form中展示供应商或客户的地址信息。","text":"Adobe Form的第五篇学习笔记。这篇笔记内容比较少，但是很常用。在Form中展示供应商或客户的地址信息。 Adobe-Form打印Address 一、介绍在原来的Smartform中可以展示供应商&#x2F;客户的地址信息。在Adobe Form中也可以做到这样的功能。和上一篇笔记中的新建图形变量一样。我们在Interface中传入地址类型、地址编号、人员编号和国家地区等内容之后。将这些数据内容填入Address参数对象中。 再在Form中划定一块区域用于展示这部分内容即可。 二、功能实现1.Interface（1）创建Interface使用事物代码SFP在Adobe Form的界面填入Interface的名称，并点击Create按钮。 （2）填入描述与Package （3）新建输入参数在新建好的Interface对象的Import中新建四个变量。变量的内容如下所示。 变量名称 变量类型 IV_ADDRESS_TYPE CHAR1 IV_ADDRNUMBER AD_ADDRNUM IV_PERSNUMBER AD_PERSNUM IV_LAND1 LAND1 输入完成之后保存并激活Interface对象。 2.Adobe Form（1）创建Form使用事物代码SFP填入Form的名称，并点击创建按钮。 （2）填写描述并绑定Interface （3）新建Address对象在Form的Context页签上右键 –&gt; Create –&gt; Address。 （4）编辑Address属性将从Interface中传入的四个参数填入到Address对象的参数中。请注意一开始需要先修改Address Type的内容，然后回车后才可以在下面的输入框中输入内容。 （5）设置Layout切换到Form的布局页签中。再转到Data View页签中，然后将Address对象拖动到Form表单中。 删除左侧的ADDRESS文本内容，然后拖动和拉缩地址框。用于多行展示。 完成之后保存并激活Form。 三、Form测试1.测试程序使用下面的程序代码测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687*======================================================================** Selection Screen*======================================================================*PARAMETERS : P_ATYPE TYPE CHAR1, &quot;Address Type P_ADRNR TYPE AD_ADDRNUM, &quot;Address Number P_PERNR TYPE AD_PERSNUM, &quot;Personnel Number P_LAND1 TYPE LAND1. &quot;Country*======================================================================** Data Objects*======================================================================*DATA: GV_FM_NAME TYPE RS38L_FNAM, &quot; FM Name GS_FP_DOCPARAMS TYPE SFPDOCPARAMS, GS_FP_OUTPUTPARAMS TYPE SFPOUTPUTPARAMS.*======================================================================** Constants*======================================================================*CONSTANTS : GV_FORM_NAME TYPE FPNAME VALUE &#x27;YADOBE_FORM_DEMO6&#x27;.*======================================================================** START of Calling the Form*======================================================================**&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open*CALL FUNCTION &#x27;FP_JOB_OPEN&#x27; CHANGING IE_OUTPUTPARAMS = GS_FP_OUTPUTPARAMS EXCEPTIONS CANCEL = 1 USAGE_ERROR = 2 SYSTEM_ERROR = 3 INTERNAL_ERROR = 4 OTHERS = 5.IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error HandlingENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Get the Function module name based on Form Name*CALL FUNCTION &#x27;FP_FUNCTION_MODULE_NAME&#x27; EXPORTING I_NAME = GV_FORM_NAME IMPORTING E_FUNCNAME = GV_FM_NAME.IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error HandlingENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Take the FM name by executing the form - by using Pattern-**&amp;&amp;~~ call that FM and replace the FM Name by gv_fm_name**&amp;&amp;~~ Call the Generated FMCALL FUNCTION GV_FM_NAME &quot;&#x27;/1BCDWB/SM00000204&#x27; EXPORTING /1BCDWB/DOCPARAMS = GS_FP_DOCPARAMS IV_ADDRESS_TYPE = P_atype IV_ADDRNUMBER = P_ADRNR IV_PERSNUMBER = P_PERNR IV_LAND1 = P_LAND1* IMPORTING* /1BCDWB/FORMOUTPUT = EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling hereENDIF.*&amp;---------------------------------------------------------------------**&amp;---------------------------------------------------------------------**&amp;---- Close the spool jobCALL FUNCTION &#x27;FP_JOB_CLOSE&#x27; EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC &lt;&gt; 0.* &lt;error handling&gt;ENDIF. 2.运行结果从LFA1或者KNA1表中找一个BP对象，然后将该BP对象的地址编号填入程序的选择屏幕。 Form的结果如下所示。 使用BP或者数据库表ADRC查看地址信息。两者内容一致。 四、参考资料SAP Adobe Interactive Form Tutorial. Part VI. Printing Address in Adobe Form","categories":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/categories/Adobe-Form/"}],"tags":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/tags/Adobe-Form/"}]},{"title":"第四章 Adobe Form中的图像与Logo","slug":"Adobe-Form/4.Adobe-Form中的图像与Logo/Adobe-Form中的图像与Logo","date":"2024-11-11T11:56:52.000Z","updated":"2024-11-11T12:05:24.148Z","comments":true,"path":"2024/11/11/Adobe-Form/4.Adobe-Form中的图像与Logo/Adobe-Form中的图像与Logo/","link":"","permalink":"https://www.yemaojun.top/2024/11/11/Adobe-Form/4.Adobe-Form%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E4%B8%8ELogo/Adobe-Form%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E4%B8%8ELogo/","excerpt":"Adobe Form的第四篇学习笔记。介绍下Adobe Form中的Image&#x2F;Logo，在Form中展示公司的Logo&#x2F;其他图片内容是很常见的需求内容。这里介绍下在Adobe Form中如何处理这些内容。","text":"Adobe Form的第四篇学习笔记。介绍下Adobe Form中的Image&#x2F;Logo，在Form中展示公司的Logo&#x2F;其他图片内容是很常见的需求内容。这里介绍下在Adobe Form中如何处理这些内容。 Adobe Form中的图像与Logo 一、介绍在Adobe Form中展示图片和公司的Logo等内容即便是在Smartform中都是很常见的需求。作为Smartform的升级和继承者，Adobe Form也有这样的处理方式。并且和Smarform处理方式类似。一样需要先使用事物代码SE78上传对应的图像对象。然后再在Form中引用和展示该对象。 二、功能实现1.上传图片（1）SE78 上传图片使用事物代码SE78打开SAP的图像管理页面。按照图中所示的方式，先展开GRAPHICS页签，然后双击BMAP对象。等右侧屏幕显示内容后再点击上传按钮上传图片。 （2）转换图片格式需要注意是此处上传的图片格式为bpm或tif&#x2F;tiff。如果你有一个其他格式的图片，可以使用系统自带的 画图 将图片转换为对应的格式。 打开之后，在界面的左上角点击文件，将图片另存为bmp格式即可。 （3）验证图片上传成功最后在验证一下图片是否真的上传成功了。按照下图中的方式，填入图片名称，然后敲击回车键，如果能找到就说明上传已经成功了。 2.Interface（1）创建Interface使用事务代码 SFP 打开Adobe Form的创建界面。输入Interface的名称然后点击Create按钮。 （2）填写描述与Package （3）添加Image输入参数在左侧的Import选项中添加一个输入参数。类型为XSTRING。创建完成之后保存并激活Interface对象。 3.Adobe Form（1）创建Form继续使用事物代码SFP，回到Adobe Form的页面。输入Form的名称，点击创建按钮。 （2）填写描述与绑定Interface （3）添加Imag输入参数将Import中的变量拖到Context中。 （4）创建图形变量在Context中的 YADOBE_FORM_DEMO5 上右键创建一个图形变量。 将Graphic 类型从 Graphic Reference 更改为 Graphic content。 确认修改图形节点类型。 修改图形节点类型之后，会多两个输入参数。分别是Field与MIME Type。 将从Interface中传入进来的变量IV_LOGO填入Field输入框。MIME Type为’IMAGE&#x2F;BMP‘。 （5）设置Layout转到Layout页签，将刚刚新建好的图形变量拖动到Form上。你可以对图形进行拉伸或压缩。 在图片的下方有图片的标题。就是Image Field的这部分。如果你不想在图片&#x2F;Logo的下方展示任何文字内容可以考虑将这部分文本内容置为空。 （6）添加文本内容在Imag的下方添加一个文本框，用来展示图片和文本内容。 三、Form 测试1.测试代码使用下面的代码进行测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102*======================================================================** Selection Screen*======================================================================*PARAMETERS : P_LOGO TYPE RSTXT-TDNAME.&quot;Imag/Logo Name*======================================================================** Data Objects*======================================================================*DATA: GV_FM_NAME TYPE RS38L_FNAM, &quot; FM Name GS_FP_DOCPARAMS TYPE SFPDOCPARAMS, GS_FP_OUTPUTPARAMS TYPE SFPOUTPUTPARAMS, GV_NAME TYPE TDOBNAME, GV_LOGO TYPE XSTRING, GV_BMP TYPE XSTRING.*======================================================================** Constants*======================================================================*CONSTANTS : GC_BTYPE TYPE TDBTYPE VALUE &#x27;BCOL&#x27;, GC_ID TYPE TDIDGR VALUE &#x27;BMAP&#x27;, GC_OBJECT TYPE TDOBJECTGR VALUE &#x27;GRAPHICS&#x27;, GV_FORM_NAME TYPE FPNAME VALUE &#x27;YADOBE_FORM_DEMO5&#x27;.*======================================================================** START of Calling the Form*======================================================================**&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open*CALL FUNCTION &#x27;FP_JOB_OPEN&#x27; CHANGING IE_OUTPUTPARAMS = GS_FP_OUTPUTPARAMS EXCEPTIONS CANCEL = 1 USAGE_ERROR = 2 SYSTEM_ERROR = 3 INTERNAL_ERROR = 4 OTHERS = 5.IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error HandlingENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Get the Function module name based on Form Name*CALL FUNCTION &#x27;FP_FUNCTION_MODULE_NAME&#x27; EXPORTING I_NAME = GV_FORM_NAME IMPORTING E_FUNCNAME = GV_FM_NAME.IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error HandlingENDIF.* Passing the logo nameGV_NAME = P_LOGO.* Get the image/logo graphic informationCALL METHOD CL_SSF_XSF_UTILITIES=&gt;GET_BDS_GRAPHIC_AS_BMP EXPORTING P_OBJECT = GC_OBJECT &quot; GRAPHICS P_NAME = GV_NAME &quot; Name of the Logo P_ID = GC_ID &quot; BMAP P_BTYPE = GC_BTYPE &quot; BCOL for color, &#x27;BMON&#x27; for Black &amp; White RECEIVING P_BMP = GV_BMP EXCEPTIONS NOT_FOUND = 1 INTERNAL_ERROR = 2 OTHERS = 3.GV_LOGO = GV_BMP.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Take the FM name by execuing the form - by using Pattern-**&amp;&amp;~~ call that FM and replace the FM Name by gv_fm_name**&amp;&amp;~~ Call the Generated FMCALL FUNCTION GV_FM_NAME EXPORTING /1BCDWB/DOCPARAMS = GS_FP_DOCPARAMS* iv_name = p_name* iv_flag = p_flag IV_LOGO = GV_LOGO EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling hereENDIF.*&amp;---------------------------------------------------------------------**&amp;---------------------------------------------------------------------**&amp;---- Close the spool jobCALL FUNCTION &#x27;FP_JOB_CLOSE&#x27; EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC &lt;&gt; 0.* &lt;error handling&gt;ENDIF. 2.测试结果按照下图中的方式填入上面从SE78中上传的GRAPHICS NAME。然后按照图中所示的方式展示Form。 最终运行的结果如下图所示。 缩略图如下所示。 使用这种方式可以通过传入的名称的不同来展示不同的Image&#x2F;Logo。当需要变更图片或Logo时只需要在SE78中上传新的图片对象，然后在调用Form时传入不同的图片名称即可。 四、参考资料SAP Adobe Interactive Form Tutorial. Part V. Images, Graphics and Logo in Adobe Forms","categories":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/categories/Adobe-Form/"}],"tags":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/tags/Adobe-Form/"}]},{"title":"多物料CK13N报表核心逻辑","slug":"ABAP/ABAP杂项记录/多物料CK13N报表核心逻辑/多物料CK13N报表核心逻辑","date":"2024-11-11T07:53:27.000Z","updated":"2024-11-11T08:58:48.961Z","comments":true,"path":"2024/11/11/ABAP/ABAP杂项记录/多物料CK13N报表核心逻辑/多物料CK13N报表核心逻辑/","link":"","permalink":"https://www.yemaojun.top/2024/11/11/ABAP/ABAP%E6%9D%82%E9%A1%B9%E8%AE%B0%E5%BD%95/%E5%A4%9A%E7%89%A9%E6%96%99CK13N%E6%8A%A5%E8%A1%A8%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91/%E5%A4%9A%E7%89%A9%E6%96%99CK13N%E6%8A%A5%E8%A1%A8%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91/","excerpt":"这段时间接到了一个为CK13N开发一个查看多物料工时的需求。要求显示的数据内容和CK13N的一样。在网上查了很多的资料。大部分资料建议直接从数据库表取。但是最后在SAP的论坛找到了一个标准函数 CK_F_CSTG_STRUCTURE_EXPLOSION 可以抓到单个物料在CK13N中的数据。所以这个需求实现的核心就是依托这个函数进行实现。","text":"这段时间接到了一个为CK13N开发一个查看多物料工时的需求。要求显示的数据内容和CK13N的一样。在网上查了很多的资料。大部分资料建议直接从数据库表取。但是最后在SAP的论坛找到了一个标准函数 CK_F_CSTG_STRUCTURE_EXPLOSION 可以抓到单个物料在CK13N中的数据。所以这个需求实现的核心就是依托这个函数进行实现。 多物料CK13N报表核心逻辑 一、核心逻辑1.核心逻辑说明如开头所介绍的内容，可以使用标准函数CK_F_CSTG_STRUCTURE_EXPLOSION获取CK13N中的物料信息。该函数的输入参数为数据库表KEKO中字段内容。所以选择屏幕的物料与工厂等信息可以从这个表中抓。抓到合适数据之后再循环调用函数获取物料在CK13N中的数据内容即可。 2.函数结构此处给一个链接，如果不想看图片，或者想复制其中的内容可以点击前面的链接，跳转到网页版的函数结构说明。 使用该函数时，输入参数中的 S_LOSGR 需要注意。如果要保证单个物料的子层级自制件的数量和CK13N的数量保持一致，则需要将该参数为置为 ABAP_TRUE 。若为空，则子层级自制件物料的数量是当期物料的合。 3.KEKO中的发布标识CK13N中的物料一般有多个版本，但是在一个时间段内只会有一个版本生效。生效的这个版本就是发布的版本。在KEKO中使用下面的三个字段表示。 字段名 字段描述 FREIG Release 标识 ( 空：当前版本未生效 X：当前版本有效 ) FREIDAT Release 的日期 FREIUSR Release 的操作人 如果KEKO中的当前记录有效，则上面三个字段都会有值。所以如果你的需求需要的是有效的KEKO记录，可以使用这三个字段进行数据筛选。 二、参考代码1.函数调用参考代码也可以直接参照下面的函数调用代码直接使用。KLVAR字段虽然不是必输的，但如果有时候不输入会拿不到值。 12345678910111213141516171819202122232425262728293031323334CALL FUNCTION &#x27;CK_F_CSTG_STRUCTURE_EXPLOSION&#x27; EXPORTING KLVAR = KEKO-KLVAR &quot;Costing Variant KALNR = KEKO-KALNR &quot;Cost Estimate Number - Product Costing KADKY = KEKO-KADKY &quot;Costing Date (Key) TVERS = KEKO-TVERS &quot;Costing Version WERK = KEKO-WERKS &quot;Plant* SICHT = 01 S_LOSGR = ABAP_TRUE* S_BEZUGSMENGE =* S_BEZUGSMENGENEINHEIT =* S_ACCEPT_NULLMENGE = &#x27; &#x27;* S_AUFLOESUNGSTIEFE =* S_READ_ONLY_DB = &#x27;X&#x27;* S_ONLY_MAT_POS = &#x27; &#x27;* S_EXPLODE_KF_TOO = &#x27; &#x27;* S_EXPLODE_RAW = &#x27; &#x27;* S_SKIP_TOTALS = &#x27;X&#x27;* S_USE_KKE3_CACHE = &#x27; &#x27;* S_EXPLODE_BPO = &#x27; &#x27;* S_VUC_READ_ONLY_DB = &#x27; &#x27; IMPORTING F_KEKO = LS_KEKO &quot;keko F_HEADER_MAT = LS_HEADER &quot;ck_strukturtab_header* S_AUFL_UNVOLLSTAENDIG = TABLES STRUKTURTABELLE = LT_STRUKTURTAB &quot;TYPE: ck_strukturtab CK13N Data* T_KEKO_IMP = LT_KEKO EXCEPTIONS INVALID_BZOBJ = 1 KEKO_NOT_FOUND = 2 META_MODEL_ERROR = 3 CKHS_NOT_FOUND = 4 OTHERS = 5. 2.效果演示（1）CK13N结果 （2）函数执行结果 函数的执行结果如下所示。当然你也可以考虑点击该链接将结果下载下来查看。但是我更建议你直接在你的系统中执行结果。 CK13N_DATA.xlsx 在返回的结果中STUFE字段记录了层级信息。","categories":[{"name":"业务","slug":"业务","permalink":"https://www.yemaojun.top/categories/%E4%B8%9A%E5%8A%A1/"},{"name":"CO","slug":"CO","permalink":"https://www.yemaojun.top/categories/CO/"},{"name":"CK13N","slug":"CO/CK13N","permalink":"https://www.yemaojun.top/categories/CO/CK13N/"}],"tags":[{"name":"业务","slug":"业务","permalink":"https://www.yemaojun.top/tags/%E4%B8%9A%E5%8A%A1/"}]},{"title":"第三章 JavaScript-动态显示和隐藏Adobe-Form的字段","slug":"Adobe-Form/3.JavaScript-动态显示和隐藏Adobe-Form的字段/JavaScript-动态显示和隐藏Adobe-Form的字段","date":"2024-11-08T10:50:41.000Z","updated":"2024-11-08T10:57:49.758Z","comments":true,"path":"2024/11/08/Adobe-Form/3.JavaScript-动态显示和隐藏Adobe-Form的字段/JavaScript-动态显示和隐藏Adobe-Form的字段/","link":"","permalink":"https://www.yemaojun.top/2024/11/08/Adobe-Form/3.JavaScript-%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8FAdobe-Form%E7%9A%84%E5%AD%97%E6%AE%B5/JavaScript-%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8FAdobe-Form%E7%9A%84%E5%AD%97%E6%AE%B5/","excerpt":"Adobe Form的第三篇学习笔记，来简单介绍下Adobe Form编写脚本的功能。脚本自身的作用很强，但是比较遗憾的是在Adobe Form中编写的脚本无法验证其准确性的。因为他没有语法检查，所以最好在别的编辑器中编写脚本，测试没有问题再复制到Adobe From中或许是比较好的思路。","text":"Adobe Form的第三篇学习笔记，来简单介绍下Adobe Form编写脚本的功能。脚本自身的作用很强，但是比较遗憾的是在Adobe Form中编写的脚本无法验证其准确性的。因为他没有语法检查，所以最好在别的编辑器中编写脚本，测试没有问题再复制到Adobe From中或许是比较好的思路。 JavaScript 动态显示和隐藏Adobe Form的字段 一、介绍脚本作为Adobe Form的重要功能之一，虽然并不经常使用，但是它能帮你解决很多的问题。所以编写本篇笔记来简单介绍下如何编写脚本。 Adobe Form可以通过编写脚本来动态的控制展示的元素属性。例如本篇笔记可以编写JavaScript脚本来控制Form上元素的显示和隐藏。 二、功能演示1.创建Interface（1）新建界面使用事务代码SFP打开Adobe Form的界面。在Interface的输入框中输入名称。 （2）填写描述与Package （3）创建输入参数点击下图中红框圈中的新建按钮，添加两个自定义输入变量。完成之后激活Interface。 2.创建Adobe Form（1）创建对象回到SFP的界面，新建Adobe Form对象。 （2）填写描述与Package信息 （3）添加Context参数将从Interface中带过来的输入参数添加到Adobe Form的Context中。 3.设置Layout（1）添加Adobe Form展示元素转到Data View页签中，将添加到Context的变量拖动到Form中进行展示。 （2）打开脚本编辑器选中拖动到屏幕上的字段 IV_VALUE，然后点击Palettes-&gt;Script Editor打开脚本编辑器。 按照图中的方式打开的脚本编辑器如下所示。 （3）编写脚本在Show后边的下拉框中选择form: ready。然后可以在右侧看到Language的输入框变为 JavaScript。在下面的文本框中可以编写JS脚本的逻辑。 然后我们编写一个简单的JS脚本逻辑。当传入参数 IV_FLAG 的值不为 X 时将屏幕上的输入框 IV_VALUE 隐藏。 1234if($record.IV_FLAG.value != &quot;X&quot;)&#123;this.presence = &quot;hidden&quot;;&#125; 进行完成上面的操作之后，保存并激活Adobe Form对象。 三、Form测试1.SFP测试在激活好的Adobe Form界面直接点击运行按钮，查看Form运行的效果。 （1）IV_FLAG 为 X填入输入参数。 运行结果如下所示。 （2）IV_FLAG 为 空填入输入参数。 运行结果如下所示。因为是一整篇的空白，所以我就截一个缩略图。 2.程序测试（1）编写测试代码创建一个Report程序，并编写如下所示的代码测试Form的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172*======================================================================** Selection Screen*======================================================================*PARAMETERS: P_VALUE TYPE CHAR40, P_FLAG TYPE CHAR1.**&amp;&amp;~~ Data ObjectsDATA: GV_FM_NAME TYPE RS38L_FNAM, &quot; FM Name GS_FP_DOCPARAMS TYPE SFPDOCPARAMS, GS_FP_OUTPUTPARAMS TYPE SFPOUTPUTPARAMS.CONSTANTS : GV_FORM_NAME TYPE FPNAME VALUE &#x27;YADOBE_FORM_DEMO4&#x27;.*======================================================================** START of Calling the Form*======================================================================**&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open*CALL FUNCTION &#x27;FP_JOB_OPEN&#x27; CHANGING IE_OUTPUTPARAMS = GS_FP_OUTPUTPARAMS EXCEPTIONS CANCEL = 1 USAGE_ERROR = 2 SYSTEM_ERROR = 3 INTERNAL_ERROR = 4 OTHERS = 5.IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error HandlingENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Get the Function module name based on Form Name*CALL FUNCTION &#x27;FP_FUNCTION_MODULE_NAME&#x27; EXPORTING I_NAME = GV_FORM_NAME IMPORTING E_FUNCNAME = GV_FM_NAME.IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error HandlingENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Take the FM name by execuing the form - by using Pattern-**&amp;&amp;~~ call that FM and replace the FM Name by gv_fm_name**&amp;&amp;~~ Call the Generated FMCALL FUNCTION GV_FM_NAME EXPORTING /1BCDWB/DOCPARAMS = GS_FP_DOCPARAMS IV_VALUE = P_VALUE IV_FLAG = P_FLAG EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling hereENDIF.*&amp;---------------------------------------------------------------------**&amp;---------------------------------------------------------------------**&amp;---- Close the spool jobCALL FUNCTION &#x27;FP_JOB_CLOSE&#x27; EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC &lt;&gt; 0.* &lt;error handling&gt;ENDIF. （2）IV_FLAG 为 X选择屏幕的数据如下所示。 运行的结果如下所示。 ![17.测试Adobe Form_Report_IV_FLAG 为 X_执行结果](JavaScript-动态显示和隐藏Adobe-Form的字段&#x2F;17.测试Adobe Form_Report_IV_FLAG 为 X_执行结果.png) （3）IV_FLAG 为 空选择屏幕的数据如下所示。 运行的结果如下所示。 四、参考资料SAP Adobe Interactive Form Tutorial. Part IV. Dynamically Hide and Display Fields using Javascript in Adobe Form Based on Conditions","categories":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/categories/Adobe-Form/"}],"tags":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/tags/Adobe-Form/"}]},{"title":"第二章 Adobe Form的Date Time与Floating Fields","slug":"Adobe-Form/2.Adobe Form的Date Time与Floating Fields/Adobe-Form的Date-Time与Floating-Fields","date":"2024-10-30T14:06:02.000Z","updated":"2024-10-30T14:17:15.781Z","comments":true,"path":"2024/10/30/Adobe-Form/2.Adobe Form的Date Time与Floating Fields/Adobe-Form的Date-Time与Floating-Fields/","link":"","permalink":"https://www.yemaojun.top/2024/10/30/Adobe-Form/2.Adobe%20Form%E7%9A%84Date%20Time%E4%B8%8EFloating%20Fields/Adobe-Form%E7%9A%84Date-Time%E4%B8%8EFloating-Fields/","excerpt":"这是Adobe From的第二篇笔记，本来我计划将所有的内容都写在一篇笔记中，但是遗憾的是我学习的时间总是断断续续的，而且将所有的知识点放在一篇笔记中会显得这篇笔记十分的庞大。不利于复习和阅读，所以我决定后面将知识点分开记录。","text":"这是Adobe From的第二篇笔记，本来我计划将所有的内容都写在一篇笔记中，但是遗憾的是我学习的时间总是断断续续的，而且将所有的知识点放在一篇笔记中会显得这篇笔记十分的庞大。不利于复习和阅读，所以我决定后面将知识点分开记录。 Adobe Form的Date Time与Floating Fields 一、介绍在后续的Adobe Form开发过程中，我们或许需要使用一些系统字段。例如系统的日期、时间、用户名和SUBRC等字段。这些系统变量在Adobe中有专门提供。我们在开发过程中可以直接使用。 在开发过程中还有一些动态文本字段，也是经常使用的。让一些文本中间的某一部分是动态变化的，类似于字符串之间的拼接。动态文本的长度会随着内容的长度变化而变化。 所以本篇笔记主要记录如何在Adobe Form中使用这两种功能。 二、功能演示1.创建Interface（1）新建界面使用事务代码SFP打开Adobe Form的界面。 Interface引用原文中的话来说，他就是交互式Adobe的支柱。 （2）填入描述与Package信息 （3）创建输入参数点击下图中红框圈中的新建按钮，添加两个自定义输入变量。设置两个变量的类型为CHAR40。 完成之后激活该Interface对象。 2.创建Adobe Form对象（1）创建对象回到SFP的界面，新建Adobe Form对象。 （2）填写描述与Package信息 3.填充Context区域（1）导入Interface变量展开左侧Interface的Import页签。将Interface中的两个输入参数拖动到Adobe Form的Context区域。在这个区域中的参数对于Adobe Form而言是全局变量。 （2）导入系统变量系统变量在Interface参数的下面一个页签中。可以使用同样的方式将系统字段拖动到Context区域。 4.设置Floating Fields（1）插入标准文本按照图中所示的方式，插入一个文本到Adobe Form中。 （2）变更文本布局与内容可以对插入的文本对象进行拉伸、缩小和拖动来调整文本对象的位置与布局。 插入一段固定的文本，并保留两个用来动态填充的词。如下所示，将“夜猫君”与“ABAP”作为Floating Fields字段插入Interface中的两个变量。 1Welcome to 夜猫君 blog. Here you will learn about ABAP-related content. 还可以在右下角的Font页签中设置文本中的字体大小等内容。 （3）设置Floating Fields选中需要变更为Floating Fields的内容，然后单击右键选择 Floating Fields 按钮。 设置完成之后被选中的内容会被大括号包起来。并且可以对文本中间的内容进行变更，这里变更的效果就类似于重命名。 在选中Floating Fields后，在右侧的导航栏中绑定我们从Interface中导入的变量。 接下来选中“ABAP”，使用同样的方式将此处的Floating Fields与VALUE1变量进行绑定。 我们设置的Floating Fields的长度是动态的。它会根据传入的变量的长度进行扩展和压缩。例如我的变量长度是40位长度，但是我传入的实际值的长度只有三位或更少的话，Floating Fields的长度也会变化。 5.使用系统变量的日期与时间（1）插入日期和时间转到Data View页签，然后选中Date与Time对象，将他们拖动到Adobe Form中。 （2）设置日期格式不同的地区或需求对于日期的格式有不同的要求。我们可以通过设置日期的Pattems属性来更改日期的格式。 （3）设置时间格式我们可以使用同样的步骤来设置时间的格式。 6.激活并保存进行完成上面的操作之后就可以激活并保存Adobe Form对象了。剩下的就是对Adobe Form进行测试。 三、Form测试1.直接执行Adobe Form在激活后的Adobe Form对象上点击运行按钮，输入参数并按照图中所示的内容操作即可看到运行出来的PDF文件。 运行出来的效果如下图所示。 2.使用程序执行Adobe Form（1）编写测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980**&amp;&amp;~~ Data ObjectsDATA: GV_FM_NAME TYPE RS38L_FNAM, &quot; FM Name GS_FP_DOCPARAMS TYPE SFPDOCPARAMS, GS_FP_OUTPUTPARAMS TYPE SFPOUTPUTPARAMS, GT_KNA1 TYPE STANDARD TABLE OF KNA1.* Selection ScreenPARAMETERS: P_VALUE TYPE CHAR40.PARAMETERS: P_VALUE1 TYPE CHAR40.&quot;Your Adobe Form NameCONSTANTS : GV_FORM_NAME TYPE FPNAME VALUE &#x27;YADOBE_FORM_DEMO3&#x27;.*======================================================================** START of TREATMENT **======================================================================*START-OF-SELECTION.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open* CALL FUNCTION &#x27;FP_JOB_OPEN&#x27; CHANGING IE_OUTPUTPARAMS = GS_FP_OUTPUTPARAMS EXCEPTIONS CANCEL = 1 USAGE_ERROR = 2 SYSTEM_ERROR = 3 INTERNAL_ERROR = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error Handling ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Get the Function module name based on Form Name* CALL FUNCTION &#x27;FP_FUNCTION_MODULE_NAME&#x27; EXPORTING I_NAME = GV_FORM_NAME IMPORTING E_FUNCNAME = GV_FM_NAME. IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error Handling ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Take the FM name by execuing the form - by using Pattern-**&amp;&amp;~~ call that FM and replace the FM Name by gv_fm_name***&amp;&amp;~~ Call the Generated FM CALL FUNCTION GV_FM_NAME &quot;&#x27;/1BCDWB/SM00000176&#x27; EXPORTING /1BCDWB/DOCPARAMS = GS_FP_DOCPARAMS VALUE1 = P_VALUE1 VALUE = P_VALUE EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open* CALL FUNCTION &#x27;FP_JOB_CLOSE&#x27;. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.*&amp;---------------------------------------------------------------------**&amp;---- Close the spool job CALL FUNCTION &#x27;FP_JOB_CLOSE&#x27; EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC &lt;&gt; 0.* &lt;error handling&gt; ENDIF.*&amp;---------------------------------------------------------------------* （2）执行测试程序在选择屏幕中输入调用Adobe Form必须的输入参数执行程序。 执行的效果如下图所示。 入上图所示，执行的效果符合我们的预期。并且第二次传入的VALUE1变量值变为了SAP。单动态文本并没有显示多余的空格。 四、参考资料本片笔记的参考资料如下所示： SAP Adobe Interactive Form Tutorial. Part III. Date Time and Floating Fields 如果你有什么建议或者发现上面笔记中的错误，欢迎在博客评论留言告知我，十分感谢。","categories":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/categories/Adobe-Form/"}],"tags":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/tags/Adobe-Form/"}]},{"title":"第一章 Adobe Form介绍与Table","slug":"Adobe-Form/1.Adobe Form介绍与Table/Adobe-Form介绍与Table","date":"2024-10-30T13:54:30.000Z","updated":"2024-10-30T14:16:22.785Z","comments":true,"path":"2024/10/30/Adobe-Form/1.Adobe Form介绍与Table/Adobe-Form介绍与Table/","link":"","permalink":"https://www.yemaojun.top/2024/10/30/Adobe-Form/1.Adobe%20Form%E4%BB%8B%E7%BB%8D%E4%B8%8ETable/Adobe-Form%E4%BB%8B%E7%BB%8D%E4%B8%8ETable/","excerpt":"Adobe Form可以理解成是Smart Form的升级版。它拥有更加简洁的界面和操作方式。更加重要的是Adobe Form未来会被运用在BTP上。但是Smart Form无法在BTP上使用。 我找到了一些国外的教程。根据这些教程我将我学习Adobe Form的内容整理成下面的笔记。你也可以理解成是对我学习资料的翻译版本。我也会给出学习网站的链接，请见最后面的参考资料。","text":"Adobe Form可以理解成是Smart Form的升级版。它拥有更加简洁的界面和操作方式。更加重要的是Adobe Form未来会被运用在BTP上。但是Smart Form无法在BTP上使用。 我找到了一些国外的教程。根据这些教程我将我学习Adobe Form的内容整理成下面的笔记。你也可以理解成是对我学习资料的翻译版本。我也会给出学习网站的链接，请见最后面的参考资料。 Adobe Form介绍与Table 一、Adobe Form介绍1.介绍SAP Adobe Form 是一种基于 Adobe 技术的表单生成工具，它允许用户在 SAP 系统中创建和打印高级的、交互式的 PDF 表单。这项技术提供了比传统的 SmartForms 更加丰富的用户界面和打印体验 。Adobe Form 通过结合 SAP 应用程序的数据处理功能和 Adobe 的 PDF 技术，使用户能够以可视化和灵活的方式设计和生成高质量的表单 。 2.特点 与 Adobe Document Services 的集成，允许从基于 SAP NetWeaver 的后端系统或使用 REST API 的应用程序生成打印和交互式表单。 支持存储表单模板在 SAP Forms service by Adobe 通过 Template Store 特性或在应用程序后端 。 表单设计器工具的使用，它提供了一个可视化界面来创建和编辑表单布局，包括静态元素和动态元素 。 支持 FormCalc 和 JavaScript 脚本语言，用于实现表单的动态行为和数据处理 。 3.注意事项在SAP端使用Adobe Form需要连接操作Adobe Form的服务器，然后再在自己的本地PC中和Smart Form一样安装Adobe Form的补丁包。如果没有连接Adobe的服务器是无法使用该功能的。 二、简单示例1.创建Interface（1）创建Interface和Smartform不一样，Adobe Form的RFC参数需要单独创建，和Adobe Form自身样式设计等界面的内容并没有集成在一起。所以需要单独创建。而且只有创建好Interface之后才能在创建Adobe Form，因为在创建Adobe Form时需要绑定一个Interface，而且Adobe Form中的数据源也是只有绑定了Interface之后才能使用的。 使用事务代码SFP（Smart Form PDF）打开维护Adobe Form的界面。填入Interface的名称。 （2）界面说明创建好Interface后，左侧的面板中是设置Adobe Form的属性面板，右侧则是对应于左侧面板的操作界面。 ① Form Interface主要包含有接口的输入、输出参数与异常处理。当我们通过RFC调用Adobe Form时，参数的设置就在此处。 ② Global Definitions如字面意思所说，此处是用来定义全局对象的位置。你可以在这里定义全局变量(Global Data)、全局类型(Global Type)与字段索引(Field Symbol)。这些对象在整个Form中都是可以引用和使用的。 ③ Initialization调用该Adobe Form时的初始化逻辑。可以在Code Initialization中对变量进行初始化操作。或者进行一些必要的程序初始化逻辑处理。Form Routines定义与编写Form逻辑的位置。 ④ Currency&#x2F;Quantity Fields当Form结构中存在数量或货币字段时，需要和Smart Form一样，在这里设置这些字段对应的参照单位或参照单位字段。 （3）设置接口参数在Form Interface页签中的Import子页签中添加一个名为IV_TEXT类型为CHAR30的可选变量。 2.创建Form（1）创建Form和上面创建Interface的初始界面一样。在Form的输入框中输入该Form的名称，然后点击创建。 创建时需要我们输入当前Form的描述与与Form相绑定的Interface对象名称。 （2）添加接口变量按照上面的步骤创建好Form后左侧是Interface，右侧是Form的Context。我们展开左侧Interface的所有页签，可以在Import页签下看到我们绑定的上面创建的Interface的参数。 System Fields是系统的标准字段。可以理解为SY开头的系统变量。这些变量在Form中固定存在。 介绍完界面，我们将从Import页签中的IV_TEXT变量拖动到右边的YADOBE_FORM_DEMO1页签下。当然你也可以手动添加这些变量，但是这样你就需要将变量的所有属性信息都自己手动添加过去。从效率和可靠性方面考量，建议还是直接拖动过去更为推荐。 将变量拖动过去之后会在界面的最下面显示该参数的属性信息。这些信息中会显示该参数的名称、描述、状态、以及数据源(Data -&gt; Field)。这里的参数名称是可以修改的，修改之后就可以在Form中以这个名称进行引用。例如我们将IV_TEXT的名称修改为GV_TEXT。 （3）Form Builder中的上下文在Context(Form Context)中，指定从接口复制到表单的数据。还可以将此数据作为节点包含在层次结构中。在层次结构中还可以指定处理节点的条件来决定表单逻辑。 可以简单理解为Context为Form中的全局对象声明区域，类似于Report中的 TOP Include一样。既如此，没有在Context中进行引用的变量是无法在Form中进行使用的。如果你在Interfce中定义了一个变量，但是没有导入Context，那么该变量也就无法在Form中进行使用。 此外就如上面提到的，当你将参数从接口导入到Context中之后，你还可以修改该参数在Form层面部分属性。例如名称等。 （4）设置LayoutLayout界面就是我们正式设置Form样式与内容的地方了。点进Layout页签，可以在左侧看到Hierarchy、Tab Order、Data View等。右侧则是Design、Mater选项。 点击左侧的Data View页签，将需要在表单上打印和显示的Field拖放到Design View。你可以拖动该字段到布局中的任何位置。例如下图所示的内容。 拖动到界面上之后，我们可以在右侧的Object页签中设置该对象的数据，例如他的文本内容等。 3.测试Form（1）直接运行Form将Form保存并激活完成之后，点击上面的运行按钮，填入IV_TEXT变量的之后运行。 运行结果如下所示，与我们在Interface中输入的内容一致。 （2）代码测试编写下面的测试代码，然后直接运行。 1 三、Adobe Form中的Table1.分类在Adobe Form中有两种用来展示表格的方式。 Table Object SubForm 2.介绍（1）Table Object① 优点 简单，容易实现。当我们之后很少的一部分字段时可以使用该对象快速构建表格。 允许你选择行或列。然后调整列的大小。 可以控制在每页上重复表格标题。 ② 缺点 很难处理嵌套表。 打印非标准表格时存在限制条件。 如果停用Context中的部分字段时，在Table Object中想要使用该字段时就会变得异常困难。 （2）SubForm① 优点 布置表格时很灵活，当打印多行表格时，子表单更有用。 可以根据要求重写排列SubForm中的单元格。 当需要在表单中打印嵌套表单时，SubForm更有用。 没有什么很明显的缺点，如果我们希望在分页符的情况下重复标题，则必须使用”Overflow Leaders“。可以在对象面板的“Pagination”选项卡上设置该属性。 在实际使用过程中经常会使用到SubForm，但如果打印的是标准表时则建议直接使用Table Object，因为这样最简单。 3.创建Interface（1）创建Interface使用事务代码：SPF，打开Adobe Form的界面。选中Interface单选按钮，输入Interface Name并点击创建按钮。 填入接口描述，点击保存按钮。 （2）填入输入参数在接口的Import中填入一个输入内表参数。 在Adobe Form的函数模块中如果要传递表类型的参数，则类型必须是一个表类型。 完成之后保存并激活Adobe Form的Interface。 4.Table Object（1）创建Table Object返回到刚刚的创建界面。选中Form单选按钮，在其中输入Form的名称。然后点击创建按钮。 输入Form的描述与绑定的Interface名称。 （2）绑定接口参数到Form在 Context 页签中，展开 Interface 的 Import 参数文件夹，将输入参数 IT_KNA1 拖动到 Form 的 Context 中。 （3）确认打印字段导入的参数结构十分庞大，存在很多我们不需要展示使用的字段。所以我们可以在 Form 的 Context 中将表类型参数展开。然后选中不需要展示的。点击鼠标右键，选择 deactivate。 被排除的字段后面会有一个灰色的叉。后续在Form中虽然可以使用 IT_KNA1 这个内表对象，但是无法引用到被打了叉的内表字段。 （4）插入文本标题点击 Form 横排按钮中的 Insert 按钮，选择 Standard ，再选择 Text 对象。 修改文本对象中的内容。并根据需要设置文本的属性信息。例如设置字体样式或设置 Layout 的排序方式等。 （5）打开字体工具栏如果你没有找到字体工具栏，可以按照下面的步骤打开工具栏。出来字体工具栏外，还有其他很多工具栏都可以在这里打开。可以根据自己的需要选择对应的工具栏打开。Palettes –&gt; Font。 （6）拖放数据到布局打开左侧的 Data View 页签，选中通过接口传入的内表变量 IT_NAK1 ，然后拖放到右侧的页面中。 你可以在这个位置手动调整列的宽度或者高度。也可以使用右侧的属性栏中对列进行精准的属性设置。 （7）数据翻页默认情况下，如果 IT_KNA1 中的数据超过一页是不会自动翻到下一页的。如果希望能通过翻页将所有数据展示出来的话，可以按照下面的操作进行设置。 ① Subform 设置为 Flowed选中图中红框圈中的 Subform 对象，在右侧的 Object 属性页签中设置 Content 为 Flowed。 ② 设置内表允许使用分页符选中内表变量 IT_KNA1，在右侧的 Object 属性中勾选上复选框 “ Allow Page Breaks Within Content ”（允许在内容中使用分页符）。 （8）设置数据排序在某些国家或者地区，查看数据是从右到左查看数据的。但是SAP中默认的是从左到右排列数据的。此时可以通过设置 IT_KNA1 的 Object 属性中的 Layout 来实现需求。 ① 从左到右(默认) ② 从右到左 可以看到经过从右到左设置之后列的顺序被颠倒了。 （9）测试Table Object使用下面的代码进行测试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576**&amp;&amp;~~ Data ObjectsDATA: GV_FM_NAME TYPE RS38L_FNAM, &quot; FM Name GS_FP_DOCPARAMS TYPE SFPDOCPARAMS, GS_FP_OUTPUTPARAMS TYPE SFPOUTPUTPARAMS, GT_KNA1 TYPE STANDARD TABLE OF KNA1.&quot;Your Adobe Form NameCONSTANTS : GV_FORM_NAME TYPE FPNAME VALUE &#x27;YADOBE_FORM_DEMO2&#x27;.*======================================================================** START of TREATMENT **======================================================================*START-OF-SELECTION. SELECT * FROM KNA1 INTO TABLE GT_KNA1 UP TO 50 ROWS.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open* CALL FUNCTION &#x27;FP_JOB_OPEN&#x27; CHANGING IE_OUTPUTPARAMS = GS_FP_OUTPUTPARAMS EXCEPTIONS CANCEL = 1 USAGE_ERROR = 2 SYSTEM_ERROR = 3 INTERNAL_ERROR = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error Handling ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Get the Function module name based on Form Name* CALL FUNCTION &#x27;FP_FUNCTION_MODULE_NAME&#x27; EXPORTING I_NAME = GV_FORM_NAME IMPORTING E_FUNCNAME = GV_FM_NAME. IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error Handling ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Take the FM name by execuing the form - by using Pattern-**&amp;&amp;~~ call that FM and replace the FM Name by gv_fm_name***&amp;&amp;~~ Call the Generated FM CALL FUNCTION GV_FM_NAME &quot;&#x27;/1BCDWB/SM00000176&#x27; EXPORTING /1BCDWB/DOCPARAMS = GS_FP_DOCPARAMS IT_KNA1 = GT_KNA1 EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open* CALL FUNCTION &#x27;FP_JOB_CLOSE&#x27;. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.*&amp;---------------------------------------------------------------------**&amp;---- Close the spool job CALL FUNCTION &#x27;FP_JOB_CLOSE&#x27; EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC &lt;&gt; 0.* &lt;error handling&gt; ENDIF.*&amp;---------------------------------------------------------------------* 5.Sub Forms跳过创建步骤，直接进入到布局设计界面。因为前面包括创建Form、绑定数据和设置打印字段都是一样的操作。所以这里不再复述了。 通过使用这种方法，我们可以暗中任意顺序显示字段，并以多行显示字段。 （1）确定打印字段和上面Table Object的操作一样，这里去掉了一个字段Name2。所以这里就只展示绑定的数据字段。 （2）确认布局默认情况下，每个表单都具有Master Page和Body Page（无标题子表单 Page1）。在Simple定义中，可以使用Master Page打印头数据，Body Page打印项目数据。在Master Page页面中打印标题内容。 我们还可以在选中Master Page后在右边的Layout页签中或界面上调整Master Page的大小和区域。 （3）设置子表单为 FLOWED如果要打印Table数据，则必须设置子表单的Content属性为FLOWED。 （4）插入SubForm在子表单上右键，选择Insert Subform。插入SubForm对象。 （5）设置SubForm属性可以在当前的页面，对插入的SubForm调整属性。例如调整他的高度或宽度。还可以移动他到其他位置等。 我们先将这个SubForm重命名为Header，因为计划将他作为Table的标题内容。 修改Header对象的Content为Flowed，并将Flow direction修改为Western text。以便字段并排显示。 （6）设置表格标题-插入文本字段接下来设置表格的标题部分。这部分使用文本字段的方式显示内容。 插入文本字段后，修改该对象的属性。让其能作为表格的标题进行显示。修改的内容有以下几个内容。 Appearance(Object -&gt; Field)：None Position(Layout)：None Type(Object -&gt; Value)：Read Only 修改边框颜色为纯色 将设置好的Text Field复制四份，然后显示在同一行。修改Text Field的名称方便区分。并在Value页签中设置Hard Coded用于在表单中进行显示。 （7）打印Item数据-创建Item子表单使用和上面插入Header子表单一样的方式，插入一个Items子表单。然后将Header中的5个Text Field复制到Items子表单中。 同时修改Items表单的content为Flowed，Flow direction为Western text。 （8）打印Item数据-表单绑定数据表在Items表单的Binding页签中，将从Interface中传过来的IT_KNA1变量绑定在此处。 （9）打印Item数据-映射TextField将数据映射到Items表单的TextField字段上。数据与字段的映射关系如下： CustomerNo &lt;—-&gt; KUNNR CustomerNo &lt;—-&gt; LAND1 Name &lt;—-&gt; NAME1 Street &lt;—-&gt; STRAS City &lt;—-&gt; ORT01 将其余字段按照同样的方式绑定完成。完成之后回到Items子表单确保Repeat Subform复选框是勾选的状态。 （10）测试Sub Forms测试的代码和上面的内容一样，只不过Adobe Form的名称不一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576**&amp;&amp;~~ Data ObjectsDATA: GV_FM_NAME TYPE RS38L_FNAM, &quot; FM Name GS_FP_DOCPARAMS TYPE SFPDOCPARAMS, GS_FP_OUTPUTPARAMS TYPE SFPOUTPUTPARAMS, GT_KNA1 TYPE STANDARD TABLE OF KNA1.&quot;Your Adobe Form NameCONSTANTS : GV_FORM_NAME TYPE FPNAME VALUE &#x27;YADOBE_FORM_DEMO2_SUBFORM1&#x27;.*======================================================================** START of TREATMENT **======================================================================*START-OF-SELECTION. SELECT * FROM KNA1 INTO TABLE GT_KNA1 UP TO 50 ROWS.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open* CALL FUNCTION &#x27;FP_JOB_OPEN&#x27; CHANGING IE_OUTPUTPARAMS = GS_FP_OUTPUTPARAMS EXCEPTIONS CANCEL = 1 USAGE_ERROR = 2 SYSTEM_ERROR = 3 INTERNAL_ERROR = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error Handling ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Get the Function module name based on Form Name* CALL FUNCTION &#x27;FP_FUNCTION_MODULE_NAME&#x27; EXPORTING I_NAME = GV_FORM_NAME IMPORTING E_FUNCNAME = GV_FM_NAME. IF SY-SUBRC &lt;&gt; 0. &quot; Suitable Error Handling ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Take the FM name by execuing the form - by using Pattern-**&amp;&amp;~~ call that FM and replace the FM Name by gv_fm_name***&amp;&amp;~~ Call the Generated FM CALL FUNCTION GV_FM_NAME &quot;&#x27;/1BCDWB/SM00000176&#x27; EXPORTING /1BCDWB/DOCPARAMS = GS_FP_DOCPARAMS IT_KNA1 = GT_KNA1 EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.*&amp;---------------------------------------------------------------------***&amp;&amp;~~ Form Processing: Call Form - Open* CALL FUNCTION &#x27;FP_JOB_CLOSE&#x27;. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.*&amp;---------------------------------------------------------------------**&amp;---- Close the spool job CALL FUNCTION &#x27;FP_JOB_CLOSE&#x27; EXCEPTIONS USAGE_ERROR = 1 SYSTEM_ERROR = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC &lt;&gt; 0.* &lt;error handling&gt; ENDIF.*&amp;---------------------------------------------------------------------* 直接展示打印的PDF内容如下所示。 四、参考资料本片学习笔记的参考资料如下所示： SAP Adobe Interactive Form Tutorial. Part I. First Adobe Form SAP Adobe Interactive Form Tutorial. Part II. Tables in Adobe Form 如果你有什么建议或者发现上面笔记中的错误，欢迎在博客评论留言告知我，十分感谢。","categories":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/categories/Adobe-Form/"}],"tags":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/tags/Adobe-Form/"}]},{"title":"RTTS动态结构创建","slug":"ABAP/动态结构创建/RTTS动态结构创建","date":"2024-08-13T12:54:42.000Z","updated":"2024-08-14T04:57:37.108Z","comments":true,"path":"2024/08/13/ABAP/动态结构创建/RTTS动态结构创建/","link":"","permalink":"https://www.yemaojun.top/2024/08/13/ABAP/%E5%8A%A8%E6%80%81%E7%BB%93%E6%9E%84%E5%88%9B%E5%BB%BA/RTTS%E5%8A%A8%E6%80%81%E7%BB%93%E6%9E%84%E5%88%9B%E5%BB%BA/","excerpt":"最近接了一个需要将XML转换为ABAP内表的开发需求。目前已经将XML的内容读进内存了，但是因为XML嵌套的结构太多也太深，所以常用的通过字段目录创建动态结构的方法无法满足业务需求。所以通过向同事打听与查阅资料，发现了SAP关于RTTC创建动态结构的内容可以满足很深层次的动态结构创建。 现已将其封装成一个工具Function，通过输入想要创建的动态结构内容，然后就可以拿到一个引用类型的对象。","text":"最近接了一个需要将XML转换为ABAP内表的开发需求。目前已经将XML的内容读进内存了，但是因为XML嵌套的结构太多也太深，所以常用的通过字段目录创建动态结构的方法无法满足业务需求。所以通过向同事打听与查阅资料，发现了SAP关于RTTC创建动态结构的内容可以满足很深层次的动态结构创建。 现已将其封装成一个工具Function，通过输入想要创建的动态结构内容，然后就可以拿到一个引用类型的对象。 RTTS动态结构创建 一、运行时类型服务（RTTS）1.介绍RTTS是使用类型描述类的层次结构实现的，这些类别包含运行时类型创建（RTTC）和运行时类型标识（RTTI）的方法。使用这些标准类可以在运行时动态创建ABAP中的结构。 通过在运行时设置由标准类提供的CL_ABAP_STRUCTDESCR&#x3D;&gt;COMPONENT_TABLE类型的内表内容，然后使用该内表创建新的结构体对象&#x2F;内表对象。之后在CREATE DATA语句中在TYPE关键词之后使用HANDLE指定新的结构体对象&#x2F;内表对象后就可以拿到这些新对象的应用变量进行操作了。 上面的内容不明白可以继续往后看，看过实例之后就会有比较清晰的认识了。 2.标准类的层次结构 我们主要使用到的类就是上面的内容。通过类的名称与描述信息可以确定自己创建动态结构时需要使用到的具体是哪一个标准类。 类名 作用 CL_ABAP_TYPEDESCR 动态类型类。 CL_ABAP_DATADESCR 变量生成类，可以将由其子类生成的对象传递给该类的对象。然后引用变量直接参照该类的对象创建对象。 CL_ABAP_ELEMDESCR 数据元素生成类，可以根据数据元素生成对象，也可以根据基本数据类型生成变量。 CL_ABAP_ENUMDESCR 枚举类型生成类。 CL_ABAP_REFDESCR 引用类型生成类，可以生成引用类型变量。 CL_ABAP_COMPLEXDESCR 组件生成类，一般不会使用该类生成对象，而是使用它的两个子类来生成结构体与内表对象。 CL_ABAP_STRUCTDESCR 结构体生成类，可以根据上面提到的该类COMPONENT_TABLE类型的变量动态生成结构体对象。 CL_ABAP_TABLEDESCR 内表生成类，需要和上面的结构体生成类对象一起使用，由结构体生成类对象确定内表的结构，然后再根据内表生成类中的其余属性来确定需要生成的内表是什么类型（标准、排序…）的与主键信息等。 CL_ABAP_OBJECTDESCR 对象生成父类，用于生成Object对象的类，主要使用的也是其两个子类来生成对象。 CL_ABAP_CLASSDESCR 类生成对象类，通过传入的自定义类内容来定义和生成对象。 CL_ABAP_INTFDESCR 接口生成队形类，和上面根据类生成对象类似，通过传入自定义的接口内容，创建对象。 二、动态对象生成的核心逻辑1.根据DDIC结构生成内表（1）说明直接参照DDIC结构生成结构体或内表对象。DDIC结构一般指在SE11中定义的结构、数据库表等对象。 （2）实例参照航班表 SFLIGHT 创建内表。 12345678910111213141516171819202122TRY. &quot;将DDIC的结构名称传入结构体定义对象 DATA(LO_STRUCT_DESC) = CL_ABAP_STRUCTDESCR=&gt;DESCRIBE_BY_NAME( &#x27;SFLIGHT&#x27; ). &quot;根据上面的结构体对象创建内表对象 DATA(LO_TABLE_DESC) = CL_ABAP_TABLEDESCR=&gt;CREATE( P_LINE_TYPE = CAST #( LO_STRUCT_DESC ) &quot;内表的结构 P_TABLE_KIND = CL_ABAP_TABLEDESCR=&gt;TABLEKIND_STD &quot;内表类型 P_UNIQUE = ABAP_FALSE ). &quot;使用引用变量创建内表对象 DATA LO_TABLE TYPE REF TO DATA. CREATE DATA LO_TABLE TYPE HANDLE LO_TABLE_DESC. &quot;请注意此处必须在TYPE关键词后使用HANDLE关键词 &quot;使用指针指向生成的内表 FIELD-SYMBOLS &lt;FT_TABLE&gt; TYPE ANY TABLE. ASSIGN LO_TABLE-&gt;* TO &lt;FT_TABLE&gt;. CATCH CX_ROOT INTO DATA(LO_ERROR). DATA(LV_MESSAGE) = LO_ERROR-&gt;GET_TEXT( ).ENDTRY. 生成的内表结构与DDIC对应的航班表SFLIGHT结构一致。 2.动态组件生成内表（1）说明接下来的这种方式是在运行时通过传入cl_abap_structdescr&#x3D;&gt;component_table类型内表中的字段名、字段类型等信息去动态生成内表对象的。字段类型可以是基本数据类型，也可以是数据元素和CL_ABAP_COMPLEXDESCR与其子类对象。设置完成该内表值后再使用**cl_abap_structdescr&#x3D;&gt;create( )**方法根据内表值生成结构体对象。有了结构体对象之后创建内表的方法就和上面一样了。 （2）实例123456789101112131415161718192021222324252627282930313233343536373839404142434445TRY. DATA LV_FLDATE TYPE SFLIGHT-FLDATE. &quot;填充动态组件的属性内表 DATA(LT_COMPONENTS) = VALUE CL_ABAP_STRUCTDESCR=&gt;COMPONENT_TABLE( &quot;创建一个字段名为CARRID，类型为C类型长度为3位的字段 ( NAME = &#x27;CARRID&#x27; TYPE = CL_ABAP_ELEMDESCR=&gt;GET_C( 3 ) ) &quot;创建一个字段名为CONNID，类型为N类型长度为4位的字段 ( NAME = &#x27;CONNID&#x27; TYPE = CL_ABAP_ELEMDESCR=&gt;GET_N( 4 ) ) &quot;创建一个字段名为CARRNAME，类型参照数据元素S_CARRNAME的字段 ( NAME = &#x27;CARRNAME&#x27; TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;DESCRIBE_BY_NAME( &#x27;S_CARRNAME&#x27; ) ) ) &quot;创建一个字段名为FLDATE，类型参照程序已有变量LV_FLDATE的字段 ( NAME = &#x27;FLDATE&#x27; TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;DESCRIBE_BY_DATA( LV_FLDATE ) ) ) ). &quot;根据动态组件内表生成结构体对象 DATA(LO_STRUCT_DESC) = CL_ABAP_STRUCTDESCR=&gt;CREATE( LT_COMPONENTS ). &quot;根据上面的结构体对象创建内表对象 DATA(LO_TABLE_DESC) = CL_ABAP_TABLEDESCR=&gt;CREATE( P_LINE_TYPE = CAST #( LO_STRUCT_DESC ) &quot;内表的结构 P_TABLE_KIND = CL_ABAP_TABLEDESCR=&gt;TABLEKIND_STD &quot;内表类型 P_UNIQUE = ABAP_FALSE P_KEY = VALUE #( ( NAME = &#x27;CARRID&#x27; ) ( NAME = &#x27;CONNID&#x27; ) ) P_KEY_KIND = CL_ABAP_TABLEDESCR=&gt;KEYDEFKIND_USER ). &quot;使用引用变量创建内表对象 DATA LO_TABLE TYPE REF TO DATA. CREATE DATA LO_TABLE TYPE HANDLE LO_TABLE_DESC. &quot;请注意此处必须在TYPE关键词后使用HANDLE关键词 &quot;使用指针指向生成的内表 FIELD-SYMBOLS &lt;FT_TABLE&gt; TYPE ANY TABLE. ASSIGN LO_TABLE-&gt;* TO &lt;FT_TABLE&gt;. CATCH CX_ROOT INTO DATA(LO_ERROR). DATA(LV_MESSAGE) = LO_ERROR-&gt;GET_TEXT( ).ENDTRY. 可以看到根据已有变量创建的字段类型会和变量的类型保持一致。变量LV_FLDATE的类型是日期类型的，所以参照该变量定义的字段也是日期类型的。 三、动态生成组件工具函数1.程序源码（1）函数源码123456789101112131415161718192021222324252627282930313233343536*&quot;----------------------------------------------------------------------*&quot;*&quot;本地接口：*&quot; EXPORTING*&quot; REFERENCE(ER_REF) TYPE REF TO DATA*&quot; REFERENCE(EV_MESSAGE) TYPE STRING*&quot; TABLES*&quot; IT_DEFINITION TYPE ZTT_TYPE_DEFINITION*&quot; EXCEPTIONS*&quot; INPUT_TABLE_EMPTY*&quot; INPUT_TABLE_DATA_EXCEPTION*&quot; INPUT_TABLE_FIELDNAME_EMPTY*&quot; STRUCTURAL_HIERARCHY_ANOMALIES*&quot;----------------------------------------------------------------------*--------------------------Variables-----------------------------------* DATA: LV_TABIX TYPE SY-TABIX VALUE 1, &quot;表索引 LV_KIND TYPE C, &quot;生成对象的类型 S 结构体 T 内表* LT_COMPONENTS TYPE ABAP_COMPONENT_TAB, LO_OBJECT TYPE REF TO CL_ABAP_DATADESCR.&quot;返回的组件对象*----------------------------Logic-------------------------------------* &quot;Input data non-null judgment IF IT_DEFINITION[] IS INITIAL. RAISE INPUT_TABLE_EMPTY. ENDIF. &quot;设置对象类型 CLEAR: IT_DEFINITION. PERFORM GET_OBJECT TABLES IT_DEFINITION* LT_COMPONENTS USING IT_DEFINITION LV_KIND CHANGING LV_TABIX LO_OBJECT EV_MESSAGE. &quot;创建参考对象 CREATE DATA ER_REF TYPE HANDLE LO_OBJECT. ASSIGN ER_REF-&gt;* TO FIELD-SYMBOL(&lt;FO_OBJECT&gt;). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200FORM GET_OBJECT TABLES PT_DEFINITION TYPE ZTT_TYPE_DEFINITION* PT_COMPONENTS TYPE ABAP_COMPONENT_TAB USING VALUE(PS_DEFINITION) TYPE ZTS_TYPE_DEFINITION VALUE(PV_KIND) TYPE C CHANGING VALUE(PV_TABIX) TYPE SY-TABIX VALUE(PO_OBJECT) TYPE REF TO CL_ABAP_DATADESCR VALUE(EV_MESSAGE) TYPE STRING.*--------------------------Variables-----------------------------------* CONSTANTS: LC_I TYPE C LENGTH 1 VALUE &#x27;I&#x27;, LC_F TYPE C LENGTH 1 VALUE &#x27;F&#x27;, LC_P TYPE C LENGTH 1 VALUE &#x27;P&#x27;, LC_C TYPE C LENGTH 1 VALUE &#x27;C&#x27;, LC_N TYPE C LENGTH 1 VALUE &#x27;N&#x27;, LC_D TYPE C LENGTH 1 VALUE &#x27;D&#x27;, LC_T TYPE C LENGTH 1 VALUE &#x27;T&#x27;, LC_X TYPE C LENGTH 1 VALUE &#x27;X&#x27;. DATA: LT_KEY TYPE ABAP_KEYDESCR_TAB, LV_TYPE TYPE REF TO CL_ABAP_DATADESCR, LV_KIND TYPE C, &quot;S 结构体 T 内表 LV_LEVEL TYPE I, LV_LENGTH TYPE I, LV_DECIMALS TYPE I, LT_COMPONENTS TYPE ABAP_COMPONENT_TAB, LO_TABLE_DESC TYPE REF TO CL_ABAP_TABLEDESCR.*----------------------------Logic-------------------------------------* TRY. &quot;记录当前递归中的层级 LV_LEVEL = PT_DEFINITION[ PV_TABIX ]-LEVEL. &quot;层级判断，递归中的层级只能比上一层递归的层级高 IF PS_DEFINITION-LEVEL IS NOT INITIAL AND PS_DEFINITION-LEVEL &gt; LV_LEVEL. &quot;当前层级不大于上层递归层级，退出本层递归 &quot;递归层级异常，请检查动态表结构内容 EV_MESSAGE = TEXT-E01. RAISE STRUCTURAL_HIERARCHY_ANOMALIES. ENDIF. LOOP AT PT_DEFINITION FROM PV_TABIX WHERE LEVEL = LV_LEVEL. PV_TABIX = SY-TABIX. &quot;判断是否是普通字段/结构/表类型 IF PT_DEFINITION-KIND IS INITIAL AND PT_DEFINITION-ELEMENT IS INITIAL AND PT_DEFINITION-TYPE IS INITIAL. &quot;结构体 &quot;设置创建的类型标识 LV_KIND = &#x27;S&#x27;. PV_TABIX = PV_TABIX + 1. &quot;递归调用，获取结构体对象 PERFORM GET_OBJECT TABLES PT_DEFINITION* PT_COMPONENTS USING PT_DEFINITION LV_KIND CHANGING PV_TABIX PO_OBJECT EV_MESSAGE. CHECK EV_MESSAGE IS INITIAL. &quot;将结构对象传入内表 LV_TYPE ?= PO_OBJECT. LT_COMPONENTS = VALUE #( BASE LT_COMPONENTS ( NAME = PT_DEFINITION-FIELD TYPE = LV_TYPE ) ). ELSEIF PT_DEFINITION-KIND IS NOT INITIAL AND PT_DEFINITION-ELEMENT IS INITIAL AND PT_DEFINITION-TYPE IS INITIAL. &quot;表类型 &quot;判断是否是第一条数据 IF PV_TABIX = 1 AND PT_DEFINITION-FIELD IS INITIAL AND PT_DEFINITION-LEVEL = 1. DATA(LV_EXIT_FLAG) = &#x27;X&#x27;. ENDIF. &quot;设置创建的类型标识 LV_KIND = &#x27;T&#x27;. PV_TABIX = PV_TABIX + 1. &quot;递归调用，获取结构体对象 PERFORM GET_OBJECT TABLES PT_DEFINITION* PT_COMPONENTS USING PT_DEFINITION LV_KIND CHANGING PV_TABIX PO_OBJECT EV_MESSAGE. CHECK EV_MESSAGE IS INITIAL. &quot;退出判断 IF LV_EXIT_FLAG IS NOT INITIAL. &quot;是，则代表创建的结构一开始就是一个内表 EXIT. ELSE. &quot;将结构对象传入内表 LV_TYPE ?= PO_OBJECT. LT_COMPONENTS = VALUE #( BASE LT_COMPONENTS ( NAME = PT_DEFINITION-FIELD TYPE = LV_TYPE ) ). ENDIF. ELSEIF PT_DEFINITION-KIND IS INITIAL AND ( PT_DEFINITION-ELEMENT IS NOT INITIAL OR PT_DEFINITION-TYPE IS NOT INITIAL ). &quot;普通字段类型 IF PT_DEFINITION-ELEMENT IS NOT INITIAL. &quot;参照DataElement LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;DESCRIBE_BY_NAME( PT_DEFINITION-ELEMENT ) ). ELSE. &quot;基本数据类型 LV_LENGTH = PT_DEFINITION-LENG. LV_DECIMALS = PT_DEFINITION-DECIMALS. CASE PT_DEFINITION-TYPE. WHEN LC_I. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_I( ) ). WHEN LC_F. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_F( ) ). WHEN LC_P. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_P( P_LENGTH = LV_LENGTH P_DECIMALS = LV_DECIMALS ) ). WHEN LC_C. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_C( P_LENGTH = LV_LENGTH ) ). WHEN LC_N. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_N( P_LENGTH = LV_LENGTH ) ). WHEN LC_D. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_D( ) ). WHEN LC_T. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_T( ) ). WHEN LC_X. LV_TYPE = CAST #( CL_ABAP_ELEMDESCR=&gt;GET_X( P_LENGTH = LV_LENGTH ) ). WHEN OTHERS. ENDCASE. ENDIF. IF PT_DEFINITION-KEY IS NOT INITIAL. LT_KEY = VALUE #( BASE LT_KEY ( NAME = PT_DEFINITION-FIELD ) ). ENDIF. LT_COMPONENTS = VALUE #( BASE LT_COMPONENTS ( NAME = PT_DEFINITION-FIELD TYPE = LV_TYPE ) ). ENDIF. &quot;判断当前层级是否大于下一层级 IF PV_TABIX &lt; LINES( PT_DEFINITION ). IF LV_LEVEL &gt; PT_DEFINITION[ PV_TABIX + 1 ]-LEVEL. &quot;当前结构的层级已结束 EXIT. ENDIF. ENDIF. CLEAR: PT_DEFINITION. ENDLOOP. &quot;根据判断创建对应的对象 IF LT_COMPONENTS IS NOT INITIAL. CASE PV_KIND. WHEN &#x27;S&#x27;. DATA(LO_STRUCT_DESC) = CL_ABAP_STRUCTDESCR=&gt;CREATE( LT_COMPONENTS ). WHEN &#x27;T&#x27;. LO_STRUCT_DESC = CL_ABAP_STRUCTDESCR=&gt;CREATE( LT_COMPONENTS ). LO_TABLE_DESC = CL_ABAP_TABLEDESCR=&gt;CREATE( P_LINE_TYPE = LO_STRUCT_DESC P_TABLE_KIND = PS_DEFINITION-KIND P_UNIQUE = ABAP_FALSE P_KEY = LT_KEY P_KEY_KIND = COND #( WHEN PS_DEFINITION-KEY_KIND IS INITIAL THEN CL_ABAP_TABLEDESCR=&gt;KEYDEFKIND_DEFAULT ELSE PS_DEFINITION-KEY_KIND ) ). WHEN OTHERS. LO_STRUCT_DESC = CL_ABAP_STRUCTDESCR=&gt;CREATE( LT_COMPONENTS ). ENDCASE. ENDIF. &quot;将对象返回 IF LO_TABLE_DESC IS BOUND. PO_OBJECT ?= LO_TABLE_DESC. ELSEIF LO_STRUCT_DESC IS BOUND. PO_OBJECT ?= LO_STRUCT_DESC. ENDIF. MOVE-CORRESPONDING PS_DEFINITION TO PT_DEFINITION. CATCH CX_ROOT INTO DATA(LO_ERROR). EV_MESSAGE = LO_ERROR-&gt;GET_TEXT( ). ENDTRY. FREE: LT_KEY,LT_COMPONENTS.ENDFORM. （2）传入参数结构ZTT_TYPE_DEFINITION为表类型，其参照的结构为ZTS_TYPE_DEFINITION。 下面是参数的说明与参考值信息。 字段名 描述 参考值 参考值说明&#x2F;备注 LEVEL 层级 若是简单无嵌套动态结构可不输入 FIELD 字段名称 动态组件的字段名 KEY 关键标识字段 内表中的主键标记字段，主要在排序表中使用 KEY_KIND 关键字段类型 和上面的类型一起使用，关键字段的类型 CL_ABAP_TABLEDESCR&#x3D;&gt;KEYDEFKIND_DEFAULT 默认类型 CL_ABAP_TABLEDESCR&#x3D;&gt;KEYDEFKIND_TABLELINE 表主键（一般用于从DDIC创建内表主字段使用） CL_ABAP_TABLEDESCR&#x3D;&gt;KEYDEFKIND_TABLELINE 用户自定义键 CL_ABAP_TABLEDESCR&#x3D;&gt;KEYDEFKIND_EMPTY 用户自定义键 KIND 表类型 CL_ABAP_TABLEDESCR&#x3D;&gt;TABLEKIND_ANY 泛型表 CL_ABAP_TABLEDESCR&#x3D;&gt;TABLEKIND_STD 标准表 CL_ABAP_TABLEDESCR&#x3D;&gt;TABLEKIND_INDEX 索引表 CL_ABAP_TABLEDESCR&#x3D;&gt;TABLEKIND_HASHED Hash表 CL_ABAP_TABLEDESCR&#x3D;&gt;TABLEKIND_SORTED 排序表 ELEMENT 数据元素 (语义域) 和下面的TYPE、LENG与DECIMALS类似，都是用来控制字段类型的，但是填写了数据元素后下面的TYPE、LENG与DECIMALS就可以不用填写了，反之填写了TYPE、LENG与DECIMALS就可以不用填写ELEMENT了。 TYPE ABAP 数据类型(C,D,N,…) 基本数据类型，I、F、P、C、N、D、T和X LENG 长度（字符数） 变量的长度，只有P、C、N与X类型需要填写 DECIMALS 小数位数 小数位长度，只有P类型需要填写 PARENT 父层级 (暂未使用) 暂未使用到，可以不用添加该字段 2.程序说明该函数主要是适用于上面动态组件生成对象的逻辑。即填充cl_abap_structdescr&#x3D;&gt;component_table类型的内表然后创建结构体与内表对象。暂时未添加根据DDIC结构创建动态结构的功能，因为直接根据DDIC结构创建动态结构的方法很多。 该函数主要是用来动态创建发杂的&#x2F;深层级的组件对象的。例如结构体嵌套结构体&#x2F;内表、内表嵌套结构体&#x2F;内表，然后他们嵌套的子结构还可以继续嵌套更深层级的组件对象时，可以使用该工具函数创建这些组件对象。 3.使用说明（1）结构体创建① 输入参数参考如果要创建一个结构体，只需要将结构体中字段名称和字段类型填写上即可。 LEVEL FIELD KEY KEY_KIND KIND ELEMENT TYPE LENG DECIMALS 1 FIELD1 CHAR10 1 FIELD2 C 10 1 FIELD3 P 10 2 ② 程序执行结果 （2）内表创建① 输入参数参考创建内表时，在输入参数的第一条数据中写上层级与表类型即可，然后在第二行写上表字段的名称层级与类型信息。KIND为S代表标准表，在上面的参考值中对应CL_ABAP_TABLEDESCR&#x3D;&gt;TABLEKIND_STD。 LEVEL FIELD KEY KEY_KIND KIND ELEMENT TYPE LENG DECIMALS 1 S 2 FIELD1 C 10 2 FIELD2 P 10 2 2 FIELD3 SYDATUM ② 程序执行结果 （3）复杂结构-结构体嵌套结构体&#x2F;内表如果涉及到深层的例如结构体嵌套结构体&#x2F;内表的情况，则按照下面的方式进行即可。同理如果已经嵌套的组件对象中还有更深层次的组件对象，则可以根据他们在嵌套组件中的位置和层级关系继续嵌套。 ① 输入参数参考 LEVEL FIELD KEY KEY_KIND KIND ELEMENT TYPE LENG DECIMALS 1 FIELD1 CHAR10 1 FIELD2 C 10 1 FIELD3 P 10 2 1 STRUCTURE1 2 STRFIELD1 CHAR10 2 STRFIELD2 CHAR10 2 STRFIELD3 CHAR10 2 STRUCTURE2 3 STRFIELD2_1 CHAR10 3 STRFIELD2_2 CHAR10 1 TABLE S 2 TABFIELD1 CHAR10 2 TABFIELD2 CHAR10 2 TABFIELD3 CHAR10 ② 程序执行结果 （4）复杂结构-内表嵌套结构体&#x2F;内表在外层的内表中嵌套了结构体STRUCTURE之后，有嵌套了内表TABLE1。在TABLE1内部又再次嵌套了TABLE2. ① 输入参数参考 LEVEL FIELD KEY KEY_KIND KIND ELEMENT TYPE LENG DECIMALS 1 S 2 FIELD1 CHAR10 2 FIELD2 C 10 2 FIELD3 P 10 2 2 STRUCTURE 3 STRFIELD1 CHAR10 3 STRFIELD2 CHAR10 2 FIELD4 2 TABLE1 S 3 TAB1FIELD1 CHAR10 3 TAB1FIELD2 CHAR10 3 TAB1FIELD3 CHAR10 3 TABLE2 S 4 TAB2FIELD1 CHAR10 4 TAB2FIELD2 CHAR10 3 TAB1FIELD4 CHAR10 ② 程序执行结果通过断点调试新增一行初始值可以看的更直观一些。 返回的第一层内表结构图下所示。 第一层内表中的STRUCTURE结构如下图所示。 第一层内表中的TABLE1结构如下图所示。 第二层内表中的TABLE2结构如下图所示。 可以看到创建出来的复杂结构对象满足一开始设计的内容。 四、参考资料How To Create A Dynamic Internal Table Using RTTS Runtime Type Services (RTTS)","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Dynamic Create","slug":"ABAP/Dynamic-Create","permalink":"https://www.yemaojun.top/categories/ABAP/Dynamic-Create/"},{"name":"RTTC","slug":"RTTC","permalink":"https://www.yemaojun.top/categories/RTTC/"},{"name":"ABAP工具类","slug":"ABAP工具类","permalink":"https://www.yemaojun.top/categories/ABAP%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP-更换程序的Package与请求号","slug":"ABAP/ABAP杂项记录/SAP-更换程序的Package与请求号/SAP-更换程序的Package与请求号","date":"2024-07-01T04:42:00.000Z","updated":"2024-07-01T04:46:33.288Z","comments":true,"path":"2024/07/01/ABAP/ABAP杂项记录/SAP-更换程序的Package与请求号/SAP-更换程序的Package与请求号/","link":"","permalink":"https://www.yemaojun.top/2024/07/01/ABAP/ABAP%E6%9D%82%E9%A1%B9%E8%AE%B0%E5%BD%95/SAP-%E6%9B%B4%E6%8D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84Package%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8F%B7/SAP-%E6%9B%B4%E6%8D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84Package%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8F%B7/","excerpt":"之前做项目的时候碰到需要更换程序或其他文件存放的Package的需求。之前只是简单记录了一下，这次以新建的Rest接口Class为用例，将其从本地迁移至业务包中。","text":"之前做项目的时候碰到需要更换程序或其他文件存放的Package的需求。之前只是简单记录了一下，这次以新建的Rest接口Class为用例，将其从本地迁移至业务包中。 SAP 更换程序的Package与请求号 一、更换Package的步骤1.更换Package的程序本次更换Package的Class类名为：YTEST_RESULT_INTER。 2.使用事务码SE03使用事务代码SE03 –&gt; 修改对象目录条目。 3.输入要修改的对象名在此处输入要变更的对象名称，选择屏幕上有很多种类型可以选择。按照自己的程序类别进行输入和勾选即可。此处请一定记得勾选，不然输入框中输入的对象名是不会被筛选的。 全部填写完成之后点击左上角的运行按钮。进入到下一个变更页面。 4.变更Package按照图中的提示完成Package的变更，之后或许会因为变更包而输入请求号。此处就根据自身的需求操作即可。 5.变更完成重新使用事务代码SE24进入查看Class的属性。发现Package已经变更为修改后的属性了。 二、解除请求号的锁定1.查看请求号的锁定状态 2.解除锁定状态使用事务代码SE03，进入到下面的界面。双击解锁对象（专家工具）。 3.填入解锁的请求号双击上面的按钮后，来到下面的界面。在输入框中填入要解锁的请求号。 4.查看解锁情况 三、移动请求中的对象1.确定要移动的对象本次我们需要将上面红框中的内容移动到下面的请求号中。此处有个注意事项是移动前的对象和移动后的对象所在的请求号类型必须一致。如图中红框圈中的开发&#x2F;更正就是请求号的类型。且被移动的对象不可以被请求号锁定。 2.更改请求号的类型先选中需要变更请求类型的请求号，然后按照最上面的按钮请求&#x2F;任务 –&gt; 更改类型。 在弹框中选择需要变更的请求类型。 3.移动对象选中需要移动的对象，然后点击图中的移动对象按钮。在弹框中输入需要移动到的请求号。此处注意被移动的对象不可以被请求号锁定。 4.移动成功","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Package","slug":"Package","permalink":"https://www.yemaojun.top/categories/Package/"},{"name":"请求号","slug":"请求号","permalink":"https://www.yemaojun.top/categories/%E8%AF%B7%E6%B1%82%E5%8F%B7/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"异步CPI接口配置","slug":"SAP云/CPI/异步CPI接口配置/异步CPI接口配置","date":"2024-07-01T04:34:43.000Z","updated":"2024-07-01T04:40:33.218Z","comments":true,"path":"2024/07/01/SAP云/CPI/异步CPI接口配置/异步CPI接口配置/","link":"","permalink":"https://www.yemaojun.top/2024/07/01/SAP%E4%BA%91/CPI/%E5%BC%82%E6%AD%A5CPI%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE/%E5%BC%82%E6%AD%A5CPI%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE/","excerpt":"前面写了CPI接口的发布、异常处理和日志跟踪等内容，但是在实际开发过程中我们还需要配置一些异步调用的CPI接口。而CPI的异步接口功能十分强大，当消息处理失败时并不会记录一个日志之后就停止了。而是会在记录日志之后将失败的消息再次填充进队列中重复执行。当执行到一定的次数还是失败的话才会停止执行。在每次重处理消息时也会同步更新日志记录的结果，直到执行成功为止。 虽然CPI的异步功能强大且方便，但是其配置却十分简单，和发布一个普通的CPI接口只相差两个步骤。下面对异步的接口发布做一篇记录的笔记。","text":"前面写了CPI接口的发布、异常处理和日志跟踪等内容，但是在实际开发过程中我们还需要配置一些异步调用的CPI接口。而CPI的异步接口功能十分强大，当消息处理失败时并不会记录一个日志之后就停止了。而是会在记录日志之后将失败的消息再次填充进队列中重复执行。当执行到一定的次数还是失败的话才会停止执行。在每次重处理消息时也会同步更新日志记录的结果，直到执行成功为止。 虽然CPI的异步功能强大且方便，但是其配置却十分简单，和发布一个普通的CPI接口只相差两个步骤。下面对异步的接口发布做一篇记录的笔记。 异步CPI接口配置 一、SAP端接口介绍配置CPI的异步接口前需要在SAP端先发布一个Web Service接口获取到SAP端接口的WSDL地址。因为发布Web Service接口之前在《通过Web Service发布CPI接口》这篇笔记中做过介绍，且本篇主要介绍CPI的异步配置。所以就不再介绍如何配置一个Web Service的接口了。 1.SAP端接口逻辑本次使用的SAP接口是：YSFLIGHT_DEMO_01。接口的逻辑如下图所示。 2.接口企业服务由上面的接口配置的企业服务如下图所示。 3.接口WSDL地址通过事务代码SOAMANAGER打开接口的Web Service配置。查看接口的WSDL地址。 二、CPI端异步配置1.新建iFlow进入存放CPI接口的Package，然后点击图中的添加 –&gt; Integration Flow。 在其中填写接口的名称、标识与描述内容，然后点击右下角的添加并在编辑器中打开。 2.创建集成过程进入编辑界面后，虽然已经有一个集成过程组件了。但是异步的接口需要额外的一个集成过程做处理。其实可以理解成异步是一个接口，而处理异步队列消息的集成过程是另一个接口。并且这两个集成过程是可以分成两个单独的iFlow的（这个后面截图简单介绍下）。 3.创建JMS异步队列接下来创建的HTTP适配器与JMC异步队列适配器是该接口的入口。其他系统在调用该接口时，会将请求存储到JMC的队列中。然后再通过JMC队列调用SAP的接口。 设置JMC适配器对象时有其他的几个属性，起作用和说明如下所示。 Queue Name：消息队列名称 **Retention Threshold for Alerting (in d)**：警报的保留阈值（单位：天） **Expiration Period (in d)**：有效期（单位：天） Compress Stored Message：压缩存储的消息 Encrypt Stored Message：加密存储的邮件 Transfer Exchange Properties：传输Exchange属性 4.添加日志记录脚本_Request01和其他接口设置日志记录脚本一样，此处通过脚本记录日志文件。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Request01&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 5.设置接口传入JMS接下来设置的就是接口的处理流程逻辑了，但其实也就是和发布一个普通的接口是一样的。只不过以前传入的适配器对象是HTTPS的适配器，现在因为HTTPS适配器已经将请求全部存储在JMS队列中了。所以在设置传入适配器选项时要将原来的HTTPS适配器修改为JMS适配器并填上JMS的适配器名称。 Queue Name：JMS队列名称 Number of Concurrent Processes：并发进程数 **Retry Interval (in min)**：重试时间间隔（单位：分钟） Exponential Backoff：如果选中，则每次重试不成功后，重试间隔将加倍。 **Maximum Retry Interval (in min)**：最大重试间隔（单位：分钟） Dead-Letter Queue：如果两次重试后无法处理邮件，请选中此复选框将其放入死信队列。 6.添加消息修正符本次还是使用的动态字段匹配方式，所以需要使用内容修正符在外层追加部分类似于命名空间的东西。 7.添加日志记录脚本_Request_XML此处添加的日志记录脚本是正式接口流程中的脚本记录文件，在监控器中会将每个集成流单独识别为一个接口然后单独有一个日志记录的数据。所以此处可以理解为是一个新接口了，所以脚本的文件名为Request_XML。此处的XML没有什么意义，只是手误写成了XML。 此处可以考虑直接复制下面集成过程中的日志记录脚本然后直接在这里引用即可。因为他的JS代码上面已经标注过了，所以此处就不再展示代码了。 8.添加格式转换器 JSON TO XML（1）设置转换器属性进行完成上面的操作之后就可以将JSON形式的报文转换为XML形式的报文然后传递到SAP进行请求处理了。 在命名空间映射处填写的内容如下： JSON Prefix XML Namespace urn urn:sap-com:document:sap:rfc:functions soapenv http://schemas.xmlsoap.org/soap/envelope/ 动态映射SAP字段与外围系统报文的方式。这种方式有如下特征： 报文的字段名和SAP的参数名称完全一致，并且字段名必须全部大写（如果传递的报文有小写字段名会映射不到值）； 当SAP端参数结构发生变化时，只需要在SAP GUI中的企业服务端右键对应的企业服务对象使用“一致性检查”即可； CPI需要在最终的报文外层另包一层用来指向SAP端哪一个RFC的指向，参考内容修正符中Message Body中的内容。 （2）配置接口运行时配置设置完上面的命名空间映射后，还需要配置SAP接口整体的运行时配置。双击界面中的空白位置唤出配置界面。 1xmlns:urn=urn:sap-com:document:sap:soap:functions:mc-style;xmlns:n0=urn:sap-com:document:sap:rfc:functions 9.添加日志记录脚本_Request02添加日志记录脚本，记录经过JSON TO XML转换后的XML数据。便于后期排查问题。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Request_XML&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 10.添加请求回复将消息处理完成之后就可以添加请求回复组件调用接口了。 这里的各项属性参数与意义在《通过Web-Service发布CPI接口》中记录的很清楚了（例如Location ID从哪里获取、Credential Name的创建方式等）。所以这里就只介绍下参数的含义即可。详细的可以参考《通过Web-Service发布CPI接口》。 Address：调用的接口地址 Proxy Type：指定使用的代理类型。 On-Premise：本地部署 Internet：网络部署 Location ID：BTP上配置的SAP服务器名称 URL to WSDL：定义WS提供程序终结点的WSDL的URL service：引用的WSDL中包含的选定服务的名称 Endpoint：引用的WSDL中包含的选定服务（在“服务名称”字段中提供）的选定端点的名称 Operation Name：引用的WSDL中所选服务的操作名称 Authentication：接口调用的权限认证方式 Credential Name：可理解成调用接口时连接对方系统的账号 **Timeout (in ms)**：接口的请求等待时长，单位为毫秒，默认为60秒一分钟时间。 Keep-Alive：选择向服务器发送信号，表示即使在初始请求&#x2F;响应序列结束后，客户机仍希望保持连接的开放。一旦建立连接，直到服务器或客户端关闭才会断开。如果未选择Keep-Alive，则在每个请求&#x2F;响应序列之后自动关闭连接 Compress Message： 启用此WS端点以：向WS提供程序发送压缩的请求消息向WS提供器指示它可以处理压缩的响应消息。 Allow Chunking：选择此选项可以在发送消息时允许HTTP数据块。 Return HTTP Response Code as Header：选择此选项可将HTTP响应代码设置到标头CamelHttpResponseCode中。 Clean-up Request Headers：选择此选项可在接收方调用后清除适配器特定的标头。 11.添加日志记录脚本_Response01调用完成接口后添加一个记录接口返回值的日志记录脚本。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Response01&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 12.添加格式转换器 XML TO JSON因为对方系统是需要JSON形式的返回报文的，所以这里需要将从SAP出来的XML形式报文转换为JSON形式的报文。 此处设置在XML Element里面的设置是用来设置返回报文中的JSON数组的。当在这里声明接口后，返回的JSON报文就会将同名的接口转换为JSON数组的形式。 13.添加日志记录脚本_Response02最后再添加一个记录最后传递出去的返回值报文。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Response02&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 14.发布接口进行完成上面的操作后点击右上角的部署按钮，发布接口。之后的流程和普通的接口处理过程一致。拿到接口的地址，然后提供给对端系统即可。 三、接口测试1.使用POSTMAN测试接口打开Postman软件填入上面的接口地址，然后设置权限控制类型为Basic Auth。 2.传输请求使用下图所示的报文发送数据。 3.查看日志监控器首先可以看到我们只发送了一条请求，但是在监控器中却有两条记录。这是因为这个接口有两个集成过程。而监控器记录的过程中会先记录一次外围系统调用的记录，然后再记录CPI调用SAP的记录。所以才会有两条记录。 较早的这一条记录就是对端系统调用CPI时将请求存入JMS队列的记录。和我们在JMS流程中只添加了一个日志记录脚本相对应，只有一个附件。 日志来源： 接下来看较晚的这一条记录。可以看到它有四条记录，分别是两条Request和两条Response。他就是CPI调用SAP时的流程了。 日志来源： 以上就是CPI的异步流程。其实和发布一个SAP的接口基本一致，只是在开始时将传入接口的HTTPS适配器换成了JMS适配器而已。其他的操作和流程都是一样的。","categories":[{"name":"SAP BTP","slug":"SAP-BTP","permalink":"https://www.yemaojun.top/categories/SAP-BTP/"},{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/categories/CPI/"},{"name":"JMS","slug":"JMS","permalink":"https://www.yemaojun.top/categories/JMS/"},{"name":"异步","slug":"异步","permalink":"https://www.yemaojun.top/categories/%E5%BC%82%E6%AD%A5/"}],"tags":[{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/tags/CPI/"}]},{"title":"CPI接口的日志跟踪","slug":"SAP云/CPI/CPI接口的日志跟踪/CPI接口的日志跟踪","date":"2024-06-16T12:14:53.000Z","updated":"2024-06-16T12:36:56.348Z","comments":true,"path":"2024/06/16/SAP云/CPI/CPI接口的日志跟踪/CPI接口的日志跟踪/","link":"","permalink":"https://www.yemaojun.top/2024/06/16/SAP%E4%BA%91/CPI/CPI%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%A5%E5%BF%97%E8%B7%9F%E8%B8%AA/CPI%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%A5%E5%BF%97%E8%B7%9F%E8%B8%AA/","excerpt":"之前在《配置调用外围系统的CPI接口》这篇笔记中记录如何调式CPI的接口，但是这种需要自己查找输入参数来测试。本次介绍一种直接通过跟踪对方传入请求的调试方式来定位问题。以之前创建的CPI接口YTESTFM_CPIDEMO_01为实例（详见《通过Web Service发布CPI接口》）进行演示。","text":"之前在《配置调用外围系统的CPI接口》这篇笔记中记录如何调式CPI的接口，但是这种需要自己查找输入参数来测试。本次介绍一种直接通过跟踪对方传入请求的调试方式来定位问题。以之前创建的CPI接口YTESTFM_CPIDEMO_01为实例（详见《通过Web Service发布CPI接口》）进行演示。 CPI接口的日志跟踪 一、设置跟踪模式1.进入接口的集成管理页面通过接口这里进入也可以，但其实也可以通过监控器 –&gt; 管理集成内容的方式也一样。 2.修改日志配置进入管理集成内容界面之后在输入框中填入本次调试的CPI接口名称，然后修改日志配置下的日志级别为跟踪。 此处有个注意事项。当你修改日志级别为跟踪之后，当前模式只有十分钟的有效期，十分钟之后自动会切换为信息级别。而且级别为跟踪的消息在监控器中也只保留一个小时，之后会切换为消息级别。所以修改后请尽快调试。 二、发送信息调试1.发送请求使用Postman发送请求。 （1）失败请求 （2）成功请求 2.请求消息日志进入监控器的日志管理界面查找对应的接口可以看到下面的内容。级别为跟踪的日志只有一个小时的有效期。 3.调试失败的消息选择失败的消息，然后点击跟踪超链接进入调试界面。 点击后会进入下面的界面，在界面的左侧是流程节点。可以理解成一个组件对象就是一个节点。而异常的位置会被CPI标红出来。 我们单击左侧异常流程节点，然后查看他们的日志内容与消息日志可以看到消息在此处的信息然后对其进行排查。其中在消息内容 –&gt; 有效负载中显示的就是CPI当前节点的报文内容。 4.调试成功的消息成功的消息演示内容和失败的其实一样，只不过因为没有失败所以没有标红显示的异常流程节点。同时查看的方式也和异常的查看方式一致。","categories":[{"name":"SAP BTP","slug":"SAP-BTP","permalink":"https://www.yemaojun.top/categories/SAP-BTP/"},{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/categories/CPI/"}],"tags":[{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/tags/CPI/"}]},{"title":"配置调用外围系统的CPI接口","slug":"SAP云/CPI/配置调用外围系统的CPI接口/配置调用外围系统的CPI接口","date":"2024-06-16T12:09:45.000Z","updated":"2024-08-24T03:52:52.860Z","comments":true,"path":"2024/06/16/SAP云/CPI/配置调用外围系统的CPI接口/配置调用外围系统的CPI接口/","link":"","permalink":"https://www.yemaojun.top/2024/06/16/SAP%E4%BA%91/CPI/%E9%85%8D%E7%BD%AE%E8%B0%83%E7%94%A8%E5%A4%96%E5%9B%B4%E7%B3%BB%E7%BB%9F%E7%9A%84CPI%E6%8E%A5%E5%8F%A3/%E9%85%8D%E7%BD%AE%E8%B0%83%E7%94%A8%E5%A4%96%E5%9B%B4%E7%B3%BB%E7%BB%9F%E7%9A%84CPI%E6%8E%A5%E5%8F%A3/","excerpt":"前面介绍了如何发布CPI接口与CPI接口的异常处理，本次介绍如何发布一个简单的调用外围系统接口的CPI配置。同时又如何在接口中设置映射用的Mapping组件。","text":"前面介绍了如何发布CPI接口与CPI接口的异常处理，本次介绍如何发布一个简单的调用外围系统接口的CPI配置。同时又如何在接口中设置映射用的Mapping组件。 配置调用外围系统的CPI接口 一、需求说明1.需求说明本次我在SAP发布了一个Rest接口，用来查询SFLIGHT表中的数据。作为这次的外围系统接口地址。 2.对端系统接口说明（1）对端接口说明接口地址：http://mysap.goodsap.cn:50400/yrest_interface （2）输入参数 参数名 参数描述 IT_CARRID JSON数组（SIGN、OPTION、LOW、HIGH。普通Range表结构） IT_CONNID JSON数组（SIGN、OPTION、LOW、HIGH。普通Range表结构） IT_FLDATE JSON数组（SIGN、OPTION、LOW、HIGH。普通Range表结构） （3）返回参数返回JSON数据，数组名称为et_return，数组中的结构如下所示： 参数名 参数描述 carrid 航线代码 connid 航班连接编号 fldate 航班日期 price 航空运费 currency 航班的本地货币 3.SAP端接口说明（1）接口说明我们需要调用上面的对端接口，通过SAP(QAS) —&gt; CPI —-&gt; SAP(DEV)这样的流程路线进行。 （2）接口传出参数 参数名 参数描述 CARRID JSON数组（SIGN、OPTION、LOW、HIGH。普通Range表结构） CONNID JSON数组（SIGN、OPTION、LOW、HIGH。普通Range表结构） FLDATE JSON数组（SIGN、OPTION、LOW、HIGH。普通Range表结构） （3）接口接收参数 参数名 参数描述 CARRID 航线代码 CONNID 航班连接编号 FLDATE 航班日期 PRICE 航空运费 CURRENCY 航班的本地货币 二、CPI端配置接口1.创建iFlow找到存放iFlow接口的Package，点击编辑然后点击下面的添加按钮，选择Integration Flow。 在弹框的界面填入iFlow的名称和描述内容。点击右下角的添加并在编辑器中打开按钮。 2.配置调用端适配器从Sender组件拉出一条箭头指向Start组件，选择SOAP适配器与其对应的版本。双击适配器线段，设置其属性。此处需要设置的有两个地方，一个地方是Address和User Role。Address是该接口的CPI端接口后缀名，User Role对象基本是默认的CPI对象。该对象的查看方式可以看前面写的那一篇《通过Web Service发布CPI接口》。在这一篇笔记中详细记录了该对象是做什么的和查看位置。 3.添加日志记录脚本_Request01添加接口的请求输入报文记录日志脚本。内容其实和前面的一样。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Request01&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 4.添加字段映射组件此处有个注意事项，那就是Message Mapping组件只能映射转换XML形式消息。JSON形式的消息是映射不了的，会报错映射时消息结构错误。而我们的接口是SOAP调用外围系统，在一开始传入CPI的消息形式就是XML形式的，所以要在日志记录完成之后先开始字段的映射。 5.编写字段映射文件在上面添加完成Mapping组件后，需要编写XSD文件与WSDL文件。其中XSD文件是对端系统的JSON字段结构，而WSDL文件则是SAP端传入消息的XML消息结构。内容如下所示。 （1）SAP端的WSDL文件示例文件后缀WSDL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;wsdl:definitions targetNamespace=&quot;urn:smart:com:SAP-YTEST_OUT&quot; xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; xmlns:wsoap12=&quot;http://schemas.xmlsoap.org/wsdl/soap12/&quot; xmlns:http=&quot;http://schemas.xmlsoap.org/wsdl/http/&quot; xmlns:mime=&quot;http://schemas.xmlsoap.org/wsdl/mime/&quot; xmlns:tns=&quot;urn:smart:com:SAP-YTEST_OUT&quot; xmlns:wsp=&quot;http://schemas.xmlsoap.org/ws/2004/09/policy&quot; xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot;&gt; &lt;wsdl:types&gt; &lt;xsd:schema targetNamespace=&quot;urn:smart:com:SAP-YTEST_OUT&quot; xmlns=&quot;urn:smart:com:SAP-YTEST_OUT&quot;&gt; &lt;xsd:element name=&quot;ZINPUT&quot;&gt; &lt;xsd:complexType&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;CARRID&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;xsd:complexType&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;SIGN&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;OPTION&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;LOW&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;HIGH&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:element name=&quot;CONNID&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;xsd:complexType&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;SIGN&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;OPTION&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;LOW&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;HIGH&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:element name=&quot;FLDATE&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;xsd:complexType&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;SIGN&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;OPTION&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;LOW&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;HIGH&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:element name=&quot;ZOUTPUT&quot;&gt; &lt;xsd:complexType&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;RETURN&quot; maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot; type = &quot;ET_RETURN&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:complexType name=&quot;ET_RETURN&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;CARRID&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;CONNID&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;FLDATE&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;PRICE&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;CURRENCY&quot; minOccurs=&quot;0&quot; type=&quot;xsd:string&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;/xsd:schema&gt; &lt;/wsdl:types&gt; &lt;wsdl:message name=&quot;ZINPUT&quot;&gt; &lt;wsdl:part name=&quot;parameter&quot; element=&quot;tns:ZINPUT&quot;/&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name=&quot;ZOUTPUT&quot;&gt; &lt;wsdl:part name=&quot;parameter&quot; element=&quot;tns:ZOUTPUT&quot;/&gt; &lt;/wsdl:message&gt; &lt;wsdl:portType name=&quot;SAP-YTEST_OUT_INTERFACE&quot;&gt; &lt;wsdl:operation name=&quot;Request&quot;&gt; &lt;wsdl:input name=&quot;Request&quot; message=&quot;tns:ZINPUT&quot;&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name=&quot;Response&quot; message=&quot;tns:ZOUTPUT&quot;&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;wsdl:binding name=&quot;SAP-YTEST_OUT_INTERFACE_test_interface&quot; type=&quot;tns:SAP-YTEST_OUT_INTERFACE&quot;&gt; &lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt; &lt;wsp:Policy xmlns:wsp=&quot;http://schemas.xmlsoap.org/ws/2004/09/policy&quot;&gt; &lt;wsp:PolicyReference URI=&quot;#BN__binding&quot;/&gt; &lt;/wsp:Policy&gt; &lt;wsdl:operation name=&quot;Request&quot;&gt; &lt;soap:operation soapAction=&quot;&quot; style=&quot;document&quot;/&gt; &lt;wsdl:input name=&quot;Request&quot;&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name=&quot;Response&quot;&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:service name=&quot;service&quot;&gt; &lt;wsdl:port name=&quot;port&quot; binding=&quot;tns:SAP-YTEST_OUT_INTERFACE_test_interface&quot;&gt; &lt;soap:address location=&quot;https://sandbox-n3optbe7.it-cpi010-rt.cpi.cn40.apps.platform.sapcloud.cn/cxf/Demo/YTEST_OUT_INTERFACE&quot;/&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt; &lt;wsp:UsingPolicy required=&quot;true&quot; xmlns:wsp=&quot;http://schemas.xmlsoap.org/ws/2004/09/policy&quot;/&gt; &lt;wsp:Policy wsu:Id=&quot;BN__binding&quot; xmlns:wsp=&quot;http://schemas.xmlsoap.org/ws/2004/09/policy&quot; xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot;&gt; &lt;wsp:ExactlyOne&gt; &lt;wsp:All&gt; &lt;sp:TransportBinding xmlns:sp=&quot;http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702&quot;&gt; &lt;wsp:Policy&gt; &lt;sp:TransportToken&gt; &lt;wsp:Policy&gt; &lt;sp:HttpsToken&gt; &lt;wsp:Policy&gt; &lt;wsp:ExactlyOne&gt; &lt;sp:HttpBasicAuthentication/&gt; &lt;/wsp:ExactlyOne&gt; &lt;/wsp:Policy&gt; &lt;/sp:HttpsToken&gt; &lt;/wsp:Policy&gt; &lt;/sp:TransportToken&gt; &lt;sp:AlgorithmSuite&gt; &lt;wsp:Policy&gt; &lt;wsp:ExactlyOne&gt; &lt;sp:Basic128/&gt; &lt;/wsp:ExactlyOne&gt; &lt;/wsp:Policy&gt; &lt;/sp:AlgorithmSuite&gt; &lt;sp:Layout&gt; &lt;wsp:Policy&gt; &lt;sp:Strict/&gt; &lt;/wsp:Policy&gt; &lt;/sp:Layout&gt; &lt;/wsp:Policy&gt; &lt;/sp:TransportBinding&gt; &lt;/wsp:All&gt; &lt;/wsp:ExactlyOne&gt; &lt;/wsp:Policy&gt; &lt;/wsdl:definitions&gt; （2）对端系统接口结构文件后缀XSD。 1234567891011121314151617181920212223242526272829303132333435363738&lt;schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;element name=&quot;root&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;IT_CARRID&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;SIGN&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;OPTION&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;LOW&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;HIGH&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;element name=&quot;IT_CONNID&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;SIGN&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;OPTION&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;LOW&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;HIGH&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;element name=&quot;IT_FLDATE&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;SIGN&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;OPTION&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;LOW&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;HIGH&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt; （3）上传映射文件编写完成上面的文件之后，上传对应的映射文件并映射对应的字段。可以看到我们在上传WSDL文件的时候CPI弹框让我们选择两个结构中的其中一个。这是因为ZINPUT是SAP端的输入Request，而ZOUTPUT则是Response。我们此时设置的是Request的Mapping内容，所以选择上面的ZINPUT对象。 在将两边的映射文件导入完成之后的操作就和PO中间件类似了，可以使用连线将两边的字段和结构根据需求连接起来。这样就是映射两边的字段和结构。而在连接的时候下面有个和PO一样的控制台，里面是很多控制字段格式的标准Function，用于控制传入值的格式等。 6.添加日志记录脚本_Request02此处添加的日志记录脚本是可选的，主要是方便我们后面对接口进行调试和问题排查的。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Request02&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 7.添加XML转JSON组件在将SAP传入的XML文件转换为对端系统要求的XML形式传入请求后，我们还需要将XML转换为JSON形式然后再发送给外围系统。毕竟外围系统当时要求的是传输JSON形式的请求内容。 在添加完成转换之后，还需要XML TO JSON组件中设置XML Element。在这里设置XML在转换JSON时，哪些字段是需要转换为JSON数组的。比如本次需求中的IT_CARRID、IT_CONNID和IT_FLDATE这三个对象是JSON数组对象，而它们三个对象是存在于XML中root对象下的，所以编写时需要编写为下面的形式。 root&#x2F;IT_CONNID root&#x2F;IT_CARRID root&#x2F;IT_FLDATE 8.去除报文的root结构在上面设置映射结构和转换消息格式的时候有提到过，经过Message Mapping转换后的报文结构是在一个root节点下面的。即下面的结构。 1&#123;&quot;root&quot;:&#123;&quot;IT_CARRID&quot;:[&#123;&quot;SIGN&quot;:&quot;I&quot;,&quot;OPTION&quot;:&quot;EQ&quot;,&quot;LOW&quot;:&quot;AA&quot;&#125;],&quot;IT_CONNID&quot;:[&#123;&quot;SIGN&quot;:&quot;I&quot;,&quot;OPTION&quot;:&quot;EQ&quot;,&quot;LOW&quot;:&quot;0017&quot;&#125;]&#125;&#125; 关于这个root节点的来源其实是映射时的root内容，因为在SAP的接口中结构中是需要存在一个外层的大结构来包含中间的各种结构的。在文件中不定义该节点名称就导入到Message Mapping文件中的话会报错。所以该名称是必须的，但是名字不一定要叫root。可以根据你的需求来定义名称。不过修改名称之后，后面所有的root就需要替换成你修改后的名称。 我们添加一个Groovy脚本，使用下面的代码去除掉经过XML TO JSON转换后的root节点。 12345678910def Message processData(Message message) &#123; //Body def bodyStr = message.getBody(java.lang.String) as String; bodyStr = bodyStr.replace(/&#123;&quot;root&quot;:/,&quot;&quot;); bodyStr = bodyStr.substring(0,bodyStr.length() - 1); // 去除掉root末尾的“&#125;” message.setBody(bodyStr); return message;&#125; 9.添加日志记录脚本_Request03添加一个日志记录脚本，代码内容如下所示。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Request03&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 10.添加请求回复经过上面的各种操作后设置的传入报文已经达到了和外围系统要求的格式，所以此时就需要设置一个请求答复来调用外围系统。然后将外围系统返回的参数在经过转换返回到SAP中。 （1）设置请求回复组件 （2）设置Credential Name这个对象是和上面的Authentication一起使用的，上面选择的是认证方式，而下面则是认证所需要的账密对象Credential Name。该对象的设置方式在下面的路径中：监控器 –&gt; 管理安全 –&gt; 安全材料。 进入安全材料界面后点击右上角的创建按钮，选择用户凭据。这个也是和外围系统确定认证的方式，所以选择的类型于认证方式请根据自身的需求来灵活调整。 按照上面的操作流程进行后，界面会弹框要求输入对象的属性。此处使用我已经创建好的凭据做一个演示。 11.添加日志记录脚本_Response01因为已经调用过外围系统了，所以此处我们记录一下接口返回的消息日志记录。日志记录的代码如下： 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Response01&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 12.添加root节点此处为接口返回的报文添加root节点，理由上面去除root节点的理由一致。我们在映射字段结构的时候需要以root节点为起始节点，此处使用内容修正符组件处理即可。 13.添加JSON转XML组件进行完上面的操作之后，我们需要将对方接口返回的消息在映射到SAP的系统中。而Message Mapping组件对象映射字段需要消息格式是XML形式的。所以此处添加一个JSON转XML的组件对象。 因为我们已经自行添加过root节点了，所以我们就不再需要此处帮我们默认添加root节点需求了。将下面的Add XML Root Element选项取消掉。当然你也可以将前面的内容修正符去掉然后保留此处的勾选也是一样的。 14.添加字段映射组件此处我们其实还可以在该组件之前再添加一个日志记录脚本文件用来查看转换后的XML文件内容。但是是可选内容，所以就暂时不做了直接进行字段映射。 15.编写字段映射文件在映射前同样需要导入XSD与WSDL文件。SAP端的WSDL文件之前已经导入过了，所以这里我们就导入对端系统的返回XSD文件即可。 （1）对端系统的Response结构12345678910111213141516171819&lt;schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;element name=&quot;root&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;et_return&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;carrid&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;connid&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;fldate&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;price&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;element name=&quot;currency&quot; type=&quot;string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt; （2）上传映射文件 16.添加日志记录文件_Response02最后再记录一下传入SAP端的日志信息即可。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Response02&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 17.接口的异常处理开发完成接口之后一定记得如果可以对他进行异常处理的话就给接口添加上异常处理的逻辑吧。此处就只演示下前面提到过的接口异常时发送邮件提醒管理员的异常处理方式。对这部分感兴趣的可以去查看之前的笔记《CPI邮件配置》。 18.发布部署接口进行完上面的所有流程操作之后就可以部署接口了。点击右上角的部署按钮发布接口。 最后到管理集成内容中查看接口的地址。 三、测试接口因为没有编写SAP端的测试接口，所以这里就借用CPI自身的测试工具对接口进行测试。刚好也对这种测试方式做一个记录。 1.获取测试用报文（1）SAP系统① SAP端传入XML1&lt;n0:ZINPUT xmlns:n0=&quot;urn:smart:com:SAP-YTEST_OUT&quot; xmlns:soap-env=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:prx=&quot;urn:sap.com:proxy:QS4:/1SAI/TASF958F66990BA4F2D7010:755&quot;&gt;&lt;CARRID&gt;&lt;SIGN&gt;I&lt;/SIGN&gt;&lt;OPTION&gt;EQ&lt;/OPTION&gt;&lt;LOW&gt;AA&lt;/LOW&gt;&lt;/CARRID&gt;&lt;CONNID&gt;&lt;SIGN&gt;I&lt;/SIGN&gt;&lt;OPTION&gt;EQ&lt;/OPTION&gt;&lt;LOW&gt;0017&lt;/LOW&gt;&lt;/CONNID&gt;&lt;/n0:ZINPUT&gt; （2）对端系统① 对端传入JSON12345678910111213141516&#123; &quot;IT_CARRID&quot;: [ &#123; &quot;SIGN&quot;:&quot;I&quot;, &quot;OPTION&quot;:&quot;EQ&quot;, &quot;LOW&quot;:&quot;AA&quot; &#125; ], &quot;IT_CONNID&quot;: [ &#123; &quot;SIGN&quot;:&quot;I&quot;, &quot;OPTION&quot;:&quot;EQ&quot;, &quot;LOW&quot;:&quot;0017&quot; &#125; ]&#125; ② 对端传出JSON123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;et_return&quot;: [ &#123; &quot;carrid&quot;: &quot;AA&quot;, &quot;connid&quot;: 17, &quot;fldate&quot;: &quot;2023-11-07&quot;, &quot;price&quot;: 422.94, &quot;currency&quot;: &quot;USD&quot; &#125;, &#123; &quot;carrid&quot;: &quot;AA&quot;, &quot;connid&quot;: 17, &quot;fldate&quot;: &quot;2024-01-26&quot;, &quot;price&quot;: 422.94, &quot;currency&quot;: &quot;USD&quot; &#125;, &#123; &quot;carrid&quot;: &quot;AA&quot;, &quot;connid&quot;: 17, &quot;fldate&quot;: &quot;2024-04-15&quot;, &quot;price&quot;: 422.94, &quot;currency&quot;: &quot;USD&quot; &#125;, &#123; &quot;carrid&quot;: &quot;AA&quot;, &quot;connid&quot;: 17, &quot;fldate&quot;: &quot;2024-07-04&quot;, &quot;price&quot;: 422.94, &quot;currency&quot;: &quot;USD&quot; &#125;, &#123; &quot;carrid&quot;: &quot;AA&quot;, &quot;connid&quot;: 17, &quot;fldate&quot;: &quot;2024-09-22&quot;, &quot;price&quot;: 422.94, &quot;currency&quot;: &quot;USD&quot; &#125;, &#123; &quot;carrid&quot;: &quot;AA&quot;, &quot;connid&quot;: 17, &quot;fldate&quot;: &quot;2024-12-11&quot;, &quot;price&quot;: 422.94, &quot;currency&quot;: &quot;USD&quot; &#125; ], &quot;ev_code&quot;: &quot;S&quot;, &quot;ev_message&quot;: &quot;数据查询成功&quot;&#125; 2.添加输入端调式点在连接每个组件的横线上单击左键会有4个按钮。按照下面所示的方式添加调试断点。然后将上面提到的测试用数据填充到开始的调试断点中运行调试。 可以看到我们使用上面的请求内容进行测试在调用外围系统之前他将我们传入的XML报文已经转换成了调用对方系统的JSON报文。 由上面的测试结果可以知道CPI的接口是按照我们的需求对请求的报文进行了XML到JSON的转换的。接下来就是测试对端系统返回的JSON转换为SAP端的XML。 3.添加输出端调试点通过上面第一小项可以知道对端系统返回的JSON报文内容，我们这里直接使用这个报文进行测试。 通过上面的测试可以发现在调试流程的起点到终点之间每个组件之后都会有一个信封图标。双击他们就可以查看到请求内容在他们之间的变化。包括我们添加的root节点与最后面的JSON转换为XML的最终形式，映射后的字段值等。 当中间存在异常无法执行时也可以通过双击信封的方式查看此处给出的报错参考。至少我认为此处的报错内容提示比监控器中给出的内容要容易排查的多。 4.取消调式点可以添加也就可以一次性取消。在运行调式点按钮的后面的按钮就是取消调试按钮。点击一下之后就可以取消调试点了。 四、其他以上就是CPI调用外围系统的CPI端配置，本来是想把SAP端的配置也一次性做了的。但是考虑到上面已经给出了WSDL的源码文件，对于创建SAP的接口已经很方便了所以就不演示SAP端如何发布接口的操作了。如果有任何疑问可以在评论区私信我。","categories":[{"name":"SAP BTP","slug":"SAP-BTP","permalink":"https://www.yemaojun.top/categories/SAP-BTP/"},{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/categories/CPI/"}],"tags":[{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/tags/CPI/"}]},{"title":"CPI邮件配置","slug":"SAP云/CPI/CPI邮件配置/CPI邮件配置","date":"2024-06-16T12:02:45.000Z","updated":"2024-06-16T12:33:16.904Z","comments":true,"path":"2024/06/16/SAP云/CPI/CPI邮件配置/CPI邮件配置/","link":"","permalink":"https://www.yemaojun.top/2024/06/16/SAP%E4%BA%91/CPI/CPI%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE/CPI%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE/","excerpt":"这里介绍下CPI的邮件发送配置。CPI自己就有封装好的邮件适配器对象，使用这个对象填入邮箱的SMTP信息与发件人，收件人和邮件标题和正文等内容。等待调用时就会自动发送邮件了。这期介绍下如何使用office邮箱的配置。","text":"这里介绍下CPI的邮件发送配置。CPI自己就有封装好的邮件适配器对象，使用这个对象填入邮箱的SMTP信息与发件人，收件人和邮件标题和正文等内容。等待调用时就会自动发送邮件了。这期介绍下如何使用office邮箱的配置。 CPI邮件配置 一、创建邮箱iFlow1.新建邮件iFlow在CPI的Package中创建CPI异常时自动发送邮件提醒运维人员的iFlow。 2.声明iFlow的调用地址如果想要在其他的CPI中调用该邮件发送功能，则你还需要像创建其他CPI接口一样，为该iFlow声明一个Address。以便其他CPI在其的Address中调用该iFlow。有点绕口，简单来说我们在创建时写的YTEST_SAP_ERROR_MAIL这个是我们给他定义的名称，但是这个名称无法在其他CPI中使用。如果要在其他CPI中使用则需要通过下面再Address中定义的接口名称。 从Sender出发，拉出适配器指向箭头。选择适配器类型为ProcessDirect。然后打开Connection页签在Address输入框中输入该iFlow的地址。 3.设置发送邮件的适配器与连接属性（1）设置连接器与属性从End出发拉出箭头指向Receiver对象，然后选择适配器类型为Mail。请注意常规界面的传输协议是默认的SMTP。所以在Connection页签中的Address中填入office邮箱的Host与端口号（smtp.office365.com:587）。设置的属性内容如下： Proxy Type：Internet（默认） **Timeout (in ms)**：30000（默认） Protection：STARTTLS Mandatory（默认） Authentication：Plain User&#x2F;Password Encrypted User&#x2F;Password：加密的用户&#x2F;密码 Plain User&#x2F;Password：普通用户&#x2F;密码 OAuth2 Authorization Code：OAuth2授权代码 None：无 Credential Name：可理解为登录office邮箱的账号角色。 （2）注意事项此处有个注意事项，那就是如果你选择Proxy Type为Internet时，SMTP的端口号只能是587和465。 以下内容摘自：SAP Business Technology Platform (BTP)的架构理解 对于只能使用这两个端口我有以下猜想，不保证正确，欢迎指正。之前我在查找BTP相关的资料时有看到说SAP为了自家的云产品能更好的互联，单独开发的一个进行身份认证的服务。被称之为Identity Authentication Tenant，简称是IAS - Identity Authentication Service。该服务严格意义上并不属于BTP上的服务。它可以使你将常见的微软认证数据接入IAS，利用现有用户数据和权限，实现SAP云产品的无缝登陆，你也可以在上边进行从0到1的用户创建填充，重度依赖IAS实现SAP云产品的用户管理。 从上边的架构图中可以看到，IAS在用户通过浏览器登陆BTP上的服务的时候起到非常关键的鉴权作用，只有该用户有足够权限才能访问BTP上的指定服务，要么在BTP上进行开发工作，要么本身就是终端用户使用BTP上暴露的服务。结合方法也不困难，SAP社区论坛有不少资料，其最直接的反应就是在上边BTP主控室的截图左侧可以看到Trust Configuration中多了一个自创建的IAS而不仅仅是default的了。 （3）Credential Name这个角色的配置位置在CPI的监控器–&gt;安全材料中。 此处的用户就是登录office邮箱的邮箱地址（账号）。 4.设置邮箱的Processing在这里可以设置发送邮件的发件人和接收邮件收件人邮箱地址，此处之外还可以设置邮件的主题、和正文部分。 如果收件人有多个，请按照**邮箱1;邮箱2;邮箱3…的方式串联收件人邮箱地址。在主题和正文中的{}**部分是调用邮件接口时的动态参数值。可以通过内容转换器定义变量和变量值然后传入该iFlow。 5.发布iFlow接口 二、设置CPI的异常处理当接口在CPI端发生异常时，是不会将数据推送到SAP端的。这时候如果不通过CPI进行排查就无法定位到问题，所以客户需要我们设置一个异常处理。当CPI接口处理失败时，向运维人员的邮箱发送异常邮件。这样可以就可以定位到CPI出现了异常。下面介绍下如何在CPI的接口中设置异常处理并发送异常邮件。 以之前在《通过Web Service发布CPI接口》中创建的CPI接口为例子。 1.创建异常子流程这里添加异常子流程有个注意事项，创建的异常子流程结束的节点是接口结束节点End。我们需求将其修改为异常结束节点Error End。不然会将邮件的内容给对方系统发送过去。 设置接口结束节点返回的报文内容如下： 2.添加内容修正符在Error Start1之后创建一个内容修正符，在其中添加上需要通过邮件发送的变量值。 3.添加请求回复组件在修正符之后添加一个请求回复组件，然后使用ProcessDirect适配器调用邮件发送的iFlow。设置好适配器之后在适配器的Connection页签中的Address中的输入框中填入之前我们为邮件iFlow声明的CPI端的名称：**&#x2F;Demo&#x2F;CPIErrorMailSend**。 4.部署修改后的接口添加完成上面的异常子流程全部步骤之后部署接口即可，点击右上角的部署按钮，等待部署状态为已部署即可。 三、测试邮件推送1.发送异常请求使用Postman测试工具向CPI发送会产生异常的请求内容。可以看到 2.监控器截图 3.邮件效果截图","categories":[{"name":"SAP BTP","slug":"SAP-BTP","permalink":"https://www.yemaojun.top/categories/SAP-BTP/"},{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/categories/CPI/"}],"tags":[{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/tags/CPI/"}]},{"title":"通过Web Service发布CPI接口","slug":"SAP云/CPI/通过Web-Service发布CPI接口/通过Web-Service发布CPI接口","date":"2024-05-29T10:52:50.000Z","updated":"2024-05-29T10:57:36.564Z","comments":true,"path":"2024/05/29/SAP云/CPI/通过Web-Service发布CPI接口/通过Web-Service发布CPI接口/","link":"","permalink":"https://www.yemaojun.top/2024/05/29/SAP%E4%BA%91/CPI/%E9%80%9A%E8%BF%87Web-Service%E5%8F%91%E5%B8%83CPI%E6%8E%A5%E5%8F%A3/%E9%80%9A%E8%BF%87Web-Service%E5%8F%91%E5%B8%83CPI%E6%8E%A5%E5%8F%A3/","excerpt":"最近一直在做CPI相关的开发，这里记录下通过Web Service方式发布CPI接口的过程，以供后面复习参考。这里先介绍下如何通过SAP发布的Web Service服务来配置CPI然后由CPI发布由外围系统调用的接口。后面会再介绍如何配置调用对方接口的CPI内容和其他方式发布接口的CPI配置方式。最后会再系统性的介绍下CPI里面的各种组件和功能。先把坑挖好，哈哈哈。","text":"最近一直在做CPI相关的开发，这里记录下通过Web Service方式发布CPI接口的过程，以供后面复习参考。这里先介绍下如何通过SAP发布的Web Service服务来配置CPI然后由CPI发布由外围系统调用的接口。后面会再介绍如何配置调用对方接口的CPI内容和其他方式发布接口的CPI配置方式。最后会再系统性的介绍下CPI里面的各种组件和功能。先把坑挖好，哈哈哈。 通过Web Service发布CPI接口 一、CPI 介绍如果有使用过PO中间件的话，其实就更容易理解这个BTP的服务了。CPI本质就是云端的中间件服务，和PO的指责一样。但是无论是在配置接口还是做相关映射等操作都比PO要简洁的多。此外如果你对JavaScript也比较了解的话，那么对于CPI接口中的脚本还有自定义配置功能就更容易上手了。不过不会也没关系，因为CPI的官方有提供专门的参考代码，可以直接使用，都是可以满足日常对日志管理的需求的。 对于没有使用过PO或者对中间件技术不了解的同事，这里讲解下中间件的作用和信息流程，方便你对中间件有一个大概的了解。 中间件是位于系统软件和用户应用软件中间的一个软件系统，所以被称之为中间件。而它的主要作用是处理由系统软件和用户软件交互时产生的各类消息和请求。当这些消息和请求中有很复杂或需要特殊处理的内容时，则可以在中间件对这些内容进行处理。比如SAP端发布了一个接口，用来接收数组形式的JSON串数据，但是对方系统发送的JSON报文内容很多且命名等各种结构与SAP均不相同。此时就可以在中间件对外围系统的JSON做映射。只将SAP需要的数据传递到SAP即可。而当外围系统的JSON结构发生变化时也只需要重新在中间件配置映射结构即可，而不需要对SAP端的内容进行修改。同理反过来也是一样的。 以SAP与其他外围系统之间的数据交互关系为例子，可以使用下图对系统软件、用户应用软件和中间件进行简单理解。 二、SAP 端发布Web Service服务1.创建远程调用函数（1）设置函数的远程属性 （2）设置函数参数此处建议将所有参数都设置为可选的，然后将所有的必输校验通过代码的形式书写。不然当对方在调用接口时，传入参数没有必输的内容时会在SAP的Web Service端报500。而且这个报错是不会进入程序的所以只能通过CPI和Web Service的日志管理进行查看。不利于对接口日志的管理和排查。 （3）编写调用逻辑12345678910111213141516171819202122232425262728FUNCTION YSFLIGHT_DEMO_01.*&quot;----------------------------------------------------------------------*&quot;*&quot;本地接口：*&quot; EXPORTING*&quot; VALUE(EV_CODE) TYPE CHAR01*&quot; VALUE(EV_MESSAGE) TYPE CHAR255*&quot; TABLES*&quot; IT_CARRID STRUCTURE TYP_F_CARRID OPTIONAL*&quot; IT_CONNID STRUCTURE TYP_F_CONNID OPTIONAL*&quot; IT_FLDATE STRUCTURE TYP_F_FLDATE OPTIONAL*&quot; ET_SFLIGHT STRUCTURE SFLIGHT OPTIONAL*&quot;---------------------------------------------------------------------- SELECT * FROM SFLIGHT WHERE CARRID IN @IT_CARRID AND CONNID IN @IT_CONNID AND FLDATE IN @IT_FLDATE INTO CORRESPONDING FIELDS OF TABLE @ET_SFLIGHT. IF SY-SUBRC EQ 0. EV_CODE = &#x27;S&#x27;. EV_MESSAGE = TEXT-S01.&quot;查询成功 ELSE. EV_CODE = &#x27;E&#x27;. EV_MESSAGE = TEXT-E01.&quot;未查询到数据 ENDIF.ENDFUNCTION. 2.配置企业服务（1）新建企业服务在程序的源代码界面按照图中所示的内容配置企业服务对象。 （2）设置企业服务的名称这里依然和普通的程序命名方式一致，必须要使用Z或Y开头的名称。这次就和函数模块的名称一致了。设置完成之后点击继续按钮进入下一步。 （3）选择函数模块此处因为我们是直接在函数模块界面创建的企业服务，所以这里就自动帮我们选择好了。直接选择下一步即可。 （4）设置服务的认证方式这里可以选择的认证方式有四种，但是这里就不介绍了。详细的可以参照我之前写的发布Web Service接口的文章。这里选择不需要认证方式（图中的选择）然后下一步。 （5）绑定包与请求编号 （6）配置完成企业服务配置完上一步点击继续之后就会来到下面的界面。此时就将企业服务全部配置完成了。 点击完成之后就会跳转到代理配置界面，如下图所示。此时该服务的状态还是新建的，所以需要激活它。 将上面的企业服务对象激活完成之后，在SAP端的所有操作就全部结束了。 3.配置Web服务（1）打开Web服务页面在SAP的导航界面输入事务代码：SOAMANAGER。进入Web服务配置界面。 输入后等待一会，等待SAP弹出企业服务浏览器页面。部分浏览器或许会提示该网址不安全，点击详细信息 –&gt; 转到此网页即可。 进入后会需要你登录SAP系统，输入当前系统的账号密码登录即可。 （2）查找Web服务通过浏览器登录页面后会弹出下面所示的服务配置页面。选择Web 服务配置功能。 （3）查找企业服务点击上面的Web 服务配置按钮后会进入下面的页面。在对象名称输入框中输入刚刚在SAP创建的企业服务名称YSFLIGHT_DEMO_01然后按下回车按钮搜索在SAP创建的企业服务。 （4）创建服务对象点击上面查询到的服务对象，进入到下面的服务对象界面。因为是新建的企业服务对象，所以列表是空的。点击图中的创建服务按钮，创建服务对象。 （5）定义服务名称与绑定名称此处是定义服务的名称方便区分用的，我们使用和Function 一样的名称和描述内容。定义完成上面的内容之后点击下一个按钮进入下一步。 （6）配置接口的协议与验证我们的传输级别安全选择**SSL(http)**，不过这个可以根据自己接口的需求来定义，选择这个从接口的角度来讲更安全，但是在使用时需要证书。 在最下面还有个传输通道验证，我们选择用户标识&#x2F;密码。这样对方在使用接口时就需要输入可以登录SAP系统的账号和密码才可以使用该接口。 （7）完成配置发布服务到这一步默认直接点击完成就可以了，因为后面就没有需要我们配置的东西了。 （8）获取接口的WSDL地址点击完成之后可以看到在刚刚创建服务的界面会多出下面的界面。点击图中红框圈中的按钮，可以查看接口的WSDL地址。 我们拿到这个地址后，在后续配置CPI时就可以根据这个地址帮助CPI快速定位到SAP中的接口。 三、配置CPI端接口1.进入CPI配置界面这个可以问你们的Basis要一下CPI接口的配置地址，由他提供地址给你们，然后你再配置。进入CPI的地址一样需要账号登录，登录之后会看到下面的界面。 2.选择CPI的包点击图中红框圈中的列表按钮（设计），打开CPI配置界面。 打开的列表界面会列出所有的Package，你需要选择一个Package存放CPI的接口内容。这个和SAP一样，如果没有新建一个即可。 然后打开存放CPI对应的Package，打开部件页签点击右上角的编辑按钮。 3.新建iFlow按照图中红框圈中的对象新建iFlow对象。 4.填写iFlow名称与描述填写iFlow的名称和描述，因为我们是新建的对象，所以点击图中红框圈中的添加并在编辑器中打开。直接对该接口进行操作，如果之点击添加，则还需要你在部件页签中查找到你新建的这个接口然后在编辑它。 5.编辑iFlow在打开的界面可以看到由五个元素。分别是： Sender：发送方 Integration Process：集成过程，可以理解成接口对消息和日志管理的流程图，所有的操作都是按照箭头和图标来操作的。 Start：接口流程的开始节点 End：接口流程的结束节点 Receiver：接收者 如果要操作iFlow对象请点击右上角的编辑按钮，CPI在配置的时候很多时候进入的界面都是Display的状态，如果要操作对象基本都需要点击编辑按钮。 6.设置CPI接口后缀第一步需要设置CPI的接口URL后缀，可以简单理解成是接口对外的名称。外围系统可以根据CPI的接口前缀地址 + CPI接口后缀调用对应的接口地址。 设置的过程其实是从Sender对象开始拉出一条连接Start对象的箭头。然后等待弹框，在弹框中选择调用接口的方式。我们这边选择接口的调用方式是HTTPS。如果是异步接口此处需要选择JMC对象，这个后面再说。设置完接口的调用方式之后双击对象间的连线会在界面的下面弹出一个属性框。点击Connection页签在Address中填入接口后缀，在User Role中填入权限角色，这个角色在什么位置我在下面介绍。 在填写适配器属性的时候我勾选掉了最下面的CSRF Protected。如果使用默认的勾选这个接口就只能通过POST的方式进行访问，如果取消勾选则可以使用POST和GET两种方式调用接口。 在User Role中填写的集成流调用者在下面的路径中查看。该对象一般是默认的，在CPI初始化完成后就会有这样一个对象。 7.添加内容修正符[可选]（1）作用这个组件的作用是用来对请求的内容如Header、Body等内容做一些整体的处理。或是定义一些用于在脚本中访问的全局变量。 （2）添加内容修正符在下面的配置中，Message Header中设置的变量是可以直接在脚本中使用的，而在Message Body中则是对消息体中的Body部分做一些处理。例如本次示例中我们在传入的报文外围添加了下面的内容。在Message Body中的内容请一定注意上面的Type要选择为Expression。如果你将类型选择为Constant则报文的整体内容就和你写的内容一致了。可理解成将传进来的报文一整个替换为你写在文本框的内容。 1234&#123;&quot;urn:YSFLIGHT_DEMO_01&quot;:$&#123;body&#125;&#125; 效果后面在日志管理的时候可以通过附件的内容查看，等后面测试的时候再演示效果。 8.添加记录日志用脚本（1）作用标题说的是功能，但其实这个组件是用来编写JS脚本用的。只不过最常用的是用来将传入传出的消息头和消息体保存成附件记录在监控器中。 SAP官网在脚本对象中留下了参考用的网址，在其中有保存消息为附件的模板代码。可以直接拿过来使用。 （2）官网参考网址① 官网地址来源新建一个脚本文件，打开之后就可以开头找到两个网址了。 ② 脚本用例脚本用例 | SAP Help Portal ③ SCRIPT APISCRIPT API （3）添加日志脚本① 添加脚本组件继续在内容修正符的后面点击加号按钮，添加脚本组件。 此处有个注意事项，在下面最后一幕，脚本的Processing页签中有一个Script Function的输入项。该选项代表优先执行脚本中的那个方法名，例如你输入request，则程序会在其中寻找是否存在这个名称的Function。如果存在就执行这个Function，不存在CPI接口就会挂掉。 ② 脚本日志代码这段代码就是直接从脚本用例 | SAP Help Portal网站中的将信息添加到消息处理日志内容。修改下附件记录的文件名称为Request01（这个名称可以自定义）。 12345678def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Request01&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 9.添加转换器（1）添加转换器此处需要看你们和外围系统商议的报文结构是什么，但是从CPI到SAP的数据传输形式一般是XML形式的。所以转换器的类型一般都是 TO XML。但是目前绝大多数的接口基本都是JSON数据格式的，所以在传入的报文结构中转换器基本都是JSON TO XML。 本文介绍一种动态映射SAP字段与外围系统报文的方式。这种方式有如下特征： 报文的字段名和SAP的参数名称完全一致，并且字段名必须全部大写（如果传递的报文有小写字段名会映射不到值）； 当SAP端参数结构发生变化时，只需要在SAP GUI中的企业服务端右键对应的企业服务对象使用“一致性检查”即可； CPI需要在最终的报文外层另包一层用来指向SAP端哪一个RFC的指向，参考内容修正符中Message Body中的内容。 上面填写的内容如下： JSON Prefix XML Namespace urn urn:sap-com:document:sap:rfc:functions soapenv http://schemas.xmlsoap.org/soap/envelope/ （2）设置CPI的运行时配置设置完上面的内容之后就可以不设置Mapping组件了。后续还需要再设置下接口的运行时配置，内容如下： 1xmlns:urn=urn:sap-com:document:sap:soap:functions:mc-style;xmlns:n0=urn:sap-com:document:sap:rfc:functions 10.Mapping组件（本次不涉及）通过Mapping组件设置字段映射内容的配置方式我后续会放在通过CPI配置调用外围系统的接口配置中介绍。本次主要介绍不需要配置Mapping组件的接口配置。 11.配置转换后的日志文件再编写一个脚本文件用来记录经过转换后的XML文件，用作记录。此处是为了排查万一由于转换的问题引起的BUG时，能通过两边的对照快速定位和解决问题。如果只记录传入的JSON报文的话，后续转换出现问题就不好排查了。配置方式其实和上面的第8项添加记录日志用脚本一致，只是需要修改下保存的日志附件名称。 （1）添加组件 （2）组件代码12345678910import com.sap.gateway.ip.core.customdev.util.Message;import java.util.HashMap;def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Request_XML&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 12.添加请求答复组件（1）组件介绍该组件可以理解成调用组件，他分别有三个通路。一个通路是接口调用时传入的请求信息，一个通路是调用接收者（也就是正式调用接口），另一个通路就是接口返回的通路。在该通路和传入的通路一样可以对返回的信息进行格式转换或记录日志文件等。 该组件本身并无什么属性设置，他的作用主要就是做一个类似于中转的流程。 新建请求答复组件并设置CPI调用的适配器类型与调用的接口地址。这里因为是外围系统调用我们的接口所以此处调用的接口地址就是我们上面发布的Web Service接口的WSDL地址。需要稍微变更一下，因为前面的内容太长了，可以使用域名代替。 （2）查看SAP主机的域名与端口SAP系统的域名与接口可以使用事务代码：SMICM。 点击上面红框圈起来的按钮会进入到下面的页面中。页面中主机名就是域名。 （3）查看CPI上的域名与端口号打开BTP平台上的云连接器页签。红框圈中的部分就是CPI上使用的域名与端口。 12345-- Web Service 的WSDLhttp://***********:8000/sap/bc/srt/wsdl/flv_10002A111AD1/bndg_url/sap/bc/srt/rfc/sap/ysflight_demo_01/100/ysflight_demo_01/ysflight_demo_01?sap-client=100-- CPI 域名替代后的WSDLhttp://******qas:44300/sap/bc/srt/rfc/sap/ysflight_demo_01/100/ysflight_demo_01/ysflight_demo_01 （4）添加组件添加完成SOAP的适配器后需要设置适配器中的属性。 Address：调用的接口地址 Proxy Type：指定使用的代理类型。 On-Premise：本地部署 Internet：网络部署 Location ID：BTP上配置的SAP服务器名称 Authentication：接口调用的权限认证方式 Credential Name：可理解成调用接口时连接对方系统的账号 **Timeout (in ms)**：接口的请求等待时长，单位为毫秒，默认为60秒一分钟时间。 （5）Credential Name下面介绍下如何创建和查找接口权限认证中的Credential Name。上面介绍了这个是用来认证调用接口系统的账号信息。一般是在监控器的安全材料中维护的。 因为是和SAP系统做连接的，所以一般最常用的连接方式就是和SAP系统的用户凭据类型的账号。这个其实就是SAP系统的系统账号。 创建的时候只需要起一个在CPI端可以引用的对象名称，选择安全材料的类型和用户名、密码即可。如下图所示。 13.记录接口调用返回的Response（1）添加日志记录脚本 （2）日志脚本代码12345678910import com.sap.gateway.ip.core.customdev.util.Message;import java.util.HashMap;def Message processData(Message message) &#123; def body = message.getBody(java.lang.String) def messageLog = messageLogFactory.getMessageLog(message) if (messageLog != null) &#123; messageLog.addAttachmentAsString(&#x27;Response&#x27;, body, &#x27;text/plain&#x27;) &#125; return message&#125; 14.设置格式转换器（1）设置转换器因为从SAP端返回的数据格式依然是XML形式的，但是对方系统接收的时候是需要JSON格式的数据。所以此处还需要再对数据做一次格式转换。并且因为我们的返回数据中数据是多条，所以对返回的JSON报文设置一个用来标识数组的字段结构。一般这种结构的名称是item。所以在配置XML Element时需要根据返回的XML结构内容定义一下数组结构。 （2）返回JSON数组设置XML Element添加的内容如下，设置时请注意大小写。映射时字段都是严格遵守大小写的。 1234/n0:YSFLIGHT_DEMO_01Response/ET_SFLIGHT/item/n0:YSFLIGHT_DEMO_01Response/IT_CARRID/item/n0:YSFLIGHT_DEMO_01Response/IT_CONNID/item/n0:YSFLIGHT_DEMO_01Response/IT_FLDATE/item 这里来介绍一下如何确定XML Element里面的内容。首先是n0这一部分，这个是urn:sap-com:document:sap:rfc:functions这一部分的简略写法。而这一部分设置的内容在上面的第9项第（2）小项 设置CPI的运行时配置。这个地方的命名空间映射分两段，前面的一段是传入数据的映射，后面的一端是传出数据的映射。 其余的属性都很好理解，内容如下： YSFLIGHT_DEMO_01Response：这个后面的Response是固定的，一段拼接在RFC名称后面的文本，请注意第一个字母是大写。YSFLIGHT_DEMO_01这个就是SAP端RFC的名称了； ET_SFLIGHT：需要转换为JSON数组的参数名称。这个其实就是上面新建RFC是的表参数名称，这几个表参数都是需要转成JSON数组形式的，所以这里设置了四个对象。 item：数组字段名，固定名称。 15.发布接口（1）完整接口流程 （2）发布接口前面查看部署状态时，在你点击部署按钮之后多等待一段时间。待其显示已启动状态后，点击导航至“管理集成内容”。 部分时候接口的地址需要多等待一段时间刷新后才会出来，所以一开始连续刷新没有接口地址也是正常的现象。 （3）其他查看接口地址的方式也可以在监控器的管理集成内容界面查看到上面的内容。具体位置如图中红框所示的内容。 四、测试CPI接口1.POSTMAN测试工具我们使用POSTMAN工具使用上面获取到的CPI地址，输入报文进行测试。 这个时候我们发现他返回了状态码401，这个代表的其实是没有进行权限认证。接下来我介绍如果设置这个认证对象。 2.接口权限对象我们点击图中的Authorization页签，选择接口认证类型为Basic Auth。然后在右侧输入CPI的认证账号和密码。 3.查询权限账号这个账号信息需要取BTP平台进行确认。通过BTP的实例和租用页签查看相关的内容。因为我这边没有有权限的账号无法查看，所以我这边就只在这里提一下。账号也可以直接向公司的Basis要。 4.发送请求输入完成之后再次回到原来的Body页签中，发送请求。可以看到接口返回的状态码是200，代表接口创建成功。但是没有查询到数据，所以几个对象都是空的。 5.查看CPI的日志管理首先进入CPI的监控器界面，然后选择所有部件。 6.查看接口日志（1）传入的报文 Request01 （2）将传入报文转化为XML （3）返回的报文因为我们是记录了没有经过格式转换的接口返回值，所以此处是XML的形式，如果想要查看返回的JSON内容可以考虑将日志记录脚本移动到XML TO JSON转换器之后，或在转换器之后再添加一个日志记录脚本。 以上就是通过Web Service发布的CPI接口的全部流程了，这种配置方式是最常用的也是最简单的一种接口配置方式。其实其中还应该有CPI端异常后的处理方式。但这部分内容我决定后面再单独做一篇记录用来讲解CPI的异常处理。","categories":[{"name":"SAP BTP","slug":"SAP-BTP","permalink":"https://www.yemaojun.top/categories/SAP-BTP/"},{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/categories/CPI/"}],"tags":[{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/tags/CPI/"}]},{"title":"CDS 视图基础内容","slug":"ABAP/CDS-视图基础内容/CDS-视图基础内容","date":"2024-05-27T00:21:51.000Z","updated":"2024-05-27T00:29:50.894Z","comments":true,"path":"2024/05/27/ABAP/CDS-视图基础内容/CDS-视图基础内容/","link":"","permalink":"https://www.yemaojun.top/2024/05/27/ABAP/CDS-%E8%A7%86%E5%9B%BE%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/CDS-%E8%A7%86%E5%9B%BE%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/","excerpt":"项目上有用到CDS和AMDP相关的东西。发现可以记录的东西挺多的，所以写一篇笔记将学习到的东西记录下来。以供后面复习和参考。","text":"项目上有用到CDS和AMDP相关的东西。发现可以记录的东西挺多的，所以写一篇笔记将学习到的东西记录下来。以供后面复习和参考。 CDS 视图基础内容 一、核心数据服务CDS1.CDS简介CDS（Core Data Services）是基于SAP HANA的一种新的用于定义语义更加丰富数据模型的架构，表现形式是CDS View。用户可以通过CDS View定义实体类型（如order、BP、Product）以及它们之间的实际联系。CDS使用基于标准SQL的DDL（数据定义语言）语言定义。 2.CDS View作用 简化SQL语句 提升效率（使数据模型可以在DB层面定义和处理） 3.CDS View类型（1）按照环境分类 ABAP CDS：在AS ABAP环境下可以使用的CDS，ABAP CDS是开放的，不仅仅局限于SAP HANA是和数据库无关的。 HANA CDS：在SAP HANA Studio环境下使用的CDS。 （2）按照是否带有参数分类 CDS View without Parameters CDS View with Parameters （3）开发者角度分类 Basic：基本视图。可理解为为查询透明表而创建的视图。 Composite：综合视图。这种视图大多时候会生成BOPF，就是会包含业务逻辑处理，大多也直接与表关联。常会提供给消费视图使用所以也可以叫做接口视图。有时也会被用作分析复杂逻辑用的分析类视图。 Consumption：消费视图。通常是生成提供OData消费使用。用于实现GetEntity与GetEntitySet等方法。 （4）HAVA CDS 与ABAP CDS差异① 相同点ABAP 和 HANA环境的View都是基于DDIC中已经存在的Table进行创建。 ② 不同点 HANA CDS必须创建对应与DDIC Table的并作为CDS View一部分的基本实体类型。 ABAP CDS需要考虑DDIC底层的所有Table View和CDS View内的类型，避免重复。 （5）AS ABAP使用HANA数据库作为中心数据库AS ABAP使用HANA数据库作为中心数据库时，使用ABAP CDS 和HANA CDS 的场景 如果要在ABAP中将CDS实体用作数据类型或者Open SQL的访问对象，或者想要评估ABAP CDS中定义的annotations，则必须使用ABAP CDS。 如果不需要在ABAP中访问CDS实体，但是希望将它与其他ABAP存储库（repository）对象一样进行传输和升级，那么可以使用ABAP CDS。 如果不将CDS实体用作数据类型或者Open SQL的访问对象，则可以使用HANA CDS，后者更好地集成到SAP HANA中，然而在ABAP中只能使用Natice SQL（ADBC、AMDP）进行访问。 注意事项： 对于每个CDS视图，在激活时都会在数据库中创建一个对应的数据库视图（SQL视图，可以在HANA环境中访问该数据库视图）。 CDS表函数由AMDP管理，还可以在本地访问相应的数据库函数。 在HANA本地环境中访问数据库视图（通过ABAP CDS视图生成）时会同时考虑相应的DCL中定义的授权逻辑。 （6）基本视图① 含义可理解为查询透明表而创建的视图。一般不会关联其他的业务表，只是作为查询表数据的视图使用。有很多的标准表也有基本视图，例如Mard的NSDM_V_MARD、MCHB表的NSDM_V_MCHB等。这些替代对象都是标准表的CDS视图，当我们在SAP使用SQL语句对这些表进行查询时其实他们是查询的替代对象（CDS视图）。 ② 基本视图条件作为基本视图还必须满足下面的条件： 公开了所有相关的业务数据； 可以直接访问数据库表和其他基本视图； 可以与其他基本视图相关联; 无冗余数据。 （7）复合视图① 含义复合视图仅使用基本视图和由基本视图中的关联提供的数据。可以简单理解为是根据业务需求将多个基本视图关联起来使用。例如如下业务场景，我们需要开发一个用于展示公司库存信息的视图，根据需求我们需要将批次库存与特殊库存组合到一个视图中进行展示。在这个业务场景中我们需要使用到的标准表与基本视图如下： 库存类型 标准表 基本视图（代理对象） 工厂级别库存 MBEW MBVMBEW 库存地点库存 MARD NSDM_V_MARD 供应商寄售库存 MKOL NSDM_V_MKOL 客户寄售库存 MSKU NSDM_V_MSKU 供应商外包库存 MSLB NSDM_V_MSLB 销售订单库存 MSKA NSDM_V_MSKA 批次库存 MCHB NSDM_V_MCHB 在编写上面的业务需求时，需要在CDS开发工具中（HANA Studio&#x2F;Eclipse）中将上面的基本视图组合在一起将所有的库存信息查询出来。 ② 复合视图条件 可以访问基本视图和其他复合视图； 本质上，引入了数据冗余； 复合视图是可重用的； 可以与其他基本视图相关联。 （8）消费视图① 含义消费视图通常称为分析视图，一般是生成提供给OData消费使用。用于实现GetEntity与GetEntitySet等方法。 ② 消费视图条件 应报告其数据的子集，即提供基本数据的界面视图（尺寸视图或分析视图）上的投影和（可选）全局过滤器； 限制或计算所需的参数； 特定的限制措施，而不是重用视图中包含的基本措施； 特定的计算量度，特别是那些在聚合后需要计算的量度； 异常聚合，例如，实体计数器； 主数据文本和显示属性，通常与此报告相关； 用于此查询的报表中的层次结构； 参数和过滤器用作变量；及其静态或派生的默认值； 默认显示形式，用于在通用UI中高度可用的初始显示（轴：行与列，总计开&#x2F;关，层次开&#x2F;关等）。 上面三种视图（基本、复合和消费视图）介绍内容摘自《CDS从入门到精通–2视图的类型》 4.SAP系统中的CDS View在数据库表TADIR中查询条件PGMID &#x3D; ‘RTR3’，OBJECT &#x3D; ‘DDLS’，可以在列DEVCLASS（Package）中找到所有DDL源代码和每个源代码的包，根据该包可以使用ADT（HANA Studio中的ABAP开发工具）来查看DDL源代码。 DDLDEPENDENCY表中包含了所有DDL源的名称和其中定义的CDS实体名称（列OBJECTTYPE的值为STOB），以及生成的数据库视图的名称（列OBJECTTYPE的值为VIEW），对于每个DDL源都有两行数据。 在CDS中必须有两个名称： 一个名称用于在数据字典中创建SQL视图（可以使用SE11查看该名称） 一个用于CDS视图实体，该实体用于Eclipse查看和维护 注：SQL View 和CDS View命名不能相同，可以使用SE11查看SQL视图但是不能修改；只有CDS View Entity才是我们在程序中的Select语句中使用的对象（作为data source使用）。 5.CDS的显著特征（1）CDS是SQL的一种增强，它为我们提供了一种数据定义语言（DDL），用于在数据库中定义语言丰富的额数据表&#x2F;视图（CDS实体）和用户定义的类型。 （2）增强点如下： **Annotations:**丰富了带有附加（特定领域的）元数据的数据模型，一个annotation就是一行以@开始的代码。 **Associations:**概念级别的关联，用于查询中简单的路径表达式替代连接。 **Expressions:**在数据模型中用于计算和查询的表达式。 （3）CDS视图可以通过ABAP数据字典管理，在CDS激活时，在HANA层上会创建一个数据库视图，但是只有ABAP CDS视图（CDS实体即DDL源）必须通过ABAP CTS传输。 语义更加丰富的数据模型 特定领域的语言（DDL、QL、DCL） 声明更接近于概念思维 CDS完全基于SQL 标准SQL的特性都可以在CDS上直接使用 与所有的DB产品兼容 生成并管理SQL View 与SAP HANA的天然整合 与特定领域的 Framework有着通用的基础，例如UI、Analytics、OData 丰富的内置函数和代码下放 突破场景的Table Function 丰富的内在SQL函数 可扩展性 在建模层面可扩展 在元模型层面可使用注释 二、CDS视图的创建与调用1.开发工具（1）开发工具介绍CDS View的开发工具主要有两种，一种是添加了ABAP开发插件的Eclipse，另一种是SAP官方推出的HANA Studio。两者在使用方面没有什么明显的区别，但是在这里介绍一下如何使用这两种开发工具去创建CDS视图。 这里有个注意事项，那就是使用下面两种开发工具开发之前都需要确保你的电脑安装有SAP GUI，并且其中有SAP客户端的连接信息。因为后面在连接SAP系统时的信息是从SAP GUI中获取的。 如果有需要开发工具的可以在评论区联系我，我这边有Hana Studio。 （2）Eclipse 2021 ADT① 安装插件使用Eclipse作为开发工具前需要先安装一个ABAP Development Tools插件。 ② 连接SAP GUI想要使用CDS视图则必须要将CDS的运行设置在自己系统的服务器上。所以在开始使用CDS之前必须先让Eclipse连接到自己的服务器。 点击Eclipse左上角的File –&gt;New –&gt;Project。 选择创建ABAP Project。 选择要连接的开发系统。 进入下一步，在这一步存在三个必输项，但是必输项的内容会从你之前选择的系统带过来所以直接下一步即可。 接下来就和登录SAP GUI一样输入客户端号、用户名、密码和语言种类。 当创建好ABAP Project后会在整个页面的最左边查看到刚刚新建好的ABAP Project。此时的项目名称为登录的系统名_客户端号_登录用户名_语言种类。 注意事项：一个ABAP Project只能只有一个人的账号，即一个项目与一个账号绑定。如果要使用别的账号创建CDS视图则需要使用新账号重新创建CDS视图。 （3）HANA Studio 连接SAP① 新建ABAP Project点击HANA Studio左上角的File -&gt; New -&gt; ABAP Project。 ② 选择连接的系统点击后会弹框你存储在SAP GUI中的系统信息，此时选择你需要连接的系统即可。后续会将系统的信息全部带出来，所以只需要一直下一步到输入登录系统的账号密码那一步即可。 选择号系统后点击下一步按钮会自动从你的SAP GUI中将SAP系统信息带出来。直接下一步即可。 ③ 登录系统进行完上面的操作之后到这一步就是输入密码登录SAP系统了。完成之后就会在左侧发现成功连接上的ABAP Project了。 ABAP Project创建成功。 2.创建CDS视图（1）新建一个CDS视图当你创建过CDS视图后，你可以在你的对应包&#x2F;本地下面找到一个Core Data Services文件夹，在其下有一个Data Definitions文件夹。在这个文件夹下面就是你新建的所有CDS视图对象了。你可以直接在Data Definitions文件夹上单机鼠标右键新建一个CDS对象。但是考虑到可能有人没有创建过CDS视图，所以下面的步骤从包&#x2F;本地的层级下新建CDS视图。 （2）Other ABAP Repository Object在包名上右键按照下图所示的内容新建对象。 （3）Core Data Services -&gt; Data Definitions在弹出的框中寻找Core Data Services文件夹下的Data Definitions对象。单击Next。 （4）New Data Definitions到这一步开始就和最上面提到的从Data Definitions文件夹新建的步骤对接上了。在那个位置新建CDS对象就会弹出下面的弹框输入CDS视图的名称，存放视图的包和视图描述信息等。 （5）选择传输的请求号填写完上述的信息后单机Next。如果你存放的不是本地包，则需要为当前新建的CDS对象选择一个请求号对象。若是本地对象则继续Next即可。不要点击Finish。 （6）选择创建的模板介绍一下我们开发工具（HANA Studio&#x2F;Eclipse）创建CDS时的模板。为了方便开发人员开发CDS视图，开发工具本身提供了很多能简化开发的CDS模板程序。下图便是创建CDS时开发工具提供的模板内容。我们一般常用的就是图中所示的模板内容，但其实还有很多其他的例如需要关联其他视图或数据表的Define View with Join模板；用来开发带参数的CDS的模板Define View with Parameters等。 模板的种类很多，具体要使用什么模板可以根据技术的需求参照模板右侧的文本描述和下面的参考代码选择。 有个注意事项，当你在第（3）或（4）步点击Finish的话，开发工具会自动创建你上一次使用的模板对象。即如果你上次选择的是Define View模板的话，这次创建的CDS模板也是Define View。 （7）编写CDS代码在新创建好的视图中编写如下内容： 1234567891011121314@AbapCatalog.sqlViewName: &#x27;YTEMPLATE1_V&#x27; // SAP CDS视图名称@AbapCatalog.compiler.compareFilter: true // 是否开启比较过滤器@AbapCatalog.preserveKey: false // 是否保留密钥@AccessControl.authorizationCheck: #NOT_REQUIRED // 是否需要权限校验@EndUserText.label: &#x27;测试CDS模板创建&#x27; // 定义CDS对象的可翻译语义文本define view YTEMPLATE1_CDS as select from sflight&#123; key carrid, key connid, key fldate, price, currency&#125; 在上面的第一个注解后可以看到注释是SAP CDS视图名称。指在SAP中的视图名称。YTEMPLATE1_CDS是CDS视图实体对象，而YTEMPLATE1_V是CDS视图对象。如果要在SAP使用这个视图就需要使用到YTEMPLATE1_V这个名称。 3.在开发工具中运行CDS当你在开发工具中开发完成一个CDS对象后如果想要查看运行结果可以按照下面的步骤进行。 （1）编写CDS视图并激活 （2）运行CDS视图在视图的编辑框上右键或点击横幅上面的运行按钮选择ABAP Application。运行CDS视图。 （3）结果展示 4.删除CDS视图选择你要删除的视图，右键删除按钮即可。 5.CDS视图的传输当创建的CDS视图不是在本地存储时，系统会需要CDS绑定一个CTS号（SE09中的请求号）。但是在传输CTS时只有CDS视图实体保存在CTS中。所有变更对象和传输都在ABAP层进行端到端的管理，不需要传到较低层级二点数据库层来管理CDS实体和组件的传输。 6.带参数的CDS视图（1）参数介绍在as select语句前视图名称之后使用关键词，设置完该参数之后在调用视图时需要先输入参数值才能继续执行。类似于必输筛选字段。 12with parameters 变量名 : 参照的字段类型， 变量名 : 参照的字段类型 （2）创建带参数的CDS视图先填入CDS视图的名称与描述信息，然后一直下一步到选择模板的界面。 选择图中所示的模板，该模板代表创建的是带参数的CDS视图。 （3）编写视图逻辑123456789101112131415161718@AbapCatalog.sqlViewName: &#x27;YPARAMETERS_V&#x27;@AbapCatalog.compiler.compareFilter: true@AbapCatalog.preserveKey: true@AccessControl.authorizationCheck: #NOT_REQUIRED@EndUserText.label: &#x27;带参数的CDS视图&#x27;define view YPARAMETERS_CDS with parameters iv_carrid : s_carr_id, iv_connid : abap.numc( 4 )as select from sflight&#123; key carrid, key connid, key fldate, price, currency&#125; where carrid = :iv_carrid and connid = $parameters.iv_connid 在声明参数时有两种定义类型的方式，一种是直接使用SE11数据字典中的类型，另一种是SAP的基本数据类型。 而在调用参数时也有两种方法，一种是在参数前加:引用，另一种是使用**$parameters.**的方式调用。 （4）执行CDS在执行时如上面所说的，声明了参数就相当于是必输参数，在使用视图时需要先为参数赋值。完成之后再运行视图。 运行结果。 三、CDS系统变量1.介绍CDS中的系统变量一般是以**$session**作为开头来使用的，和SAP的系统系统变量是一样的效果。主要是下面四个变量。 变量名 用途 $session.user 当前用户 id 与 ABAP中系统字段 SY-UNAME 的值一样 $session.client 当前客户端，默认值与 SY-MANDT 一样，在Open SQL中使用 USING CLIENT语句指定，在 ABAP 中调用设定了 AMDP OPTIONS CDS SESSION CLIENT的AMDP方法时，需要指定 $session.system_language 当前内部会话的文本环境语言，ABAP中系统字段 SY-LANGU的值 $session.system_date ABAP 的当前日期，ABAP中系统字段SY-DATUM的值 使用的方法和上面使用参数创建的CDS一样，在需要引用的位置按照**$Session.vname**的形式进行使用。 2.示例（1）作为关联条件1234567891011121314@AbapCatalog.sqlViewName: &#x27;YSYSTEM_VAR_V&#x27;@AbapCatalog.compiler.compareFilter: true@AbapCatalog.preserveKey: true@AccessControl.authorizationCheck: #NOT_REQUIRED@EndUserText.label: &#x27;CDS视图的系统变量&#x27;define view YSYSTEM_VAR_CDS as select from mara as a left outer join makt as t on t.matnr = a.matnr and t.spras = $session.system_language&#123; key a.matnr, t.maktx&#125; （2）作为Where筛选条件12345678910111213@AbapCatalog.sqlViewName: &#x27;YSYSTEM_VAR_V&#x27;@AbapCatalog.compiler.compareFilter: true@AbapCatalog.preserveKey: true@AccessControl.authorizationCheck: #NOT_REQUIRED@EndUserText.label: &#x27;CDS视图的系统变量&#x27;define view YSYSTEM_VAR_CDS as select from mara as a left outer join makt as t on t.matnr = a.matnr&#123; key a.matnr, t.maktx&#125; where t.spras = $session.system_language 四、CDS 语法介绍1.基本语法（1）Select① 用途和普通的SQL语句类似，代表查询。 ② 示例1234567define view YTEMPLATE1_CDS as select from data_source_name&#123; field1, field2, ...&#125; （2）Key① 用途用来标识视图中的主键字段。 @AbapCatalog.preserveKey: true 这句annotation 的值为TRUE时，SQL view中的key字段使用CDS中定义的key； 值为FALSE时，使用DB table中table的key field. ② 示例1234567891011@AbapCatalog.sqlViewName: &#x27;YTEMPLATE1_V&#x27;@AbapCatalog.preserveKey: truedefine view YTEMPLATE1_CDS as select distinct from sflight&#123; key carrid, connid, fldate, price, currency&#125; ③ 效果截图 注解为True时 注解为False时 （3）Select Distinct① 用途在最终查询出来的结果集中对所有字段进行去重。值得注意的是无法只根据个别字段进行去重，只能根据整个结果集去重。 ② 示例12345define view YTEMPLATE1_CDS as select distinct from sflight&#123; key carrid&#125; ③ 效果截图 示例代码运行结果 数据库表运行结果 （4）Where语句① 用途用来对数据进行筛选的条件语句，一般添加在CDS语句的最后。 ② 示例12345678910define view YTEMPLATE1_CDS as select from sflight&#123; key carrid, key connid, key fldate, price, currency&#125; where carrid = &#x27;AA&#x27; ③ 运行结果 2.CDS 聚合与Join（1）聚合函数① 用途注：在使用聚合函数时需要同时使用Group By语句对数据进行分组。 函数名称 函数描述 MIN 获取操作数的最小值 MAX 获取操作数的最大值 AVG 操作数的平均值（操作数必须是数字）。只有添加AS dtype时才支持类型INT8。不支持用于十进制浮点数的类型DF16、DF34。也不支持类型DATN、TIMN和UTCL。 SUM 操作数之和（操作数必须是数字）。不支持用于十进制浮点数的类型DF16、DF34。也不支持类型DATN、TIMN和UTCL。 COUNT 如果指定了DISTINCT操作数，则计算操作数的不同值数；如果指定为*，则计算结果集中的总行数。 ② 示例1234567891011121314define view YTEMPLATE1_CDS as select from sflight&#123; key sflight.carrid, key sflight.connid, count( * ) as count_all, count( distinct carrid ) as count_dis, min( price ) as price_min, max( price ) as price_max, avg( price ) as price_agv, avg( price as abap.curr( 15, 2 ) ) as price_agv_curr, sum( price ) as price_sum&#125; group by carrid,connid ③ 运行结果 （2）Group By① 用途该语句是分组语句，一般不会单独使用。使用时基本都是和聚合函数一起使用。详细的使用方法和示例可以参照上面的结果。 （3）Having① 用途和Group By语句不同，该语句只能使用在有聚合函数的CDS中。其作用是针对聚合函数的结果再做一边筛选。例如我想要筛选出price字段最大值在600以上的数据，就可以按照下面的语句编写。 ② 示例123456789101112131415define view YTEMPLATE1_CDS as select from sflight&#123; key sflight.carrid, key sflight.connid, count( * ) as count_all, count( distinct carrid ) as count_dis, min( price ) as price_min, max( price ) as price_max, avg( price ) as price_agv, avg( price as abap.curr( 15, 2 ) ) as price_agv_curr, sum( price ) as price_sum&#125; group by carrid,connid having max( price ) &gt;= 600 ③ 运行结果可以发现运行结果和上面的相比没有最大价格在600以下的数据。 （4）Join① 用途 连接类型 连接描述 理解 left outer join 将主数据源中的记录与辅助数据源的记录联接，以便 主数据源的所有记录都包含在结果中。 将主表的所有数据展示出来，辅助表的数据有则展示，无则返回Null right outer join 将主数据源中的记录与辅助数据源的记录联接，以便 辅助数据源的所有记录都包含在结果中。 将辅助表的所有数据展示出来，主表的数据有则展示，无则返回Null inner join 将来自主数据源的数据与来自辅助数据源的数据联接，以便 结果包含来自主数据源的所有数据，辅助数据源中至少有一个联接伙伴 存在。 取两个表的交集部分 cross join 将主数据源的所有记录与辅助数据源的所有记录合并。 生成的数据集包含的条目数等于主数据源中的记录数乘以 辅助数据源中的记录数。 将两个表的所有数据都取出来，然后按照笛卡尔积的形式进行组合。 使用上面的关联条件时有个注意事项，那就是当你使用了关联的同时，还是使用了Where子句当满足下面的条件时将会将结果变为inner join。 左外连接：Where子句的筛选条件包含了辅助表（关联表）的字段进行筛选时 右外连接：Where子句的筛选条件包含了主表的字段进行筛选时 cross join：使用Where子句时结果变为inner join ② 示例 left outer join 1234567891011121314define view YJOIN_TEST_CDS as select distinct from sflight as s left outer join scarr as r on r.carrid = s.carrid left outer join spfli as p on p.carrid = s.carrid and p.connid = s.connid&#123; key r.carrid, key p.connid, s.planetype, p.distance, r.carrname&#125; 请注意下图红框圈中的数据，该条记录是我手动添加在sflight表中的数据。该条记录在另外两个外键表scarr与spfli中是没有相关记录的，所以才会在引用了这两张外键表字段的列中显示为初始值。 但是因为使用的是左外连接，所以在关联时会将主表sflight的所有数据都罗列出来。而下面红框圈中的数据虽然在两外键表中不存在，但因是主表的数据所以也被展示出来了。 right outer join 1234567891011121314define view YJOIN_TEST_CDS as select distinct from sflight as s right outer join scarr as r on r.carrid = s.carrid right outer join spfli as p on p.carrid = s.carrid and p.connid = s.connid&#123; key r.carrid, key p.connid, s.planetype, p.distance, r.carrname&#125; 使用右外连接会将关联表的所有数据都展示出来，而主表的数据不存在时则不会展示。和上面的数据对比后发现上面红框圈起来的只在主表存在的数据并没有被展示出来。因为这条数据在另外两张表中是不存在的。 inner join 使用下面语句时我们先将sflight表中所有的 AA 0017的数据全部删除掉，然后使用下面的SQL查询结果。 1234567891011121314define view YJOIN_TEST_CDS as select distinct from sflight as s inner join scarr as r on r.carrid = s.carrid inner join spfli as p on p.carrid = s.carrid and p.connid = s.connid&#123; key r.carrid, key p.connid, s.planetype, p.distance, r.carrname&#125; 由上面的连接条件得知在另外两张表中是存在Carrid字段为AA，Connid字段为0017的数据的。但是当我们删除掉主表sflight中对应的数据后，在下面的结果中并没有展示出来我们删除的数据，而是取出来了三个表中都存在的数据。所以可看出inner join是获取关联表与主表的交集数据的。 cross join 这种关联方式上面提过，是将关联的表的所有数据按照笛卡尔积的形式组合起来。下面对笛卡尔积进行解释。 存在两个集合A与B，其包含的值如下所示： A &#x3D; { 1,2 } B &#x3D; { 3,4,5 } 两个集合交叉关联或说进行笛卡尔积 A×B B×A。 A×B &#x3D; { (1,3),(1,4),(1,5),(2,3),(2,4),(2,5) } B×A &#x3D; { (3,1),(3,2),(4,1),(4,2),(5,1),(5,2) } 通过上面的演示可以发现笛卡尔积满足下面的条件： 两个结果不满足A×B &#x3D; B×A的交换律 集合总个数 &#x3D; A集合总个数 × B集合总个数 12345678define view YJOIN_TEST_CDS as select distinct from spfli as s -- 14条记录 cross join scarr as r -- 18条记录&#123; key r.carrid, key s.connid, r.carrname&#125; 可以看到最终运行出来的总条数是 14 × 18 &#x3D; 252条记录，我防止查询的最大展示条数为300。 （5）union① 用途将两个或多个结果集合并到一起输出，但是每个子结果集的字段名与数量等必须一致。十分好用的一个语句，当我们有需求需要将多个SQL的结果合并到一起时可以使用这个语句。他有两种合并方式。 union：将结果集进行合并，当存在相同的数据时只展示其中一条。可理解为合并结果集时进行去重。 union all：同样将结果集进行合并，但是不会对其中的数据进行去重，直接将结果集的数据原样有多少就合并多少。 ② 示例 union 123456789101112131415161718define view YJOIN_TEST_CDS as select distinct from spfli&#123; key carrid, key connid, countryfr, cast( &#x27;&#x27; as abap.char( 20 ) ) as carrname&#125;unionselect distinct from scarr&#123; key carrid, key cast( &#x27;&#x27; as abap.numc( 4 ) ) as connid, cast( &#x27;&#x27; as abap.char( 3 ) ) as countryfr, carrname&#125; union all 123456789101112131415161718define view YJOIN_TEST_CDS as select distinct from spfli&#123; key carrid, key connid, countryfr, cast( &#x27;&#x27; as abap.char( 20 ) ) as carrname&#125;union allselect distinct from spfli&#123; key carrid, key connid, countryfr, cast( &#x27;&#x27; as abap.char( 20 ) ) as carrname&#125; ③ 运行结果 union 沿用上面测试spfli表和scarr表的总数据条数可以看到合并后集合总数为 14 + 18 &#x3D; 32。 union all 这次直接将两个SQL写成一样的，然后使用union all语句对结果进行验证发现合并时并没有将重复的数据去重，而是直接合并在一起了。 五、CDS视图中的内置函数1.数值运算函数（1）内容 方法名称 描述 ABS(arg) arg的绝对值 CEIL(arg) 不小于arg的最小整数 FLOOR(arg) 不大于arg值的最大的整数 DIV(arg1,arg2) arg1 除以 arg2。但是仅允许输入整数，且返回的结果也只是整数 DIVISION(arg1,arg2,dec) 常规除法，结果四舍五入到小数点后dec位。但是无法传入浮点数 MOD(arg1,arg2) 常规余数运算，计算余数值 ROUND(arg, pos) 按照指定的保留pos位小数，然后四舍五入的值 （2）代码示例1234567891011121314151617define view YBUILTFUNCTIONas select from sflight as a&#123; key a.carrid, ABS( -123.31 ) as abs, -- ABS绝对值 CEIL( -1.5 ) as ceil, -- 不小于输入值的最小整数 FLOOR( -1.5 ) as floor, -- 不大于输入值的最大的整数 DIV( 3 , 2 ) as div, -- 输入值除以2 DIVISION( 10 , 3 , 6) as divsion, -- 除法运算，四舍五入到小数点后十位 MOD( 10, 3 ) as mod, -- 取模运算，计算余数 a.price, ROUND( a.price, 1 ) as round --四舍五入，保留1位小数&#125; -- 为了只显示一条数据所作的筛选 where a.carrid = &#x27;AA&#x27; and a.connid = &#x27;0017&#x27; and a.fldate = &#x27;20231010&#x27; （3）运行结果 2.字符串函数（1）内容 方法名称 描述 LENGTH( str ) 返回字符串str的长度 INSTR( str, find ) 返回字符串str中find字符&#x2F;字符串所在的位置索引 CONCAT( str1, str2 ) 拼接两个字符串 CONCAT_WITH_SPACE( str1, str2, space ) 在两个字符串拼接处添加space（整数）个空格 LEFT( str, len ) 从左向右截取字符串str的len（整数）位，可以用在关联条件中 RIGHT( str, len ) 从右向左截取字符串str的len（整数）位，可以用在关联条件中 LOWER( str ) 将字符串str转换为小写 UPPER( str ) 将字符串str转换为大写 LPAD( str1, len, str2 ) 字符串填充，从字符串str1的最左侧填充字符串str2。最后填充后的字符总长为len。 RPAD( str1, len, str2 ) 字符串填充，从字符串str1的最右侧填充字符串str2。最后填充后的字符总长为len。 LTRIM( str, cha ) 从最左侧开始删除字符串str中的字符cha，直到字符串str1中的第一个字符不为cha为止 RTRIM( str, cha ) 从最右侧开始删除字符串str中的字符cha，直到字符串str1中的第一个字符不为cha为止 REPLACE( str1, str2, str3) 在字符串str1中寻找字符&#x2F;字符串str2替换为字符&#x2F;字符串str3 SUBSTRING( str, pos, len ) 从做开始的第pos（正整数）位截取字符串str长度为len（正整数）的内容 （2）代码示例123456789101112131415161718192021define view YSTRINGFUNC as select from scarr&#123; key carrid, carrname, url, LENGTH( carrname ) as str_length, -- 返回字符串carrname的长度 INSTR( carrname, &#x27;S&#x27; ) as str_posion, -- 返回查找的字符在字符串中的第一个位置 CONCAT( carrid, carrname ) as str_concat, -- 返回两个字符串拼接后的结果 CONCAT_WITH_SPACE( carrid, carrname, 2 ) as str_con_space, -- 返回拼接两个字符串时在中间拼接了2个空格的字符串结果 LEFT( carrname, 3 ) as str_left, -- 返回字符串carrname从左到右边第3位的字符串结果 RIGHT( carrname, 3 ) as str_right, -- 返回字符串carrname从右到左边第3位的字符串结果 LOWER( carrname ) as str_lower, -- 将字符串carrname全部转换为小写后的结果返回 UPPER( carrname ) as str_upper, -- 将字符串carrname全部转换为大写后的结果返回 LPAD( carrname, 18 , &#x27;&amp;&#x27; ) as str_lpad, -- 在字符串左侧填充字符&#x27;&amp;&#x27;，直到字符串总长等于18 RPAD( carrname, 18 , &#x27;*&#x27; ) as str_rpad, -- 在字符串右侧填充字符&#x27;*&#x27;，直到字符串总长等于18 LTRIM( url, &#x27;h&#x27; ) as str_ltrim, -- 从字符串最左侧删除字符 &#x27;h&#x27; RTRIM( url, &#x27;m&#x27; ) as str_rtrim, -- 从字符串最右侧删除字符&#x27;m&#x27; REPLACE( url, &#x27;www&#x27;, &#x27;123&#x27; ) as str_replace, -- 替换字符串url中字符串&#x27;www&#x27;为&#x27;123&#x27; SUBSTRING( url, 1, 10 ) as str_substring -- 截取字符串从1位开始长度为10的内容 &#125; （3）运行结果 3.日期函数（1）内容下表中所有的Error均为参数中日期异常时的处理方案，均为可选。 方法名称 描述 DATS_ADD_DAYS( dats, day, [error] ) 为日期dats新增或减去day天。day为正数时为加，负数时为减 DATS_ADD_MONTHS( dats, month, [error] ) 为日期dats新增或减去month月。error为异常时的处理方案 DATS_DAYS_BETWEEN( dats1, dats2 ) 计算两日期间相差的天数。 DATS_IS_VALID( dats ) 校验dats是否时有效日期。有效返回1，无效返回0。 下表是异常处理状态表 异常名称 描述 FAIL 发生错误时，运行一个异常状态 NULL 发生错误时返回null INITIAL 发生错误时返回initial UNCHANGED 发生错误时返回一个未修改的日期值 （2）代码示例123456789101112define view YDATETIMEFUNC as select from sflight&#123; key fldate, DATS_ADD_DAYS( fldate, 4, &#x27;INITIAL&#x27; ) as dats_day_add, -- 为日期字段fldate的当前日期加四天 DATS_ADD_DAYS( fldate, -4, &#x27;INITIAL&#x27; ) as dats_day_reduce, -- 为日期字段fldate的当前日期减四天 DATS_ADD_MONTHS( fldate, 1, &#x27;INITIAL&#x27; ) as dats_months_add, -- 为日期字段fldate的当前日期加一个月 DATS_ADD_MONTHS( fldate, -1, &#x27;INITIAL&#x27; ) as dats_months_reduce, -- 为日期字段fldate的当前日期减一个月 DATS_DAYS_BETWEEN( fldate, 20240101 ) as dats_between, -- 计算fldate到20240101之间相差的天数 DATS_IS_VALID( fldate ) as dats_vali1, -- 判断fldate的字段值是否是日期 DATS_IS_VALID( 20240101 ) as dats_vali3 -- 判断20240101的字段值是否是日期&#125; （3）运行结果 4.时间函数（1）内容 函数名称 描述 TIMS_IS_VALID( tims ) 判断传入的tims字段是否是时间数据 TIMS_TO_TIMN( tims, [error] ) 将时间tims转换为timn类型 TIMS_FROM_TIMN( timn, [error] ) 将timn类型转换为tims类型 （2）示例代码1234567891011define view YDATETIMEFUNC with parameters iv_time : abap.tims as select from sflight&#123; key fldate, :iv_time as time, -- 时间函数 TIMS_IS_VALID( cast( :iv_time as abap.tims ) ) as tims_valid, -- 判断当前传入的字段是否是时间 TIMS_TO_TIMN( cast( :iv_time as abap.tims ), &#x27;INITIAL&#x27; ) as tims_to_tomn-- 将时间类型转换为timn类型&#125; （3）运行结果 5.时区与时间戳函数（1）内容 函数名称 描述 ABAP_SYSTEM_TIMEZONE( client, [error] ) 获取传入客户端的时区 ABAP_USER_TIMEZONE( user, client, [error] ) 获取用户主数据的时区 TSTMP_CURRENT_UTCTIMESTAMP( ) 获取当前的时间戳 TSTMP_IS_VALID( tstmp ) 判断传入的字段是否是时间戳格式 DATS_TIMS_TO_TSTMP( dats, tims, timezone, client, [error] ) 将传入的日期dats和时间tims组合成时间戳。timezone时区，client客户端 TSTMP_ADD_SECONDS( tstmp, sec, [error] ) 为时间戳tstmp加&#x2F;减去sec秒 TSTMP_SECONDS_BETWEEN( tstmp1, tstmp2, [error] ) 计算两时间戳字段之间相差的秒数 TSTMP_TO_DATS( tstmp, tzone, cilent, [error] ) 从传入的时间戳中获取日期，返回D类型数据 TSTMP_TO_TIMS( tstmp, tzone, cilent, [error] ) 从传入的时间戳中获取时间，返回T类型数据 TSTMP_TO_DST( tstmp, tzone, cilent, [error] ) 将时间戳数据转换为DST数据 （2）示例代码12345678910111213141516171819202122232425262728define view YDATETIMEFUNC as select from sflight&#123; key fldate, -- 时区与时间戳函数 ABAP_USER_TIMEZONE( &#x27;E-CHENYH&#x27;, $session.client, &#x27;NULL&#x27; ) as t_user_timezone, -- 获取用户所在的时区 ABAP_SYSTEM_TIMEZONE( $session.client, &#x27;NULL&#x27; ) as t_timezone, -- 获取传入client的时区信息 TSTMP_CURRENT_UTCTIMESTAMP( ) as t_now_timestamp, -- 当前的时间戳 DATS_TIMS_TO_TSTMP( fldate, &#x27;173158&#x27;, abap_system_timezone( $session.client, &#x27;NULL&#x27; ), $session.client, &#x27;INITIAL&#x27; ) as dats_tstmp, -- 将传入的日期与时间还有时区转换为时间戳 TSTMP_ADD_SECONDS( TSTMP_CURRENT_UTCTIMESTAMP( ), cast( 30 as abap.dec( 15, 0 ) ), &#x27;FAIL&#x27; ) as t_add, -- 为当前时间戳加上30秒 TSTMP_SECONDS_BETWEEN( TSTMP_CURRENT_UTCTIMESTAMP(), tstmp_add_seconds( tstmp_current_utctimestamp(), cast( 25000 as abap.dec(15,0) ), &#x27;FAIL&#x27;), &#x27;FAIL&#x27;) as t_between, -- 计算两时间戳字段之间相差的秒数 TSTMP_TO_DATS( TSTMP_CURRENT_UTCTIMESTAMP( ), abap_system_timezone( $session.client, &#x27;NULL&#x27; ), $session.client, &#x27;NULL&#x27; ) as t_to_dats, -- 将时间戳中的日期转换出来 TSTMP_TO_TIMS( TSTMP_CURRENT_UTCTIMESTAMP( ), abap_system_timezone( $session.client, &#x27;NULL&#x27; ), $session.client, &#x27;NULL&#x27; ) as t_to_tims, -- 将时间戳中的时间转换出来 TSTMP_TO_DST( TSTMP_CURRENT_UTCTIMESTAMP( ), abap_system_timezone( $session.client, &#x27;NULL&#x27; ), $session.client, &#x27;NULL&#x27; ) as t_to_dst -- 将时间戳中转换为dst类型&#125; （3）运行结果 6.计量单位转换函数（1）函数介绍1234unit_conversion( quantity =&gt; 重量数值, source_unit =&gt; 重量的原单位, target_unit =&gt; 重量转换的目标单位, error_handling =&gt; 异常的处理方式 ) （2）其余内容异常处理方式有两种。单位转换和货币转换两种的异常处理方式都是一样的。 异常处理名称 异常处理描述 FAIL_ON_ERROR 异常处理的默认值，发生异常时抛出异常 SET_TO_NULL 异常时返回NULL值 KEEP_UNCONVERTED 异常时返回一个未转换的货币金额 计量单位的转换规则使用事务代码CUNI进行维护，数据存储在T006表中。而在SAP中可以使用下面的Function对计量单位进行转换。详细的可以参考这篇博文：SAP 基本单位与物料计量单位间的转换。里面介绍了这三种SAP中单位转换的Function并附有参考代码。 函数名称 函数描述 UNIT_CONVERSION_SIMPLE 基本单位间的转换 MD_CONVERT_MATERIAL_UNIT 计量单位之间转换 MATERIAL_UNIT_CONVERSION 每基本单位等于多少计量单位 （3）代码示例123456789101112define view ZUNITCONVERSION as select from mara&#123; key matnr as material, brgew as MatQuan, meins as SrcUnit, gewei as TgtUnit, unit_conversion( quantity =&gt; brgew, -- 重量数值 source_unit =&gt; meins, -- 重量原单位 target_unit =&gt; gewei, -- 重量目标单位 error_handling =&gt; &#x27;SET_TO_NULL&#x27; ) as ConvF1 -- 异常时设置为NULL&#125; （4）运行结果 7.货币转换函数（1）函数介绍123456currency_conversion( amount =&gt; 货币金额, source_currency =&gt; 货币的原币种, target_currency =&gt; 转换的目标币种, exchange_rate_type =&gt; 汇率类型, exchange_rate_date =&gt; 汇率转换的日期, error_handling =&gt; 异常处理方式 ) （2）其余内容使用该内置函数转换货币金额时需要传入汇率日期，函数会自动去数据库表TCURR中查找对应的汇率信息。当你填入的汇率日期在数据库表中不存在或小于对应的有效期则会报错。此时就需要使用事务码OB08或视图V_TCURR去维护汇率信息。 即使内置函数使用的是SAP一样的功能模块和相同的规则等信息，但是因为舍入规则等并无法保证两者得到的结果是一致的。 查看SFLIGHT表中的货币类型为 USD（美元）、EUR（欧元）、JPY（日元）、AUD（澳元）和SGD（新加坡货币）。所以在视图V_TCURR中维护它们几种货币M类型的汇率信息。 （3）代码示例12345678910111213141516define view YCURRENCYCONV as select distinct from sflight&#123; key carrid, key connid, price, currency, currency_conversion( amount =&gt; price, -- 货币金额 source_currency =&gt; currency, -- 货币的原币种 target_currency =&gt; cast( &#x27;CNY&#x27; as abap.cuky ), -- 转换的目标币种 exchange_rate_type =&gt; &#x27;M&#x27;, -- 汇率类型 M : 平均汇率下的标准换算 exchange_rate_date =&gt; cast( &#x27;20240426&#x27; as abap.dats ), -- 汇率转换的日期 error_handling =&gt; &#x27;SET_TO_NULL&#x27; ) -- 异常信息设置 as convPrice, -- 将机票的金额转换为人民币 cast( &#x27;CNY&#x27; as abap.cuky ) as target_currency -- 转换的货币币种&#125; （4）运行结果 8.小数点移位函数（1）函数内容该函数会根据传入的货币金额还有货币的币种来处理货币的小数点位置，例如日元和韩元货币是没有小数点的，但是在航班表中金额却是带小数点的，这是因为在数据库表中韩元和日元被缩小了100倍，此时就可以使用小数点移位函数来处理这种货币。 12decimal_shift( amount =&gt; 转换用的货币金额 currency =&gt; 转换时的货币币种 ) （2）示例代码123456789define view YDECIMALSHIFT as select distinct from sflight&#123; key carrid, price, currency, decimal_shift( amount =&gt; price, currency =&gt; currency ) as dec_shft&#125; （3）运行结果 9.处理NULL函数（1）函数内容在CDS中关联其他视图或数据表对象时当关联不到数据时就会返回Null。而需要对返回Null的字段做初始值设置就可以使用函数COALESCE。 当field1字段为Null时，返回Value值。Value值可以是常量、变量或另一字段值。反之当field1字段不为Null时就返回field1字段值。 1coalesce（field1, value） （2）示例代码12345678910111213define view YTEMPLATE1_CDS as select from sflight left outer join spfli on spfli.carrid = sflight.carrid and spfli.connid = sflight.connid&#123; key sflight.carrid, key sflight.connid, key sflight.fldate, coalesce( spfli.countryfr, &#x27;CN&#x27; ) as countryfr, coalesce( spfli.countryto, sflight.planetype ) as countryto&#125; where sflight.carrid = &#x27;CC&#x27; （3）运行结果 10.Case … When … Then …（1）语法介绍该语法和ABAP新语法的用法其实一样，既可以使用Case 变量 When 变量值1 Then 返回值 …的形式，也可以使用Case When 表达式1 Then 返回值 …的形式。代表的都是类似于if语句的判断语法。 12345678910111213--方式一 变量+常量形式 CASE data1 WHEN value1 THEN return1 WHEN value2 THEN return2 ... ELSE returnn END --方式二 判断表达式 CASE WHEN expression1 THEN return1 WHEN expression2 THEN return2 ... ELSE returnn END （2）示例代码12345678910111213141516171819202122232425define view YCASEWHEN_CDS as select distinct from sflight as a&#123; key carrid, key connid, -- case when 语句简单形式 case carrid when &#x27;AA&#x27; then &#x27;American Airlines&#x27; when &#x27;AZ&#x27; then &#x27;Alitalia&#x27; when &#x27;DL&#x27; then &#x27;Delta Airlines&#x27; when &#x27;JL&#x27; then &#x27;Japan Airlines&#x27; when &#x27;LH&#x27; then &#x27;Lufthansa&#x27; when &#x27;QF&#x27; then &#x27;Qantas Airways&#x27; when &#x27;SQ&#x27; then &#x27;Singapore Airlines&#x27; when &#x27;UA&#x27; then &#x27;United Airlines&#x27; else &#x27;Scarr&#x27; end as carrname, --case when 语句复杂形式 case when carrid = &#x27;AA&#x27; and connid = &#x27;0017&#x27; then &#x27;US flights&#x27; when carrid = &#x27;AZ&#x27; and connid = &#x27;0555&#x27; then &#x27;European flights&#x27; when carrid = &#x27;JL&#x27; and connid = &#x27;0407&#x27; then &#x27;Japanese flights&#x27; else &#x27;Other flights&#x27; end as region&#125; （3）运行结果 11.Cast类型转换函数（1）语法介绍在CDS视图中进行强制类型转换的函数。可以将操作数转换为ABAP字典类型或数据元素。但是在添加时有如下注意事项。 数据元素：将操作数转换为数据元素时可以指定可选的PRESERVING TYPE。但如果使用了此方法，则内置数据类型、操作数长度和小数位以及目标数据类型必须完全匹配。 字典类型：ABAP中的基本数据类型，如果指定这种类型则无法使用可选的PRESERVING TYPE。 下图是用于指定内置数据类型的表格图片。 允许的操作数类型： 常量文本对象 当前的CDS视图字段 标准系统变量 带参数视图的参数 聚合表达式 一个路径表达式，用于标识数据源data_source的字段 内置函数 算数表达式 case的返回值&#x2F;case语句 嵌套的强制类型转换表达式 下表显示了ABAP字典中内置数据类型的哪些组合当前可以相互转换，以及每种情况下的要求。每个组合都有一个特殊的转换规则列表。 与”X”组合使用时无需注意其他限制。以下规则适用于其他组合： 与”Y”组合使用时，目标数据类型的长度必须足够 与”Z”组合使用时，数据类型长度必须完全匹配 在”P”或”D”组合情况下，必须将数据元素指定为目标数据类型。无法从ABAP字段中指定内置数据类型。 与”D”组合使用时，数据元素可以具有符合上表的合适目标类型和任何长度。 与”P”组合使用时，数据元素必须具有内置的数据类型，并且长度与操作数的数据类型相同。 在类型不兼容的情况下，操作数的内容将转换为目标类型（如果值不合适，则可能引发异常）。在兼容类型中，会出现语法检查警告（除非使用添加的PRESERVING type将目标数据类型指定为数据元素）。 （2）示例代码12345678define view YJOIN_TEST_CDS as select distinct from spfli&#123; key carrid, key connid, countryfr, cast( &#x27;123456&#x27; as abap.char( 20 ) ) as carrname&#125; （3）运行结果 六、CDS的注解开发下面的注解只是一小部分，我在总结的时候发现注解相关的内容太多了，所以要另开几篇笔记记录。到时候把链接贴在这个地方，下面写的这部分先作个参考吧。请注意下面的注解不是全部。 1.SAP ABAP CDS view里的注解在ABAP后台是如何被解析的SAP ABAP CDS view里的注解在ABAP后台是如何被解析的？ 2.ABAP 字典名称注解 AbapCatalog.sqlViewName（1）注解1@AbapCatalog.sqlViewName: ‘&lt;SQL VIEW NAME&gt;’ （2）描述ABAP字典中CDS数据库视图名称。最有多由16个字符组成的字符串。字符串由字母数字和下划线组成。可以简单理解成该CDS视图在ABAP中使用的名称。 CDS的视图每个定义都必须包含ABAP注解。 （3）示例12345678910111213@AbapCatalog.sqlViewName: &#x27;YSYSTEM_VAR_V&#x27;@AbapCatalog.compiler.compareFilter: true@AbapCatalog.preserveKey: true@AccessControl.authorizationCheck: #NOT_REQUIRED@EndUserText.label: &#x27;CDS视图的系统变量&#x27;define view YSYSTEM_VAR_CDS as select from mara as a left outer join makt as t on t.matnr = a.matnr&#123; key a.matnr, t.maktx&#125; where t.spras = $session.system_language 在SAP的数据字典中如下所示。在使用时需要使用的是在注解**@AbapCatalog.sqlViewName**中书写的名称。 如果直接使用CDS Entity的名称则会提示需要在相应的开发工具中查看视图。 3.CDS视图的过滤条件 AbapCatalog.compiler.compareFilter（1）注解1@AbapCatalog.compiler.compareFilter: ‘&lt;VALUE&gt;’ （2）描述定义CDS视图的路径表达式中过滤器条件的评估。 （3）可能的值 true：比较路径表达式中多次出现的CDS关联的过滤条件，如果它们匹配，则只创建一次相关联的联接表达式。 false：对于具有过滤条件的每个CDS关联，将创建并评估单独的联接表达式。 4.访问CDS的隐式访问控制 AccessControl.authorizationCheck（1）注解1@AccessControl.authorizationCheck: ‘&lt;VALUE&gt;’ （2）描述定义ABAP SQL用于访问CDS视图时的隐式访问控制。可简单理解成权限检查。 （3）可能的值 #CHECK：如果ABAP SQL用于访问视图，则在为视图分配CDS角色的情况下隐式执行访问控制。如果视图没有角色，则会出现语法检查警告。 #NOT_REQUIRED：类似#CHECK，但没有语法检查警告。 #NOT_ALLOWED：不执行访问控制。这会在视图的角色的DCL源代码中生成语法检查警告。 #PRIVILEGED_ONLY：Privileged CDS association (evaluated by SADL). 以下内容摘自：ABAP CDS注解详解 与 访问控制注释 ABAP CDS 支持基于数据控制语言 (DCL) 的访问控制。ABAP CDS 中的访问控制进一步限制了从 ABAP CDS 中的 CDS 实体返回的数据。CDS 访问控制基于以下几点： 使用 DCL 语句 DEFINE ROLE 定义的 CDS 角色。目前，CDS 角色隐式映射到每个用户。这就是为什么它们也被称为映射角色的原因。 在 CDS 角色 CDS 实体中定义的访问条件。访问条件可以如下： 将 CDS 实体的元素与文字值进行比较的文字条件。 将 CDS 实体的元素与 SAP 授权概念中的授权相关联的 PFCG 条件。 如果为 CDS 实体定义了 CDS 角色，则每次使用 Open SQL 或使用服务适配描述语言 (SADL) 查询访问对象时都会隐式评估访问条件（除非使用值 #NOT_ALLOWED 禁用访问控制）注解@AccessControl.authorizationCheck）。如果启用访问控制，则只读取满足访问条件的数据。 注：SADL（Service Adaptation Description Language）是一种ABAP技术，基于模型驱动的方式，可以在具有共同开发体验的各种场景下，实现类实体关系的ABAP数据模型的消费。因此，SADL 可以使用查询下推实现对基于 SAP HANA 的移动和桌面应用程序场景的数据的快速读取访问。 4.最终用户文本注解 EndUserText.label（1）注解1@EndUserText.label:’&lt;String&gt;’ （2）描述CDS 视图的可翻译短文本，用户看到的文本。可以简单理解成对该CDS视图的描述。 （3）可能的值最多 60 个字符的字符串。引入了ABAP 注释@EndUserText.label来定义 CDS 对象的可翻译语义文本。像这样的注释的值保存在具有语言键且可翻译的特殊表中。源代码中指定的值应由 CDS 源代码原始语言的文本组成，并被翻译成所需的语言。 （4）示例12345678910111213@AbapCatalog.sqlViewName: &#x27;YSYSTEM_VAR_V&#x27;@AbapCatalog.compiler.compareFilter: true@AbapCatalog.preserveKey: true@AccessControl.authorizationCheck: #NOT_REQUIRED@EndUserText.label: &#x27;CDS视图的系统变量&#x27;define view YSYSTEM_VAR_CDS as select from mara as a left outer join makt as t on t.matnr = a.matnr&#123; key a.matnr, t.maktx&#125; where t.spras = $session.system_language 在SAP中使用SE11查看YSYSTEM_VAR_V的信息。该界面是系统的英文界面 （5）文本翻译在这里介绍下如果翻译由@EndUserText.label注解和@EndUserText.quickinfo注解的文本内容。使用事务代码SE63，选择短文本 –&gt; A5用户界面文本 –&gt; DDLS 统一数据存储视图。 在对象名称处填写CDS Entity名称。注意是CDS实体对象名称而不是ABAP中CDS的名称。 之后点击编辑按钮，就会出现和以往翻译程序一样的翻译列表，在其中填写翻译的文本内容。点击保存按钮，最后到传输翻译文本的事务代码：SLXT。按照图中所提示的内容填写传输内容。 5.字段文本注解 EndUserText.quickinfo（1）注解1@EndUserText.quickinfo:’&lt;String&gt;’ （2）描述只能在字段上使用的文本注解，不限制长度。和上面的最终用户文本注解一样，可以在SE63中进行翻译。 （3）示例1234567891011121314151617181920212223@AbapCatalog.sqlViewName: &#x27;YANNOTATION_1_V&#x27;@AbapCatalog.compiler.compareFilter: false@AbapCatalog.preserveKey: true@AccessControl.authorizationCheck: #NOT_REQUIRED@EndUserText.label: &#x27;测试注解用CDS视图对象&#x27;define view YANNOTATION_1_CDS as select from sflight as a left outer join scarr as r on r.carrid = a.carrid left outer join spfli as s on s.carrid = a.carrid and s.connid = a.connid&#123; key r.carrid, key s.connid, key a.fldate, a.price, @EndUserText.quickInfo: &#x27;Currency Code&#x27; a.currency, @EndUserText.label: &#x27;HomePage&#x27; @EndUserText.quickInfo: &#x27;Scarr Url&#x27; r.url&#125; 七、参考资料CDS从入门到精通–2视图的类型 [SQL快速入门-38] SQL CROSS JOIN：交叉连接 SAP CDS View语法进阶（聚集、JOIN、UNION） SAP CDS View基础语法（创建你的第一个CDS View） CDS View-Part8&amp;Part9&amp;Part10&amp;Part16 内置函数 CDS相关资料整理(七) CDS视图中的字符串函数 Open SQL LPAD与 RPAD 函数（填充字符串） ABAP CDS - 字符串函数 ABAP CDS注解详解","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"CDS View","slug":"ABAP/CDS-View","permalink":"https://www.yemaojun.top/categories/ABAP/CDS-View/"},{"name":"CDS View","slug":"CDS-View","permalink":"https://www.yemaojun.top/categories/CDS-View/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP 程序调试","slug":"ABAP/ABAP基础/程序调试/SAP 程序调试方式/SAP-程序调试","date":"2024-01-12T06:10:07.000Z","updated":"2024-02-29T06:47:44.905Z","comments":true,"path":"2024/01/12/ABAP/ABAP基础/程序调试/SAP 程序调试方式/SAP-程序调试/","link":"","permalink":"https://www.yemaojun.top/2024/01/12/ABAP/ABAP%E5%9F%BA%E7%A1%80/%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95/SAP%20%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/SAP-%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95/","excerpt":"程序调试在开发过程中是十分常用的一项功能，掌握程序调试的各种方式与操作，对于开发人员和业务人员都是可以提升定位到问题和解决问题的效率的。所以本篇笔记在于简单介绍几种常用和好用的调试方式。","text":"程序调试在开发过程中是十分常用的一项功能，掌握程序调试的各种方式与操作，对于开发人员和业务人员都是可以提升定位到问题和解决问题的效率的。所以本篇笔记在于简单介绍几种常用和好用的调试方式。 SAP 程序调试 一、断点介绍1.断点类型SAP中的断点有四种类型，这几种断点的图标样式都是不一样的。分别是： 调试断点：这种断点指的是在程序调试过程中打的断点。是一种临时断点，程序调试结束后断点自动消失。 会话断点：这种断点有两种添加方式，第一种是在程序执行前添加的，另一种是添加调试断点后点击保存按钮由调试断点转换来的。在同一个登录状态下不同的窗口中都有效，随着账户的退出而消失。 外部断点：只能在程序执行前添加，与账户绑定。即便是账户退出后仍然有效。 静态断点：这个是通过代码BREAK-POINT设置的，只要程序执行到本段代码就会进去调试状态。取消的方法就是注释掉这段代码。 2.调试断点添加方式就是在调试界面的断点添加列处单击左键添加。之后就可以在本次调试中当作会话断点进行调试了。在本次调试结束之后设置的调试断点也就自动消失了，下次再进入调试界面时就不会再生效了。 3.会话断点（1）调试前添加在程序执行前，将光标放置于想要添加断点的行处，例如下图所示的第57行。当你熟练之后其实可以直接在对应的行前的断点添加列处点击左键来添加断点。 调试状态的会话短线如下所示。 （2）调试断点转换调试断点在上面介绍过，是在程序调试过程中添加的。但是存在一个问题就是这种断点会在程序调试结束后消失，但我现在希望它能在本次调试结束之后依然能在下次调试时继续进入到这个断点的位置就需要将其转化为会话断点。 而转化的方法其实就是在添加完成调试断点之后，再点击一下上面的保存按钮就可以将其转换为会话断点。在下次调试时依然会进入这个断点的位置。 4.外部断点（1）添加外部断点外部断点的添加方式和上面的会话断点添加方式类似。一样是现将光标放置于需要添加的断点的行处。然后点击外部断点按钮添加。 （2）设置断点生效账户外部断点和会话断点的一个区别就是会话断点是对自己的账号生效的，但是外部断点是可以设置为别人的账号生效的。常用于接口调试等情况。 下面介绍下如何设置外部断点与别人的账号进行绑定。先添加一个外部断点，然后再GUI窗口的最上层点击实用程序 —-&gt; 设置。 点击完上面的按钮之后会弹出下面的弹框，再弹框的页签中点击ABAP编辑器 —-&gt; 调试。再此处输入用户的账号，然后点击右下角的对勾按钮 当外部断点生效后的调试界面其实都是一样的。 5.静态断点此处的静态断点其实指的是使用代码编写的断点，因为只要执行到这行代码就会触发断点调试，不受其他因素的影响所以被称之为静态断点。 1BREAK-POINT. 二、程序调试运行方式1.程序调试运行方式分类上面介绍了进入调试状态的断点类型与添加方式。但是只是进入调试状态是不够的，还需要一步一步的执行程序看程序的执行流程是否按照自己预期的内容进行了执行。而执行的过程总共有四种执行类型。 单步执行 F5：一行代码一行代码的执行，不会跳过Form、Function和子程序等，会进入其中逐行执行其中的逻辑。 单行执行 F6：在当前页面逐行执行，不会进入Form、Function和子程序，会直接执行完他们的逻辑，但不会进入其中逐行执行他们的逻辑。 跳出本段子逻辑 F7：当你进入了一个Form、Function或子程序的子逻辑中，你想跳转到当前子逻辑执行完成的代码行处就是用该执行方式即可，他会帮你把当前的子逻辑全部执行完成，然后跳转到该子逻辑执行结束的行处。 执行到下一个断点处 F8：当你调试时设置了多个断点 ，而每两个断点间的逻辑你不关心或与你的调试无关想要直接运行到下一个断点时就是用该执行方式。它可以帮你从执行的当前行跳转到下一个断点处。 2.单步执行 F5（1）图标位置进入调试状态后有两种执行单步执行的方式。第一种是通过快捷键 F5单步执行；第二种是通过调试界面左上角的单步执行按钮进行调试。单步执行的调试按钮位置如下图所示，在整个调试界面的左上角。 （2）执行效果单步执行是不会跳过任何一个程序逻辑块的，可以理解成是程序自己执行的最真实的状态。像上图所示，当前调试已经执行到一个Form逻辑块处了，程序在执行时会找到当前Form逻辑块逻辑所在的位置然后一步一步的执行。而单步执行和程序执行一样，所以会进入到当前Perform的逻辑块中执行其中的逻辑。 3.单行执行 F6（1）图标位置和单步执行类似，这类执行方式基本都有两种。一种是通过界面按钮执行，一种是通过快捷键执行。单行的执行快捷键是F6，按钮在单步执行的后一个。 （2）执行效果单行执行指在当前程序调试界面逐行执行。不会进入子逻辑或Function中，而是会直接获取到他们执行完成的后的结果。 以下图的执行方式为例，我们执行到Function时，使用单行执行时他会直接运行完Function，拿到Function最后运行完成的结果。 4.跳出本段子逻辑 F7（1）图标位置在单行执行按钮的后一个执行图标就是F7 跳出本段子逻辑的调试执行按钮。 （2）执行效果当我们在调试时，进入到了一个逻辑十分复杂但是又与想调试的内容无太大关系的子逻辑或Function逻辑中时。我们想要快速执行完这段逻辑但又不想跳过本段子逻辑执行完后面的逻辑时就可以使用F7 跳出本段字段逻辑。 虽然叫做跳出本段子逻辑，单并不是指不执行本段子逻辑。而是执行完本段子逻辑剩余的逻辑后，停留在它的上层逻辑中。请参照下面的例子帮助理解。 下图为第404行的代码的子逻辑。在我们进入子逻辑之前可以看到返回值为0，但是在我们使用F7 跳出本段子逻辑返回子逻辑的上层逻辑时可以看到它的返回值为3。代表跳出本段子逻辑并不是直接跳过后续逻辑，而是执行完后续的逻辑，然后停留在子逻辑的上层调用逻辑处。 返回上层调用的逻辑处。 5.执行到下一个断点 F8（1）图标位置该执行方式的按钮是最后一个按钮。 （2）执行效果当我们想要执行到下一个断点或直接执行完程序退出调试模式就可以使用这个按钮功能。当你执行到最后一个断点时，再次使用该按钮后就会将程序全部执行完。但如果执行到当前位置后还有断点再次点击该按钮就会执行到后面的断点。 在执行时，使用该执行方式是会将中间的逻辑全部执行完成的，例如下图所示的在执行前三个变量的值均为初始值0。 在执行到下一个断点后，这三个变量又都有值了。说明程序是会执行中间的逻辑的。 三、进阶程序调试1.事务码进入调试状态 &#x2F;H（1）介绍当我们想要快速进入调试状态时，可以在输入事务码的输入框内容输入’&#x2F;h‘来进入调试状态。此方法十分常用也很便捷。 （2）操作步骤例如我想要进入断点逻辑按钮的调试状态，我可以在点击按钮之前先使用&#x2F;h然后按下回车键进入调试状态。 当激活调试状态后会在左下角弹框提示调试被激活的Message信息。 （3）执行效果当进行完上面的操作之后，点击我们想要调试的功能，例如断点逻辑按钮就会进入他的调试界面。 2.通过Message信息添加断点（1）介绍在日常的程序调试与标准程序使用过程中我们都会遇到Message提示信息。但是只看Message信息还是不清楚被卡控的原因，这时就需要通过程序调试到报出该Message信息的地方去通过代码查看报错原因。 此时就需要我们找到报出该Message信息的Message ID与Message Number来创建断点了。当添加完该断点后再次执行程序就会停留在报出该Message信息的地方了。 （2）操作步骤① 找到Message信息如下图所示，当我们点击断点逻辑功能按钮时，在程序最下方提示了Message信息。 双击左下角的Message信息会弹出技术弹框，在弹框中有Message的ID与Number信息。此时我们可以选择两种添加方式，此处先介绍一种不通过Message信息添加断点的方式。 在弹框最上面的有一个技术信息的按钮，点击该按钮查看该Message信息的技术信息。 点击技术信息按钮后可以查看到该Message信息的详细内容。 此时我们双击下面的行输入框，可以跳转到报出该Message信息的代码行。然后可以在这里添加一个会话断点。 ② 进入调试状态，添加断点除了上面的那种方式外，还可以使用下面的方式添加Message 断点。先使用&#x2F;h进入调试状态。 点击断点逻辑按钮，进入调试界面后点击新建断点的按钮，然后选择子页签为消息。 当断点设置成功后会在左下角显示Message：断点设置。此时我们再次点击执行到下一个断点（快捷键F8）按钮就可以运行到相应的Message处了。 （3）执行效果 3.创建监控点（1）介绍此处的创建监控点的运用场景是我想要测试当某一个变量的值为X时的场景，但是当前变量的值为X时还要执行很多次才行的场景。就可以使用这种断点添加方式。 用实际例子举例的话，就是循环。当我们在调试循环中的某一个变量在第300次循环时的情况时，我们就可以创建一个系统变量SY-TABIX &#x3D; 300的监控点。 （2）执行步骤① 添加监控点如下图所示，我现在执行到了一个20次循环的语句。现在我想要调试他在第15次循环时LV_INDEX的值。此时我们就可以点击图中红框圈起来的按钮创建变量SY-INDEX &#x3D; 15的监控点。 在下面的弹框中输入你要监控的变量名称与断点生效时变量的值。以本次的例子来讲，在弹框的最上面变量输入框中填入变量名称，下方的附加条件处填入断点生效时变量的值，当你不填值时每当这个变量的值产生变化时断点就会生效。最后点击右下角的对勾按钮添加监控点。 当你添加完成监控点之后，可以在调试界面的断点&#x2F;监控点页签中选择下方的监控点页签查看你本次调试添加的监控点信息，在此处你还可以对其进行编辑或删除等操作。 （3）执行效果进行完上面的操作之后，回到调试界面按下执行到下一个断点（快捷键F8）的按钮就可以直接执行到第15次循环时停下。下图是执行前的截图，可以看到当前执行到第419行而右侧的两个变量值都是0。 在我们按下执行到下一个断点的按钮后，可以看到程序在第420行停住了。而右侧的SY-INDEX变量值变为了15，左下角也提示了Message 已到达监控点（SY-INDEX）。此时就可以对你想要调试的内容进行调试了。 4.转到语句（1）介绍该功能是可以将程序执行移动到其他行然后开始执行，是一个十分实用的功能。当我们在调试时按键太快导致我们不小心执行过我们想要调试的逻辑处了，但重新调试执行又很麻烦。我们就可以使用转到语句功能直接跳转到想要调试的语句处，从新的位置开始执行。 但是有个注意事项。转到语句是跳转到某一行，并不是执行或回溯到某一行语句。在跳转时会保持跳转前各变量的值。所以在调试时如果你想要跳转到之前的语句的话需要考虑是否要变更部分变量的值到执行前的值。 （2）执行步骤我想要调试第402行到第408行的全部内容，但是我现在的执行位置是第419行。此时我想要重新回到第402行进行调试就可以先将光标置于第402行，然后使用快捷键Shift + F12或右键 —&gt; 转到语句。使程序重新跳转到第402行进行执行，此时请注意右侧的变量值是跳转前的变量值。 （3）执行效果跳转后可以在第402行前面看到一个黄颜色的箭头，他代表当前程序执行的行。右侧的变量值没有变化，说明这个功能不是程序的回溯，仅仅只是跳转。因为本次的调试逻辑即便回溯到402行也不会影响结果，所以就不需要再次变更此时再执行的变量值了。 5.执行到当前行（1）介绍此功能是可以在不添加断点的情况下，直接执行到光标所在的行。和添加断点后使用执行到下一个断点（快捷键F8）的效果相同，但是这种方式不需要添加断点，只需要使用快捷键Shift + F8即可。 （2）执行步骤如下图所示，我现在执行到了419行。但是我想要调试第430行的代码，如果我一行一行的执行过去的话，执行完20次循环十分耗费时间。此时我可以先将光标放置在第430行，此时可以先留意右侧变量LV_INDEX &#x3D; 0。 （3）执行效果然后使用快捷键Shift + F8直接让程序执行到第430行。此时可以观察到第430行前面有一个黄色的小箭头，代表程序现在停留在这一行。而此时的LV_INDEX变量值由0变为了20。说明程序是从第419行执行过来的，而不是跳转。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"ABAP基础","slug":"ABAP基础","permalink":"https://www.yemaojun.top/categories/ABAP%E5%9F%BA%E7%A1%80/"},{"name":"SAP程序调试","slug":"SAP程序调试","permalink":"https://www.yemaojun.top/categories/SAP%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP Rest接口传输文件","slug":"ABAP/Rest Interface/SAP-Rest接口传输文件/SAP-Rest接口传输文件","date":"2024-01-12T06:05:46.000Z","updated":"2024-04-10T04:24:03.646Z","comments":true,"path":"2024/01/12/ABAP/Rest Interface/SAP-Rest接口传输文件/SAP-Rest接口传输文件/","link":"","permalink":"https://www.yemaojun.top/2024/01/12/ABAP/Rest%20Interface/SAP-Rest%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/SAP-Rest%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/","excerpt":"之前项目上有需要使用接口传输文件的需求。项目上没有使用FTP，而是自己搭建了一个文件服务器。希望通过接口传输，研究了一下通过Rest传输和接收文件的方式。现在将其整理为笔记，方便未来使用。","text":"之前项目上有需要使用接口传输文件的需求。项目上没有使用FTP，而是自己搭建了一个文件服务器。希望通过接口传输，研究了一下通过Rest传输和接收文件的方式。现在将其整理为笔记，方便未来使用。 SAP Rest接口传输文件 一、需求分析1.文件推送接口（1）接收文件的接口地址： （2）接口的传输方式：POST （3）传输的文件类型：除压缩包外的大部分文件 （4）传输文件大小限制：传输的单个文件不允许超过25M（因为这个校验在对面系统卡控，所以本次没有在这个接口做卡控，但如果要限制可以通过上传时的Function获取FileSize的值做判断进行限制）。 （5）传输文件的数量：允许一次性传输多个文件 2.文件接收接口（1）接收文件的接口地址： （2）接口的传输方式：POST （3）传输的文件类型：若用户选择下载一个文件，则下载原文件。若用户一次性下载多个文件则返回压缩包。 （4）传输文件大小限制：传输的单个文件不允许超过25M。 （5）传输文件的数量：一次只传输一个文件，选择多个文件时将多个文件压缩为压缩包传输 3.需求注意事项（1）因为接口使用的地区不仅是国内，还涉及国外。所以在传输时需将当前系统的语言环境表示传递给文件系统 二、 文件推送接口1.Function 参数123456789101112131415*&quot;----------------------------------------------------------------------*&quot;*&quot;本地接口：*&quot; IMPORTING*&quot; VALUE(IV_FBILLNO) TYPE ZEL_FBILLNO 凭证编号*&quot; VALUE(IV_ORDERTYPE) TYPE ZEL_ORDERTYPE 凭证类型*&quot; VALUE(IV_BASENUMBER) TYPE T001W-WERKS 工厂编号*&quot; VALUE(IV_USERNAME) TYPE XUBNAME 上传用户账号*&quot; VALUE(IV_FFILEGROUPNUMBER) TYPE ZEL_FTYPE 传输时的请求内容*&quot; EXPORTING*&quot; VALUE(EV_CODE) TYPE SYSUBRC 接口调用的返回*&quot; VALUE(EV_MESSAGE) TYPE CHAR255*&quot; TABLES*&quot; IT_FILE TYPE YCAS002_T OPTIONAL*&quot; ET_FILESTATUS TYPE ZCAS008_T OPTIONAL*&quot;---------------------------------------------------------------------- （1）YCAS002 Row Field Name Position Key Data Element Domain Data Type Length Domain Text 1 FILENAME 1 CHAR255 CHAR 255 上传的文件名称 2 FILETYPE 2 CHAR20 CHAR 20 上传的文件类型 3 FILESIZE 3 INT4 10 上传的文件大小 4 FFILEGROUPNUMBER 4 CHAR40 CHAR 40 上传的文件类型编号 5 FILEDATA 5 RMPS_RSPOLPBI TABLE 上传的文件二元数据表类型 （2）ZCAS008 Row Field Name Position Key Data Element Domain Data Type Length Domain Text 1 FILENAME 1 CHAR255 CHAR 255 上传的文件名称 2 FILETYPE 2 CHAR20 CHAR 20 上传的文件类型 3 FILESIZE 3 INT4 10 上传的文件大小 4 STATUS 4 CHAR01 CHAR 1 上传的文件状态 5 MESSAGE 5 CHAR255 CHAR 255 返回的Message信息 2.变量声明12345678910111213141516171819202122CONSTANTS: LC_URL_IP TYPE STRING VALUE &#x27;http://********************************************&#x27;,&quot;正式环境接口IP与端口 LC_URL_TEST_IP TYPE STRING VALUE &#x27;http://********************************************&#x27;,&quot;测试环境接口IP与端口 LC_URL_SUFFIX TYPE STRING VALUE &#x27;*********************************&#x27;.&quot;接口后缀DATA: LV_URL TYPE STRING, &quot;最终发送的URL地址，由上面的IP与端口和IP后缀拼接而成 LV_RESPONSE TYPE STRING, &quot;用于接收接口返回值的Json字符串变量 LV_LANGUAGE TYPE STRING, &quot;用于设置文件上传时的系统语言 LV_FILENAME LIKE SAVWCTXT-FIELDCONT, &quot;用于存放将文件名转换为URL编码的变量 LO_HTTPCLIENT TYPE REF TO IF_HTTP_CLIENT, &quot;http客户端 LO_HTTPENTITY TYPE REF TO IF_HTTP_ENTITY, &quot;http实体 LV_XSTRING TYPE XSTRING, &quot;用来存放二进制流转换为XSTRING类型的文件内容的变量 LV_FILELEN TYPE I, &quot;文件大小 LV_USERNAME TYPE STRING, &quot;上传文件的SAP账号 LV_BASENUMBER TYPE STRING, &quot;工厂编号 LV_CONTENT_TYPE TYPE STRING, &quot;存放URL中传输文件类型的变量 LV_FFILEGROUPNUMBER TYPE STRING, &quot;传输时的请求内容 LV_CONTENT_DISPOSITION TYPE STRING. &quot;设置请求传输时的Content-Disposition属性DATA: LV_LEN TYPE I, &quot;获取内表长度与索引用的功能性变量 LT_SPLIT_NAME TYPE TABLE OF STRING, &quot;获取分割返回JSON消息后文件名称的内表（成功） LT_SPLIT_ERROR TYPE TABLE OF STRING. &quot;获取分割返回JSON消息后文件名称的内表（失败） 3.逻辑部分先上我这个需求开发的源码。但是如果只是传输文件的话，在最后面的对方的Json信息的处理有点太复杂了。所以后面的Json处理可以不用看，如果角色下面的逻辑还是有点看不懂，后面还有发送的步骤解析，可以看拆分后的解析内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244 &quot;非空校验，校验要上传的文件列表是否是空的 IF IT_FILE[] IS INITIAL. EV_MESSAGE = TEXT-E10. &quot;上传的文件列表为空 EXIT. ENDIF. &quot;判断客户端设置URL IF SY-MANDT EQ &#x27;800&#x27;. &quot;正式系统接口地址 LV_URL = LC_URL_IP &amp;&amp; LC_URL_SUFFIX. ELSEIF SY-MANDT EQ &#x27;400&#x27;. &quot;测试系统接口地址 LV_URL = LC_URL_TEST_IP &amp;&amp; LC_URL_SUFFIX. ENDIF. &quot;根据系统语言获取两位语言标识 SELECT SINGLE LAISO FROM T002 INTO LV_LANGUAGE WHERE SPRAS = SY-LANGU. LV_USERNAME = IV_USERNAME. &quot;对方系统接收的参数 LV_BASENUMBER = IV_BASENUMBER. &quot;对方系统接收的参数 LV_FFILEGROUPNUMBER = IV_FFILEGROUPNUMBER. &quot;对方系统接收的参数 &quot;将所有参数拼接在URL之后传递给文件服务器 LV_URL = LV_URL &amp;&amp; &#x27;fBillNo=&#x27; &amp;&amp; IV_FBILLNO &amp;&amp; &#x27;&amp;fOrderType=&#x27; &amp;&amp; IV_ORDERTYPE &amp;&amp; &#x27;&amp;fFileGroupNumber=&#x27; &amp;&amp; LV_FFILEGROUPNUMBER &amp;&amp; &#x27;&amp;fLangueCode=&#x27; &amp;&amp; LV_LANGUAGE. &quot;创建客户端请求 CALL METHOD CL_HTTP_CLIENT=&gt;CREATE_BY_URL EXPORTING URL = LV_URL &quot;最后的URL接口地址 IMPORTING CLIENT = LO_HTTPCLIENT &quot;自定义的Http请求对象 EXCEPTIONS ARGUMENT_NOT_FOUND = 1 PLUGIN_NOT_ACTIVE = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC NE 0. &quot;URL link failed MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF. &quot;设置请求方式POST LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_POST ). &quot;设置数据的传输格式 LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CONTENT_TYPE( CONTENT_TYPE = &#x27;multipart/form-data&#x27; ). &quot;设置头信息 LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_HEADER_FIELD( NAME = &#x27;BaseNumber&#x27; VALUE = LV_BASENUMBER ). LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_HEADER_FIELD( NAME = &#x27;UserName&#x27; VALUE = LV_USERNAME ). &quot;获取HTTP实体 LV_CONTENT_DISPOSITION = &#x27;form-data;name=&quot;files&quot;;filename=&quot;&#x27;. LOOP AT IT_FILE. &quot;上传的文件内表 LO_HTTPENTITY = LO_HTTPCLIENT-&gt;REQUEST-&gt;IF_HTTP_ENTITY~ADD_MULTIPART( ). LV_FILENAME = IT_FILE-FILENAME. &quot;utf-8编码文件名（目的是让上传后的文件名跟原来一样，不然会乱码） CALL FUNCTION &#x27;WWW_URLENCODE&#x27; EXPORTING VALUE = LV_FILENAME IMPORTING VALUE_ENCODED = LV_FILENAME. &quot;反向将URL中的字符转义为原文本 ：RSBB_WWW_URL_CODE I_MODE 置空 LV_CONTENT_DISPOSITION = LV_CONTENT_DISPOSITION &amp;&amp; LV_FILENAME &amp;&amp; &#x27;.&#x27; &amp;&amp; IT_FILE-FILETYPE &amp;&amp; &#x27;&quot;&#x27;. TRANSLATE IT_FILE-FILETYPE TO LOWER CASE. CASE IT_FILE-FILETYPE. WHEN &#x27;jpg&#x27; OR &#x27;png&#x27; OR &#x27;bmp&#x27;.* LV_CONTENT_TYPE = &#x27;image/jpeg&#x27;. LV_CONTENT_TYPE = &#x27;image/*&#x27;.* WHEN &#x27;png&#x27;.* LV_CONTENT_TYPE = &#x27;image/png&#x27;.* WHEN &#x27;bmp&#x27;.* LV_CONTENT_TYPE = &#x27;image/bmp&#x27;. WHEN &#x27;txt&#x27;. LV_CONTENT_TYPE = &#x27;text/plain&#x27;. WHEN &#x27;pdf&#x27;. LV_CONTENT_TYPE = &#x27;application/pdf&#x27;. WHEN &#x27;xlsx&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;. WHEN &#x27;xls&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.ms-excel&#x27;. WHEN &#x27;docx&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#x27;. WHEN &#x27;doc&#x27;. LV_CONTENT_TYPE = &#x27;application/msword&#x27;. WHEN &#x27;ppt&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.ms-powerpoint&#x27;. WHEN &#x27;pptx&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.openxmlformats-officedocument.presentationml.presentation&#x27;. WHEN OTHERS. &quot;不允许传输的文件类型 MESSAGE TEXT-E08 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDCASE. &quot;设置文件 CALL METHOD LO_HTTPENTITY-&gt;SET_HEADER_FIELD EXPORTING NAME = &#x27;Content-Disposition&#x27; VALUE = LV_CONTENT_DISPOSITION. IF LV_CONTENT_TYPE IS NOT INITIAL. &quot;设置文件类型 CALL METHOD LO_HTTPENTITY-&gt;SET_CONTENT_TYPE EXPORTING CONTENT_TYPE = LV_CONTENT_TYPE. ENDIF. &quot;将二进制流内表转换为XSTRING CALL FUNCTION &#x27;SCMS_BINARY_TO_XSTRING&#x27; EXPORTING INPUT_LENGTH = IT_FILE-FILESIZE* FIRST_LINE = 0* LAST_LINE = 0 IMPORTING BUFFER = LV_XSTRING TABLES BINARY_TAB = IT_FILE-FILEDATA[] EXCEPTIONS FAILED = 1 OTHERS = 2. LV_FILELEN = XSTRLEN( LV_XSTRING ). &quot;设置文件流 CALL METHOD LO_HTTPENTITY-&gt;SET_DATA EXPORTING DATA = LV_XSTRING OFFSET = 0 LENGTH = LV_FILELEN. LV_CONTENT_DISPOSITION = &#x27;form-data;name=&quot;files&quot;;filename=&quot;&#x27;. CLEAR: IT_FILE,LV_XSTRING,LV_FILELEN,LV_CONTENT_TYPE,LV_FILENAME. ENDLOOP. &quot;发送请求 CALL METHOD LO_HTTPCLIENT-&gt;SEND EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3 HTTP_INVALID_TIMEOUT = 4 OTHERS = 5. &quot;从下面的分割线开始就可以选择着看了，因为下面是处理接口调用状态的 &quot;此处有很多关于这个接口本身的自定义设置内容，所以不具有大的参考性，但仍可以看看使用的一些功能Function********************************************************************************************** IF SY-SUBRC NE 0. CALL METHOD LO_HTTPCLIENT-&gt;GET_LAST_ERROR IMPORTING CODE = EV_CODE MESSAGE = LV_MESSAGE. &quot;将Message转换为内表内容 CLEAR GS_ERROR. /UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_MESSAGE CHANGING DATA = GS_ERROR ). EV_MESSAGE = GS_ERROR-ERROR. ELSE. &quot;请求返回结果 CALL METHOD LO_HTTPCLIENT-&gt;RECEIVE EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3. &quot;请求返回的状态码 CALL METHOD lo_httpclient-&gt;response-&gt;get_status IMPORTING code = ev_code. &quot;获取接口返回的数据 LV_RESPONSE = LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_CDATA( ). &quot;将Message转换为内表内容 CLEAR GS_RETURNEAD. /UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_RESPONSE CHANGING DATA = GS_RETURNEAD ). &quot;返回消息处理 ------- 后面的逻辑不需要太过深的研究，因为这个是我这个需求对方系统返回的Json信息的处理。 LOOP AT GS_RETURNEAD-DATA INTO GS_RETURNITEM. ET_FILESTATUS-FILENAME = GS_RETURNITEM-SOURCEFILENAME. ET_FILESTATUS-FILESIZE = GS_RETURNITEM-FILESIZE. &quot;获取文件名称与类型 SPLIT GS_RETURNITEM-SOURCEFILENAME AT &#x27;.&#x27; INTO TABLE LT_SPLIT_NAME. LV_LEN = LINES( LT_SPLIT_NAME ). IF LV_LEN &gt; 0. READ TABLE LT_SPLIT_NAME INTO ET_FILESTATUS-FILETYPE INDEX LV_LEN. DELETE LT_SPLIT_NAME INDEX LV_LEN. &quot;去掉文件类型 IF SY-SUBRC EQ 0. CONCATENATE LINES OF LT_SPLIT_NAME INTO LV_FILENAME SEPARATED BY &#x27;.&#x27;. ENDIF. ENDIF. &quot;分割Message IF GS_RETURNITEM-ERROR IS NOT INITIAL. &quot;获取Message的内容 SPLIT GS_RETURNITEM-ERROR AT &#x27;.&#x27; INTO TABLE LT_SPLIT_ERROR. LV_LEN = LINES( LT_SPLIT_ERROR ). READ TABLE LT_SPLIT_ERROR INTO DATA(LS_SPLIT) INDEX LV_LEN. IF SY-SUBRC EQ 0. GS_RETURNITEM-ERROR = LV_FILENAME &amp;&amp; &#x27;.&#x27; &amp;&amp; LS_SPLIT. ENDIF. ENDIF. IF GS_RETURNITEM-SUCCESS EQ GC_X. ET_FILESTATUS-STATUS = &#x27;S&#x27;. ET_FILESTATUS-MESSAGE = TEXT-S02. &quot;文件上传成功 ELSE. ET_FILESTATUS-STATUS = &#x27;E&#x27;. ET_FILESTATUS-MESSAGE = GS_RETURNITEM-ERROR. ENDIF. APPEND ET_FILESTATUS. CLEAR: GS_RETURNITEM,ET_FILESTATUS,LV_LEN,LV_FILENAME. ENDLOOP. ENDIF. &quot;日志表的Message数据 IF LV_RESPONSE IS NOT INITIAL. EV_MESSAGE = LV_RESPONSE. ELSE. EV_MESSAGE = LV_MESSAGE. ENDIF. &quot;存入日志表 PERFORM FRM_SAVE_FILE_LOGTABLE TABLES ET_FILESTATUS[] &quot;文件上传状态内表 USING &#x27;C&#x27; &quot;操作类型 EV_CODE &quot;接口调用状态 EV_MESSAGE &quot;接口返回的Message IV_FBILLNO &quot;订单编号 IV_ORDERTYPE &quot;订单类型 IV_BASENUMBER &quot;工厂编号 IV_USERNAME. &quot;操作人员账号 &quot;关闭Http请求 CALL METHOD LO_HTTPCLIENT-&gt;CLOSE( ). 4.逻辑解析（1）声明需要使用的变量此处可以参照最上面的变量声明部分。通过注释已经说明了各变量的用途，此处就不再陈述了。 （2）设置对方接口的地址因为我们参照IF_HTTP_CLIENT声明的Http客户端对象LO_HTTPCLIENT在实例化时需要使用到对方系统的接口地址，所以我们需要先将对方系统的接口Url地址设置好。此处在设置的时候也可以将需要通过URL推送的参数也一并设置好。 （3）实例化Http客户端对象使用下面的语句实例化Http客户端对象。 123456789101112131415CALL METHOD CL_HTTP_CLIENT=&gt;CREATE_BY_URL EXPORTING URL = LV_URL &quot;最后的URL接口地址 IMPORTING CLIENT = LO_HTTPCLIENT &quot;自定义的Http请求对象 EXCEPTIONS ARGUMENT_NOT_FOUND = 1 PLUGIN_NOT_ACTIVE = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC NE 0. &quot;URL link failed MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. EXIT.ENDIF. （4）设置请求信息下面的数据传输格式是传输文件时的固定格式。当你只是普通的传输Json等内容时使用的数据传输格式是application&#x2F;json。 此处放置一个用于查询各种content-type的网址链接，后续可以去这里面查找自己要用的参数。 1234567&quot;设置请求方式POSTLO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_POST ).&quot;设置数据的传输格式LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CONTENT_TYPE( CONTENT_TYPE = &#x27;multipart/form-data&#x27; ).&quot;设置请求头信息（可选内容，如果需求有需要通过消息头传递的参数可以使用下面的语句设置头字段和值）LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_HEADER_FIELD( NAME = &#x27;BaseNumber&#x27; VALUE = LV_BASENUMBER ).LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_HEADER_FIELD( NAME = &#x27;UserName&#x27; VALUE = LV_USERNAME ). （5）获取Request Http实体对象此处获取的是Request对象的http实体对象，通过向其中添加属性与内容来设置发送给对方系统的信息。像我们设置发送用的JSON字符串也是添加到这个实体对象中的。 ① 获取Request Http实体对象1234DATA: LO_HTTPCLIENT TYPE REF TO IF_HTTP_CLIENT, &quot;http客户端 LO_HTTPENTITY TYPE REF TO IF_HTTP_ENTITY. &quot;http实体 LO_HTTPENTITY = LO_HTTPCLIENT-&gt;REQUEST-&gt;IF_HTTP_ENTITY~ADD_MULTIPART( ). ② 通过Http实体对象设置发送用的JSON字符串12345678910&quot;将JSON字符串封装进HTMLLO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CDATA( DATA = LV_SENDJSON LENGTH = STRLEN( LV_SENDJSON )).&quot;等效于下面LO_HTTPENTITY-&gt;SET_CDATA( DATA = LV_SENDJSON LENGTH = STRLEN( LV_SENDJSON )). （6）设置传输的文件① 设置文件名称在传输文件时，如果你的文件名存在非数字和字母的字符的话，则需要对其转换名称。不然对方系统接收到的文件名称可能是一堆乱码。 这里介绍两个Function，一个是将文件名转换为Url中的编码。另一个是将其转换回来的Function。 123456&quot;将文本转换为Url编码CALL FUNCTION &#x27;WWW_URLENCODE&#x27; EXPORTING VALUE = LV_FILENAME IMPORTING VALUE_ENCODED = LV_FILENAME. 接下来我们用上面导出的参数值使用Function RSBB_WWW_URL_CODE将其转换为文本。需要注意的是参数I_MODE 置空，该参数值默认E。 或者你可以使用这个Function使用的静态方法：cl_http_utility&#x3D;&gt;unescape_url来转换也可以。 ② 设置Content-Disposition该参数是用来设置传输文件时，文件的各种属性信息与文件内容的。想要深入了解的话可以查看这篇内容Content-Disposition。如果你有使用过Postman的话可以借助下图来理解该参数的作用。 123456LV_CONTENT_DISPOSITION = &#x27;form-data;name=&quot;files&quot;;filename=&quot;&#x27;.&quot;设置传输的文件名称CALL METHOD LO_HTTPENTITY-&gt;SET_HEADER_FIELD EXPORTING NAME = &#x27;Content-Disposition&#x27; VALUE = LV_CONTENT_DISPOSITION. ③ 设置传输的文件类型传输文件时你需要告诉对方系统对方要接受什么类型的文件，这时就需要设置文件类型。设置的类型可以参考content-type中的内容，在这片博客中有很完善的各种类型文件对应的content-type对照信息。 这里就是用上面代码中使用的类型来做个参考和演示，基本上常用的文件类型除压缩包外都在这了。 12345678910111213141516171819202122232425262728293031323334353637 TRANSLATE IT_FILE-FILETYPE TO LOWER CASE. CASE IT_FILE-FILETYPE. WHEN &#x27;jpg&#x27; OR &#x27;png&#x27; OR &#x27;bmp&#x27;.* LV_CONTENT_TYPE = &#x27;image/jpeg&#x27;. LV_CONTENT_TYPE = &#x27;image/*&#x27;.* WHEN &#x27;png&#x27;.* LV_CONTENT_TYPE = &#x27;image/png&#x27;.* WHEN &#x27;bmp&#x27;.* LV_CONTENT_TYPE = &#x27;image/bmp&#x27;. WHEN &#x27;txt&#x27;. LV_CONTENT_TYPE = &#x27;text/plain&#x27;. WHEN &#x27;pdf&#x27;. LV_CONTENT_TYPE = &#x27;application/pdf&#x27;. WHEN &#x27;xlsx&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;. WHEN &#x27;xls&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.ms-excel&#x27;. WHEN &#x27;docx&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#x27;. WHEN &#x27;doc&#x27;. LV_CONTENT_TYPE = &#x27;application/msword&#x27;. WHEN &#x27;ppt&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.ms-powerpoint&#x27;. WHEN &#x27;pptx&#x27;. LV_CONTENT_TYPE = &#x27;application/vnd.openxmlformats-officedocument.presentationml.presentation&#x27;. WHEN OTHERS. &quot;不允许传输的文件类型 MESSAGE TEXT-E08 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDCASE. &quot;设置文件类型 IF LV_CONTENT_TYPE IS NOT INITIAL. &quot;设置文件类型 CALL METHOD LO_HTTPENTITY-&gt;SET_CONTENT_TYPE EXPORTING CONTENT_TYPE = LV_CONTENT_TYPE. ENDIF. ④ 转换文件为XSTRING类型传输时需要将文件转换为XSTRING类型的串进行传输。此处介绍下下面的Function SCMS_BINARY_TO_XSTRING进行转换。此处的IT_FILE-FILEDATA[]类型建议使用SAP标准类型RMPS_RSPOLPBI。这样不容易出问题。 12345678910111213&quot;将二进制流内表转换为XSTRINGCALL FUNCTION &#x27;SCMS_BINARY_TO_XSTRING&#x27; EXPORTING INPUT_LENGTH = IT_FILE-FILESIZE* FIRST_LINE = 0* LAST_LINE = 0 IMPORTING BUFFER = LV_XSTRING TABLES BINARY_TAB = IT_FILE-FILEDATA[] EXCEPTIONS FAILED = 1 OTHERS = 2. RMPS_RSPOLPBI的结构类型如下所示，是由类型为Raw类型构成的单字段表类型。 在SCMS_BINARY_TO_XSTRING这个Function所在的函数组中有很多类似的转换Function在，如果后续需要使用转换什么类型时可以在这个包中查看是否有自己需要使用的Function在。 ⑤ 将转换的文件流放入http对象中我们在第二步设置Content-Disposition时设置了文件名称，相当于设置了键值对的key。而此时设置的文件二进制内容就是key所对应的Value。 当设置完Content-Disposition与CDATA的内容之后我们就会开始新一轮的Content-Disposition与CDATA内容的设置。这样就可以实现一次请求传输多个文件。 123456789&quot;获取文件流大小LV_FILELEN = XSTRLEN( LV_XSTRING ).&quot;设置文件流 CALL METHOD LO_HTTPENTITY-&gt;SET_DATA EXPORTING DATA = LV_XSTRING OFFSET = 0 LENGTH = LV_FILELEN. （7）发送请求设置好上面的文件传输内容之后，就可以调用Send方法发送请求了。这个过程和普通接口的调用过程就是一致的。 12345678&quot;发送请求 CALL METHOD LO_HTTPCLIENT-&gt;SEND EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3 HTTP_INVALID_TIMEOUT = 4 OTHERS = 5. （8）获取接口的调用状态发送完成之后，我们需要查看是否推送成功了。先使用Receive方法获取接口的返回信息。然后使用下面的代码判断我们是否成功调用了对方的接口，也就是查看对方的服务器或端口等信息是否无异常。但是有个注意事项是该方法只能用来判断是否调用成功，无法判断对方那边对我们推送的信息是否处理成功了。 12345678910&quot;请求返回结果CALL METHOD LO_HTTPCLIENT-&gt;RECEIVE EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3.&quot;请求返回的状态码 成功：200CALL METHOD lo_httpclient-&gt;response-&gt;get_status IMPORTING CODE = EV_CODE. （9）获取接口返回的JSON字符串如果对方系统有返回JSON串就可以使用GET_CDATA()方法拿到对面的JSON字符串。之后在将该JSON串转换为ABAP的内表结构进行处理。 12&quot;获取接口返回的数据LV_RESPONSE = LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_CDATA( ). （10）将JSON传转化为内表结构这里有个注意事项，那就是如果你要转换JSON串为内表或结构体的话，需要定义一个严格遵守JSON串结构的内表或结构体。即JSON中传递的是数组，那么你就应该定义为内表，若只有一个结构则应定义为结构体。而字段名也应和JSON中的字段名一致（不考虑大小写）。 1234567&quot;将Message转换为内表内容CLEAR GS_RETURNEAD./UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_RESPONSE CHANGING DATA = GS_RETURNEAD ). 使用这种方式转换的JSON串也可以接收复杂结构，即数组嵌套数组&#x2F;内表嵌套内表。例如下面的结构： 可以看到我们最终转换的是gs_returnead结构，这个结构里面的data字段是一个内表。这就是一个结构体嵌套内表的复杂结构。使用上面的Function可以将JSON字符串转换成上面的样式。 三、文件接收接口这个接口其实和普通的接口基本上就没什么太大的区别了，因为对方也是利用和上面类似的操作将我所需要的文件流返回回来我这边接收到之后调用GUI_DOWNLOAD Function下载的。 1.Function 参数1234567891011121314*&quot;----------------------------------------------------------------------*&quot;*&quot;本地接口：*&quot; IMPORTING*&quot; VALUE(IV_FBILLNO) TYPE ZEL_FBILLNO 凭证编号*&quot; VALUE(IV_FORDERTYPE) TYPE ZEL_ORDERTYPE 凭证类型*&quot; VALUE(IV_BASENUMBER) TYPE T001W-WERKS 工厂编号*&quot; VALUE(IV_USERNAME) TYPE XUBNAME 下载用户账号*&quot; EXPORTING*&quot; VALUE(EV_CODE) TYPE SYSUBRC 接口状态码*&quot; VALUE(EV_MESSAGE) TYPE CHAR255 接口Message*&quot; VALUE(EV_FILEBIN) TYPE XSTRING 下载的文件二进制流*&quot; TABLES*&quot; T_FILEDATA TYPE ZCAS005_T OPTIONAL 要下载的文件名称内表*&quot;---------------------------------------------------------------------- （1）ZCAS005 Row Field Name Position Key Data Element Domain Data Type Length Domain Text 1 FILENAME 1 CHAR255 CHAR 255 上传的文件名称 2 FILETYPE 2 CHAR20 CHAR 20 上传的文件类型 3 FILEPATH 3 CHAR255 CHAR 255 文件服务器中文件地址 2.变量声明12345678910111213141516CONSTANTS: LC_URL_IP TYPE STRING VALUE &#x27;http://********************************************&#x27;,&quot;正式环境接口IP与端口 LC_URL_TEST_IP TYPE STRING VALUE &#x27;http://********************************************&#x27;,&quot;测试环境接口IP与端口 LC_URL_SUFFIX TYPE STRING VALUE &#x27;*********************************&#x27;, &quot;接口后缀 LC_TRUE TYPE STRING VALUE &#x27;TRUE&#x27;, LC_FALSE TYPE STRING VALUE &#x27;FALSE&#x27;.DATA: LV_URL TYPE STRING, &quot;最终的接口URL地址 LV_RETURN TYPE STRING, &quot;接收接口返回JSON串的临时变量 LV_MESSAGE TYPE STRING, &quot;接收接口返回JSON串的临时变量 LV_FILETYPE TYPE STRING, &quot;要下载的文件类型 LV_FILENAME LIKE SAVWCTXT-FIELDCONT, &quot;要下载的文件名称 LV_JSONSEND TYPE STRING, &quot;存放发送用JSON串的变量 LV_BASENUMBER TYPE STRING. &quot;工厂字段DATA: LO_HTTPCLIENT TYPE REF TO IF_HTTP_CLIENT. &quot;http客户端对象 此处放一下参考报文和GS_JSONSEND的结构定义。 123456789101112131415161718192021222324252627282930313233343536373839*下载文件的示例报文参考*&#123;* &quot;fBillNo&quot;: &quot;1&quot;,* &quot;fFileName&quot;: [* &quot;入库效率占比.xlsx&quot;* ],* &quot;fFilePath&quot;: [* &quot;xlsx/202310/20231031-094151-cda8318b-a6de-45d1-9d5b-4636f70d321f.xlsx&quot;* ],* &quot;fileNameRule&quot;:1,//1为文件服务器实时名称，0为当前名称* &quot;fOrderType&quot;: &quot;1&quot;,* &quot;type&quot;: false,//true:压缩* &quot;fName&quot;: &quot;officia&quot;//下载的文件名称,如果Type的值卫false时需要传递*&#125;*当压缩多个文件进行下载时，文件名为 订单编号.zip&quot;下载文件发送的JSON结构DATA: BEGIN OF gs_jsonsend, fbillno TYPE string, fordertype TYPE string, type TYPE string, fname TYPE string, filenamerule TYPE string, ffilename TYPE TABLE OF string, ffilepath TYPE TABLE OF string, END OF gs_jsonsend.&quot;报错返回的JSON结构DATA: BEGIN OF gs_jsonres, success TYPE string, code TYPE string, msg TYPE string, isexception TYPE string, isnulldata TYPE string, error TYPE string, errorcode TYPE string, errortips TYPE string, data TYPE string, END OF gs_jsonres. 3.逻辑部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166 &quot;输入值校验 IF T_FILEDATA[] IS INITIAL. &quot;文件下载列表为空 MESSAGE TEXT-E12 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF. &quot;判断客户端设置URL IF SY-MANDT EQ &#x27;800&#x27;. &quot;正式系统接口地址 LV_URL = LC_URL_IP &amp;&amp; LC_URL_SUFFIX. ELSEIF SY-MANDT EQ &#x27;400&#x27;. &quot;测试系统接口地址 LV_URL = LC_URL_TEST_IP &amp;&amp; LC_URL_SUFFIX. ENDIF. LV_BASENUMBER = IV_BASENUMBER. &quot;接口传输用工厂字段值 &quot;创建客户端请求 CALL METHOD CL_HTTP_CLIENT=&gt;CREATE_BY_URL EXPORTING URL = LV_URL IMPORTING CLIENT = LO_HTTPCLIENT EXCEPTIONS ARGUMENT_NOT_FOUND = 1 PLUGIN_NOT_ACTIVE = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC NE 0. &quot;URL link failed MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF. &quot;设置请求方式POST LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_POST ). &quot;设置数据的传输格式 LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CONTENT_TYPE( CONTENT_TYPE = &#x27;application/json&#x27; ). &quot;设置头信息 LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_HEADER_FIELD( NAME = &#x27;BaseNumber&#x27; VALUE = LV_BASENUMBER ). &quot;设置发送JSON的结构值 - 简单理解成给JSON串的结构传值即可，传递的值都是对方系统要求的值 CLEAR: GS_JSONSEND. GS_JSONSEND-FBILLNO = IV_FBILLNO. &quot;订单编号 GS_JSONSEND-FORDERTYPE = IV_FORDERTYPE. &quot;订单类型 GS_JSONSEND-FILENAMERULE = &#x27;1&#x27;. &quot;1为文件服务器实时名称，0为当前名称 &quot;判断是否需要传递压缩文件 IF LINES( T_FILEDATA[] ) EQ 1. &quot;只有一个文件时，不需要压缩 GS_JSONSEND-TYPE = LC_FALSE. ELSE. &quot;存在两个及以上的文件时，压缩传输 GS_JSONSEND-TYPE = LC_TRUE. ENDIF. &quot;设置需要传输的文件内表 LOOP AT T_FILEDATA. &quot;转换文件名称 LV_FILENAME = T_FILEDATA-FILENAME. LV_FILETYPE = T_FILEDATA-FILETYPE. &quot;utf-8编码文件名（目的是让上传后的文件名跟原来一样，不然会乱码） CALL FUNCTION &#x27;WWW_URLENCODE&#x27; EXPORTING VALUE = LV_FILENAME IMPORTING VALUE_ENCODED = LV_FILENAME. LV_FILENAME = LV_FILENAME &amp;&amp; &#x27;.&#x27; &amp;&amp; LV_FILETYPE. APPEND LV_FILENAME TO GS_JSONSEND-FFILENAME. &quot;文件名称 APPEND T_FILEDATA-FILEPATH TO GS_JSONSEND-FFILEPATH. &quot;文件服务器路径 &quot;不压缩只下载一个文件时，文件名称为原名称 IF GS_JSONSEND-TYPE EQ LC_FALSE. GS_JSONSEND-FNAME = LV_FILENAME. ENDIF. CLEAR: T_FILEDATA. ENDLOOP. &quot;将结构转换为JSON字符串 LV_JSONSEND = /UI2/CL_JSON=&gt;SERIALIZE( EXPORTING DATA = GS_JSONSEND COMPRESS = ABAP_TRUE PRETTY_NAME = /UI2/CL_JSON=&gt;PRETTY_MODE-CAMEL_CASE &quot;JSON串的字段大小写设置（大小驼峰） ). &quot;将JSON字符串封装进HTML LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CDATA( DATA = LV_JSONSEND LENGTH = STRLEN( LV_JSONSEND ) ). &quot;发送请求 CALL METHOD LO_HTTPCLIENT-&gt;SEND EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3 HTTP_INVALID_TIMEOUT = 4 OTHERS = 5. &quot;从下面的分割线开始就可以选择着看了，因为下面是处理接口调用状态的 &quot;此处有很多关于这个接口本身的自定义设置内容，所以不具有大的参考性，但仍可以看看使用的一些功能Function********************************************************************************************** IF SY-SUBRC NE 0. CALL METHOD LO_HTTPCLIENT-&gt;GET_LAST_ERROR IMPORTING CODE = EV_CODE MESSAGE = LV_MESSAGE. &quot;将Message转换为内表内容 CLEAR GS_ERROR. /UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_MESSAGE CHANGING DATA = GS_JSONRES ). EV_MESSAGE = GS_JSONRES-ERROR. ELSE. &quot;请求返回结果 CALL METHOD LO_HTTPCLIENT-&gt;RECEIVE EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3. &quot;请求返回的状态码 CALL METHOD LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_STATUS IMPORTING CODE = EV_CODE. IF EV_CODE EQ &#x27;200&#x27;. &quot;将Message转换为内表内容 LV_RETURN = LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_DATA( ). &quot;将JSON串转为结构 /UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_RETURN CHANGING DATA = GS_JSONRES ). &quot;因为GS_JSONRES是用来接收失败时的JSON串内容的 &quot;与成功时的JSON串结构不一致，所以当收到的JSON串没法转换为异常结构时就说明返回的是二进制流文件 IF GS_JSONRES IS INITIAL. &quot;获取接口返回的文件二进制流 EV_FILEBIN = LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_DATA( ). ELSE. EV_CODE = GS_JSONRES-CODE+0(3). EV_MESSAGE = GS_JSONRES-ERROR. ENDIF. ENDIF. &quot;日志表的Message数据 EV_MESSAGE = LV_RETURN. &quot;存入日志表 PERFORM FRM_SAVE_FILE_LOGTABLE TABLES T_FILEDATA &quot;文件内表 USING &#x27;X&#x27; &quot;操作类型 EV_CODE &quot;接口调用状态 EV_MESSAGE &quot;接口返回的Message IV_FBILLNO &quot;订单编号 IV_FORDERTYPE &quot;订单类型 IV_BASENUMBER &quot;工厂编号 IV_USERNAME. &quot;操作人员账号 ENDIF. &quot;关闭Http请求 CALL METHOD LO_HTTPCLIENT-&gt;CLOSE( ). 4.逻辑解析前面的操作和步骤基本都是一样的。 （1）声明需要使用的变量此处可以参照最上面的变量声明部分。通过注释已经说明了各变量的用途，此处就不再陈述了。 （2）设置对方接口的地址因为我们参照IF_HTTP_CLIENT声明的Http客户端对象LO_HTTPCLIENT在实例化时需要使用到对方系统的接口地址，所以我们需要先将对方系统的接口Url地址设置好。此处在设置的时候也可以将需要通过URL推送的参数也一并设置好。 （3）实例化Http客户端对象123456789101112131415CALL METHOD CL_HTTP_CLIENT=&gt;CREATE_BY_URL EXPORTING URL = LV_URL &quot;最后的URL接口地址 IMPORTING CLIENT = LO_HTTPCLIENT &quot;自定义的Http请求对象 EXCEPTIONS ARGUMENT_NOT_FOUND = 1 PLUGIN_NOT_ACTIVE = 2 INTERNAL_ERROR = 3 OTHERS = 4.IF SY-SUBRC NE 0. &quot;URL link failed MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. EXIT.ENDIF. （4）设置请求信息123456&quot;设置请求方式POST LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_POST ). &quot;设置数据的传输格式 LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CONTENT_TYPE( CONTENT_TYPE = &#x27;application/json&#x27; ). &quot;设置头信息 LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_HEADER_FIELD( NAME = &#x27;BaseNumber&#x27; VALUE = LV_BASENUMBER ). （5）设置JSON串结构的值因为后面使用了结构转JSON的方式来设置JSON串，所以此处是给结构体赋值，之后再将结构体转换为JSON。 12345678910111213&quot;设置发送JSON的结构值 - 简单理解成给JSON串的结构传值即可，传递的值都是对方系统要求的值 CLEAR: GS_JSONSEND. GS_JSONSEND-FBILLNO = IV_FBILLNO. &quot;订单编号 GS_JSONSEND-FORDERTYPE = IV_FORDERTYPE. &quot;订单类型 GS_JSONSEND-FILENAMERULE = &#x27;1&#x27;. &quot;1为文件服务器实时名称，0为当前名称 &quot;判断是否需要传递压缩文件 IF LINES( T_FILEDATA[] ) EQ 1. &quot;只有一个文件时，不需要压缩 GS_JSONSEND-TYPE = LC_FALSE. ELSE. &quot;存在两个及以上的文件时，压缩传输 GS_JSONSEND-TYPE = LC_TRUE. ENDIF. 设置要下载的文件名封装到JSON串数组中。 12345678910111213141516171819202122&quot;设置需要传输的文件内表 LOOP AT T_FILEDATA. &quot;转换文件名称 LV_FILENAME = T_FILEDATA-FILENAME. LV_FILETYPE = T_FILEDATA-FILETYPE. &quot;utf-8编码文件名（目的是让上传后的文件名跟原来一样，不然会乱码） CALL FUNCTION &#x27;WWW_URLENCODE&#x27; EXPORTING VALUE = LV_FILENAME IMPORTING VALUE_ENCODED = LV_FILENAME. LV_FILENAME = LV_FILENAME &amp;&amp; &#x27;.&#x27; &amp;&amp; LV_FILETYPE. APPEND LV_FILENAME TO GS_JSONSEND-FFILENAME. &quot;文件名称 - JSON串中的文件名数组 APPEND T_FILEDATA-FILEPATH TO GS_JSONSEND-FFILEPATH. &quot;文件服务器路径 - 对方文件服务器中文件地址（可传空） &quot;不压缩只下载一个文件时，文件名称为原名称 IF GS_JSONSEND-TYPE EQ LC_FALSE. GS_JSONSEND-FNAME = LV_FILENAME. ENDIF. CLEAR: T_FILEDATA. ENDLOOP. （6）转换结构体为JSON并放入Http对象中① 将结构体转换为JSON串1234567&quot;将结构转换为JSON字符串 LV_JSONSEND = /UI2/CL_JSON=&gt;SERIALIZE( EXPORTING DATA = GS_JSONSEND COMPRESS = ABAP_TRUE PRETTY_NAME = /UI2/CL_JSON=&gt;PRETTY_MODE-CAMEL_CASE &quot;JSON串的字段大小写设置（大小驼峰） ). ② 封装JSON串到Http对象12345&quot;将JSON字符串封装进HTML LO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CDATA( DATA = LV_JSONSEND LENGTH = STRLEN( LV_JSONSEND ) ). （7）发送请求12345678&quot;发送请求 CALL METHOD LO_HTTPCLIENT-&gt;SEND EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3 HTTP_INVALID_TIMEOUT = 4 OTHERS = 5. （8）获取接口的调用状态12345678910&quot;请求返回结果 CALL METHOD LO_HTTPCLIENT-&gt;RECEIVE EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3. &quot;请求返回的状态码 CALL METHOD LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_STATUS IMPORTING CODE = EV_CODE. （9）获取接口返回的JSON串与文件流其实和普通的接口调用时一样的，只不过接收的对象类型是XSTRING类型的。 1234567891011121314151617181920IF EV_CODE EQ &#x27;200&#x27;. &quot;将Message转换为内表内容 LV_RETURN = LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_DATA( ). &quot;将JSON串转为结构 /UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_RETURN CHANGING DATA = GS_JSONRES ). &quot;因为GS_JSONRES是用来接收失败时的JSON串内容的 &quot;与成功时的JSON串结构不一致，所以当收到的JSON串没法转换为异常结构时就说明返回的是二进制流文件 IF GS_JSONRES IS INITIAL. &quot;获取接口返回的文件二进制流 EV_FILEBIN = LO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_DATA( ). ELSE. EV_CODE = GS_JSONRES-CODE+0(3). EV_MESSAGE = GS_JSONRES-ERROR. ENDIF.ENDIF. 以上就是通过Rest结构推送和接收文件的全过程了，整体其实和普通的接口没有太大的区别。只是部分参数设置的不太一样。如果有什么疑问或指正还请在评论区谈论，谢谢。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Rest接口","slug":"ABAP/Rest接口","permalink":"https://www.yemaojun.top/categories/ABAP/Rest%E6%8E%A5%E5%8F%A3/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"代理类形式的PO接口配置","slug":"ABAP/PO 接口/代理类形式的PO接口配置/代理类形式的PO接口配置","date":"2023-12-12T00:24:51.000Z","updated":"2024-01-12T05:39:49.716Z","comments":true,"path":"2023/12/12/ABAP/PO 接口/代理类形式的PO接口配置/代理类形式的PO接口配置/","link":"","permalink":"https://www.yemaojun.top/2023/12/12/ABAP/PO%20%E6%8E%A5%E5%8F%A3/%E4%BB%A3%E7%90%86%E7%B1%BB%E5%BD%A2%E5%BC%8F%E7%9A%84PO%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE/%E4%BB%A3%E7%90%86%E7%B1%BB%E5%BD%A2%E5%BC%8F%E7%9A%84PO%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE/","excerpt":"之前写了一篇使用RFC形式的配置PO接口的笔记，那一篇的配置比较简单，且在安全性方面不太可靠。所以这次介绍一下比较常用也相对灵活的代理类形式的配置方式。","text":"之前写了一篇使用RFC形式的配置PO接口的笔记，那一篇的配置比较简单，且在安全性方面不太可靠。所以这次介绍一下比较常用也相对灵活的代理类形式的配置方式。 代理类形式的PO接口配置 一、需求分析1.读取航班表SFLIGHT表中的数据信息外围系统需要通过航线代码CARRID、航班连接编号CONNID和航班日期FLDATE三个字段读取航班表中的信息。其中他们所对应的接口字段名称与外围系统所需要使用的字段结构如下所示： SAP对应的字段 类型 外围系统所对应的字段名 CARRID STRING RouteCode CONNID STRING FlightConnection FLDATE STRING FlightDate PRICE DEC(15,2) AirFreight CURRENCY STRING LocalCurrency PLANETYPE STRING AircraftType SEATSMAX STRING MaximumCapacity SEATSOCC STRING EconomyClassSeatsUsed PAYMENTSUM DEC(17,2) TotalNumberOfReservations SEATSMAX_B STRING MaximumCapacityOfBusinessClass SEATSOCC_B STRING BusinessClassSeatsUsed SEATSMAX_F STRING MaximumCapacityOfFirst SEATSOCC_F STRING FirstClassSeatsOccupied 根据上图的字段对应关系可以看出，外围系统的接口字段与SAP的接口字段并不一致，所以我们需要新建两套Data Type对象用于映射SAP系统字段与外围系统的字段。并且是根据三个主键进行的查询，所以约定成用于筛选的输入结构如下所示： 1234567891011121314151617181920&#123; &quot;RouteCode&quot;:[ &#123; &quot;LOW&quot;:&quot;&quot;, &quot;HIGH&quot;:&quot;&quot; &#125; ], &quot;FlightConnection&quot;:[ &#123; &quot;LOW&quot;:&quot;&quot;, &quot;HIGH&quot;:&quot;&quot; &#125; ], &quot;FlightDate&quot;:[ &#123; &quot;LOW&quot;:&quot;&quot;, &quot;HIGH&quot;:&quot;&quot; &#125; ]&#125; 二、新建PO接口 Enterprise Services Builder1.新建接口文件夹在命名空间或文件夹上右键，新建一个如下图所示的文件夹。 在新建好的界面上点击保存按钮，就可以在左侧的工具栏处看到新建的文件夹了。 2.新建输入参数的Data Type（1）新建Data Type对象填入用于区分的Data Type对象名称与描述，然后点击左下角的创建按钮新建一个Data Type对象。在这个地方可以根据自己的需求来，可以只创建一个Data Type对象然后SAP端的输入参数名称和这个名称保持一致即可。也可以专门再新建一个SAP端用的Data Type。然后一会通过Message Mapping进行映射即可。 为了方便理解，本篇笔记会新建两套Data Type用于讲解PO中数据方向对参数配置的影响。所以在这个地方我们新建两个用于输入参数的Data Type。 （2）填写Data Type输入参数结构由输入参数的JSON结构可以看出来，三个输入的字段结构都是数组形式的。所以在配置的时候我们需要将其放在一个结构中封装起来。然后在配置通道的时候设置数据类型为数组即可。 想要封装成一个结构，则需要在字段的Occurrence列设置字段属性的maxOccurs为unbounded。这样就代表该字段是一个结构，然后就可以插入子元素。用ABAP来说的话，被设置为unbounded的字段为结构体名称，然后插入该字段的子元素就是该结构体下的字段名。 ① 配置SAP端的输入参数字段结构 完整的输入参数结构如下，其余两个字段的配置方式都是一样的。 ② 配置外围系统端输入参数 完成的外围系统输入参数结构。 （3）填写Data Type输出参数结构根据SAP传出的结构参数与外围系统的接口字段参数关联起来。这些的配置方式都是和上面的内容一致的，所以此处就只展示最终配置好的参数结构就行。 同样的要先和上面新建Data Type一样，需要现新建两个Data Type对象。 ① 配置SAP端的输出参数字段结构 ② 配置外围系统端的输出参数字段结构 3.创建Message Type创建Message Type对象。这个对象就是用在接口数据传输过程中的对象，可以理解为信息的载体。用ABAP的开发来理解的话，Data Type是定义了一种数据类型，而Message Type对象则是参照数据类型定义的变量，要存储数据和内容自然是要使用变量也就是Message Type去存储。 此外有个不算规范的小技巧，在创建Message Type对象时我们可以将Message Type的后缀名称写成与Data Type一致的后缀名称，这样就可以很快的定位到Message Type所参照的类型。 新建完成Message Type对象后，我们就需要为该对象声明参照类型，也就是Data Type对象。当你的PO中有很多的Data Type对象，直接通过Data Type的名称引入时数据太多不利于查找。所以也可以考虑先填入Data Type所在的命名空间（Namespace）缩小查找范围。 新建完成之后点击最上方的保存按钮，就可以在最左侧的工具栏中看到新建的对象了。下图中工具栏中圈出来的Message Type对象就是SAP端与外围系统端所对应的全部Message Type对象。 （1）创建输入参数结构的Message Type① 外围系统端输入参数结构 ② SAP端输入参数结构 （2）创建输出参数结构的Message Type① 外围系统端输出参数结构 ② SAP端输出参数结构 4.创建字段映射对象Message Mapping来到了PO创建的一个小重点。Message Mapping对象是用来关联SAP端接口字段与外围系统端接口字段的。简单来说就是告诉PO中间件，我需要将这个结构的A字段的值传递到另一个接口的a字段中。这就是Message Mapping对象所作的事情。 介绍完Message Mapping的作用后接下来介绍如何创建和配置Message Mapping对象。先介绍创建对象。 （1）创建Message Mapping对象 点击左下角的创建按钮，进入下面的界面中。在该界面中左侧的空白区域需要填入数据来源Message对象，在右侧需要填入数据目标Message对象。 （2）Message Mapping映射方向Message Mapping的映射方向顺序不能反，不然后续在使用过程中会报错。简单来说就是根据接口的调用方向来判断数据的来源与去向。 如果是SAP推送数据到外围系统，那么在Request中映射的关系就是SAP是输入源，那么在左侧就需要填入SAP端的Message Type。而传输出去之后获取外围系统接口返回值的Response中映射关系是外围系统是输入源，在Response映射结构中左侧的输入源就应该是外围系统端的Message Type。 反过来如果是外围系统推送数据到SAP系统，那么在Request的映射结构中，外围系统段就是输入源，在左侧的映射关系中应该填入外围系统端的Message Type。反过来，在外围系统推送数据到SAP后，SAP需要返回信息给外围系统，这个时候在Response中SAP端就是输入源。 （3）配置Request Message Mapping本次的接口是外围系统调用SAP的接口（需要推送数据到SAP端）。所以按照上面的数据传导方向，在Request结构中外围系统是数据源，SAP端是目标数据。所以左侧引入外围系统的Message Type对象 MT_DEMO001_DEMO2ERP_REQ_OUT，右侧引入SAP端的Message Type对象MT_DEMO001_DEMO2ERP_REQ。 （4）映射Request Message Mapping字段进行完上面的操作之后会发现每个字段和结构前面有一个圆形的灯。此时是灰色的，代表没有与之映射的字段。选中左右两边的结构，点击映射按钮映射两个字段或结构。当两个结构下有同名的字段时，会自动映射字段名相同的字段。 当字段全部映射结束后，会发现有映射关系的字段前面的圆形灯会变成绿色。代表字段映射成功。 （5）配置Response Message Mapping与上面配置Request的映射关系一样，需要先分清楚数据的方向。本次的接口是外围系统调用SAP端的接口，所以在一开始传入数据时是外围系统端传入的，而此时响应外围系统的请求后需要回传SAP端的消息给外围系统。所以在Response的映射结构中数据源是SAP端，目标数据是外围系统端。 即左侧的Source Message是MT_DEMO001_DEMO2ERP_RES，右侧的Target Message是MT_DEMO001_DEMO2ERP_RES_OUT。 （6）映射Response Message Mapping和上面的操作类似，根据FS给出的字段对应关系一个字段一个字段的映射即可。最终映射完成之后见下图。 5.配置Service Interface（1）创建Service Interface对象上面创建了很多的对象，例如SAP端的Message Type对象MT_DEMO001_DEMO2ERP_REQ与MT_DEMO001_DEMO2ERP_RES。外围系统端的Message Type对象MT_DEMO001_DEMO2ERP_REQ_OUT与MT_DEMO001_DEMO2ERP_RES_OUT。我们可以根据命名规则知道他们两两一组是对应的Request与Response对象。 此时我们需要告诉系统，上方的Message Type对象哪两个是一组的对象。也就是将同一个数据端的Request对象与Response对象关联起来。这样在数据进入中间件时就会根据对应的接口来传递数据。简单来说就是PO系统哪两个Message Type是SAP端的，哪两个Message Type的外围系统端的。 在Service Interface中，除了可以关联Message Type对象，还可以设置接口对应的Request与Response对应的是那个对象。 （2）创建SAP端的Service Interface对象创建完Service Interface对象后，还需要配置方向。也就是Category属性，在图中用红框圈起来了。此处需要设置当前Service Interface是inbound还是outbound。此时可以遵循调用方是outbound，响应方是inbound。 在这个接口中，外围系统是调用方，SAP是响应方。所以在SAP端的Service Interface对象应该将Category属性设置为inbound。 （3）创建外围系统端的Service Interface对象同理，创建外围系统的Service Interface对象时，因为他是调用方，所以设置Category属性设置为outbound。 6.配置Operation Mapping（1）创建Operation Mapping对象此处设置的内容和上面的Message Mapping对象设置的内容类似，也是需要区分数据源和目标数据。简单理解成接口的调用方是数据源，而响应方是目标源即可。我们刚刚在上面设置了两个端的Service Interface对象。 接下来是新建Operation Mapping对象的操作。 （2）配置Operation Mapping对象按照上面说的内容，接口的调用方是数据源，而响应方是目标源。在外围系统调用SAP端接口时，外围系统是调用方（数据源），SAP端是响应方（目标源）。对Operation Mapping对象进行设置。 配置完数据源与目标数据后，点击下方的刷新按钮唤出下面消息的映射关系页签Request与Response。 因为我们在上面配置了数据源与目标数据的关系，所以下面会根据上面配置的Message Type自动带出来对应的对象，然后在中间填写他们两者之间的Mapping关系即可。 Response页签的Message Type映射关系。 7.激活全部对象配置完上面的所有对象之后，就可以激活创建的所有对象了。当然在创建中途你也可以激活未处于活动状态的对象。这里只是为了统一介绍功能所以才放在了一起介绍。在每个新建的对象未激活前，所创建的对象在左上角都会带一个红色的小勾。激活对象是没有这个图标的。例如在下面的第一张图中，下面的MM文件夹和SD文件夹都是激活状态，而其他的对象左上角都带有红色的小勾图标，代表未激活对象。 在未激活的对象上单击右键，点击Activate按钮。之后会弹出一个未激活对象的列表弹框。在其中勾选你要激活的对象，然后再点击弹框左下角的Activate按钮，激活选中的对象。 激活完成后，如果没有报错就会弹出下面的弹框。点击弹框的close按钮后，就可以看到刚刚未激活的对象左上角小勾图标消失了。 三、集成生成器 Integration Builder1.业务组件&#x2F;业务系统 Business Component&#x2F;System这两种对象简单来说就是业务系统（Business System）是具有真实地址的对象，而业务组件（Business Component）是虚拟的服务对象。在使用时是需要通过Communication Channel对象设置各项属性和访问用的URL地址的。但是业务系统在一开始配置PO时就配置好响应的属性了，所以在集成生成器中只需要Assign进来就可以了。在创建接口时因为会根据配置自动带出属性等信息，所以不需要像虚拟对象一样配置很多的属性了。 （1）配置业务系统 Business System在这里简单介绍一下配置业务系统（Business System）的地方和方法。在一开始配置好PO时，就可以在System Landscape Directory中设置业务系统了。 但是因为本片笔记主旨在于介绍配置代理类形式的PO接口，所以这里只简单介绍一下如何配置。 配置业务系统的地方如下图所示。点击下图红框选中的超链接进入System Landscape Directory界面。 在该界面需要先配置好技术系统，然后再去下面的业务系统中配置业务系统（Business System）对象。因为下面业务系统中的对象属性基本都是从上面导入的技术系统中映射过来的，所以需要先配置好上面的技术系统，然后再去配置业务系统。 在技术系统界面会看到目前已经配置好了四套系统，分别是PO的开发系统和测试系统以及SAP的开发D系统和测试Q系统。 在配置完成上面的技术系统之后就可以去刚刚看到的业务系统中根据导入的系统配置业务对象了。配置好的业务对象如下图所示。 新建业务对象的步骤如下图红框圈中的内容所示。 （2）配置业务组件 Business Component这个对象是虚拟对象，没有地址等属性信息，所以在使用时一般需要配置Communication Channel对象设置各项属性和访问用的URL地址。所以创建的时候比较简单，只需要在一个对象上单击右键New，选择Business Component即可。 2.配置 接口通信通道 Communication Channel对象这个可以简单理解为为业务组件或业务系统配置属性的对象，一个业务组件&#x2F;系统可以拥有多个不同的通信通道对象。而每一个通信通道对象都对应一个&#x2F;多个接口，所以才可以做到一个业务组件&#x2F;系统可以同时对接不同类型与不同地址的接口。 （1）新建对象在新建通信信道时需要在界面上填写通信组件（Communication Component）。这个一般填写都是虚拟的对象，也就是业务组件对象。我们本次使用自己配置的BC_DEMO_CYH对象。 （2）配置通信通道基础属性本页面重要的信息很多，第一个就是需要在最开始的位置设置适配器。也就是图中第一个红框圈起来的地方。在设置完这个地方之后才会出现下面的多个页签。 第二个需要注意是判断当前通信通道到底是发送方还是接收方。这个的判断是通过刚开始在创建通信通道时输入的业务组件对象，相对于他来说是发送方还是接收方。我们在创建时，导入的业务组件对象是外围系统方。他们是调用我们的接口，所以他们是请求的发送方。 第三个需要注意的是需要设置下方的Element Name和Element Namespace。这个地方需要传入的是Message Mapping对象Test页签中的东西。详细位置可以参考下一张图片。 第四个就是最下面的设置数据格式的地方，这里可以设置传入和传出JSON报文中的字段数据格式。例如传入的是数组（内表）或传出的是数组（内表）等信息，也可以在这里对某一字段设置默认初始值。本次配置的接口中数组形式的字段很多，所以配置了较多的内容。 Message Mapping对象Test页签。 （3）配置通信通道的接口地址后缀此处还可以灵活的设置动态参数从SAP端或外围系统端灵活的传入PO进行处理，这个后面有机会单独介绍。多适用于一个PO的通信访问多个其他接口。简单来说比如一个SAP端的接口需要将数据推送给不同外围系统的接口地址，就需要在这里动态的配置外围系统的接口地址。 本次接口不涉及这些内容所以只需要将SAP端接口后缀设置好之后就可以设置下一项请求方式的配置了。 （4）配置通信通道的请求方式因为是请求数据的接口，所以我们将他的请求方式设置未GET请求方式即可。 配置完上面的所有过程之后，通信通道对象的属性就全部设置完成了，这个时候激活就可以了。 3.配置代理类的通信通道这一步主要是对没有启用或尚未配置代理类访问服务用的。如果你的PO已经配置过SAP端的XI服务访问方式可以直接跳过这一步，到下面的集成配置。 （1）新建通信通道对象因为是400系统的XI通信通道对象，即配置的是400系统的服务。所以这里的业务组件是BS_DEV_400。 （2）选择通信通道适配器代理类的适配器是SOAP，但是需要变更Message Protocol（消息协议）为XI 3.0。完成之后选择通过URL地址方式配置服务地址。在最下面选择登录SAP的方式。目标URL地址获取方式在下一步介绍。 （3）获取目标URL Target URL这个目标URL是通过事务码 SICF进入SAP Service界面，点击运行按钮进入到Service列表中。 在列表中展开SAP页签，展开XI页签，最后在集成引擎（SAP XI消息格式）上单击右键选择测试服务。此时会有一个弹框也可能不会有，但是最后都会跳转到浏览器。此时浏览器的URL就是目标URL。 网页的目标地址。 4.配置 集成配置 integrated configuration 对象（1）配置业务组件的接口服务在新建集成配置对象前，需要先去参与交互的业务组件对象处将本次它参与的接口服务对象填充进去。本次我们使用的是BC_DEMO_CYH业务组件对象且他是发送方，所以我们需要在他的发送页签中将对应接口的Service Interface填充进去。 （2）新建集成配置对象在创建集成配置对象时，一样需要传入业务组件对象。这里传入的业务组件对象是固定的，是接口的调用方。如果调用方是SAP，则在这里传入SAP端的业务系统。如果调用方是外围系统则在这里传入外围系统的业务组件对象。 第二个interface输入框中则需要填入我们配置的接口所对应的Service Interface对象，这个对象需要在上面的操作中引入业务组件对象才可以在这里使用搜索帮助带出来。 （3）配置通信通道对象因为在开头配置过发送方的业务组件对象了，所以在这里只需要配置发送方的通信通道即可。在通信信道中有发送方的属性信息。 （4）配置接收方配置完发送方的属性信息之后就需要配置接收方对象了。在这里可以配置多个对象，既可以在这里配置400的接收方也可以配置500的接收方等。不过需要设置一下响应的条件，即告诉系统在什么情况下调用哪个系统的数据。这个判断条件是在第二列的Condition中进行设置的。 下面附带一张多系统响应的参考截图。 （5）配置接收方报文映射关系这里主要设置的是接收方对字段的映射关系。不同的接收方系统可以调用不同的映射关系。 （6）接收方输出设置此处的配置是根据接收方配置的属性去设置的，一般只要选好接收方，这个地方会自动带出来接收方的CC配置。我这里配置了两个访问方式，第一个是通过XI的代理类方式访问的通信通道，第二个是通过SAP 的RFC方式访问的通信通道。我们选择上面配置的代理类方式的通信通道。 （7）高级设置这里主要是配置一些日志相关的内容。配置完这些内容之后就可以激活创建的对象了。到这一步，PO端的配置就全部完成了。剩下的就是到SAP端激活和生成代理类，然后在其中编写接口的响应逻辑了。 四、SAP端接口响应逻辑1.激活PO生成代理类对象（1）查找对应的PO对象路径使用事务码 SPROXY进入SAP端PO配置界面。 （2）Generate对象在其中一个对象上右键点击Generate选项生成对象，此时会弹框需要你绑定生成的对象应该存放在什么包和事务码下。 （3）激活生成的对象生成完成的对象前面图标和原来生成之前的一样，只有在生成之后激活对象后，该对象才算是在SAP中可以使用的对象。对象前的蜕变也会变成一个右下角带绿色方框的图标。 在生成对象时可以直接根据自己的接口需求进行生成即可。在图中可以看到一个PO对象有两个Service。一个是消费者，一个是供应商。这两个带入到调用方与响应方中就是接口调用方是消费者，接口响应方是供应商。在本次配置的接口中，因为是外围系统调用SAP端的接口。所以SAP端是供应商，外围系统端是消费者。 这样一来我们就只需要生成一下供应商服务，编写他的响应逻辑即可。操作的方式和上面的一致，先生成Service Providers，然后在激活生成的代理类型对象即可。 （4）查看代理类实例化方法在生成的服务上，双击实现类对象，查看接口响应的实例化方法。 （5）接口响应逻辑因为是查询航班表的逻辑，所以这里根据传入的筛选条件编写查询逻辑并将返回的数据封装到对应的参数结构中即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495METHOD ZII_SI_DEMO001_DEMO2ERP_SYNC_S~SI_DEMO001_DEMO2ERP_SYNC_SAP.*--------------------------Variables-----------------------------------* CONSTANTS: LC_I TYPE C LENGTH 1 VALUE &#x27;I&#x27;, LC_EQ TYPE C LENGTH 2 VALUE &#x27;EQ&#x27;, LC_BT TYPE C LENGTH 2 VALUE &#x27;BT&#x27;. &quot;PO设置的参数结构 DATA: LS_INPUT TYPE ZMT_DEMO001_DEMO2ERP_REQ, LS_OUTPUT TYPE ZMT_DEMO001_DEMO2ERP_RES. &quot;PO中参与逻辑处理的参数 DATA: LS_CARRID TYPE ZDT_DEMO001_DEMO2ERP_REQ_CARRI,&quot;输入筛选参数结构体 LS_CONNID TYPE ZDT_DEMO001_DEMO2ERP_REQ_CONNI,&quot;输入筛选参数结构体 LS_FLDATE TYPE ZDT_DEMO001_DEMO2ERP_REQ_FLDAT,&quot;输入筛选参数结构体 LT_CARRID TYPE ZDT_DEMO001_DEMO2ERP_REQ__TAB1,&quot;输入筛选参数内表 LT_CONNID TYPE ZDT_DEMO001_DEMO2ERP_REQ_C_TAB,&quot;输入筛选参数内表 LT_FLDATE TYPE ZDT_DEMO001_DEMO2ERP_REQ_F_TAB,&quot;输入筛选参数内表 LT_TABLE TYPE ZDT_DEMO001_DEMO2ERP_RES_E_TAB.&quot;返回参数内表 &quot;SAP端参数 DATA: LR_CARRID TYPE RANGE OF SFLIGHT-CARRID, LR_CONNID TYPE RANGE OF SFLIGHT-CONNID, LR_FLDATE TYPE RANGE OF SFLIGHT-FLDATE, LS_CARRID_R LIKE LINE OF LR_CARRID, LS_CONNID_R LIKE LINE OF LR_CONNID, LS_FLDATE_R LIKE LINE OF LR_FLDATE.*----------------------------Logic-------------------------------------* &quot;参数传入 LS_INPUT = INPUT. &quot;将传入参数传入内表中 MOVE-CORRESPONDING: LS_INPUT-MT_DEMO001_DEMO2ERP_REQ-CARRID TO LT_CARRID, LS_INPUT-MT_DEMO001_DEMO2ERP_REQ-CONNID TO LT_CONNID, LS_INPUT-MT_DEMO001_DEMO2ERP_REQ-FLDATE TO LT_FLDATE. &quot;将传入的筛选条件填入Range表 MOVE-CORRESPONDING: LT_CARRID TO LR_CARRID, LT_CONNID TO LR_CONNID, LT_FLDATE TO LR_FLDATE. &quot;补全Range表 SELECT @LC_I AS SIGN, CASE WHEN R~LOW IS NOT INITIAL AND R~HIGH IS INITIAL THEN @LC_EQ WHEN R~LOW IS NOT INITIAL AND R~HIGH IS NOT INITIAL THEN @LC_BT END AS OPTION, R~LOW, R~HIGH FROM @LR_CARRID AS R INTO CORRESPONDING FIELDS OF TABLE @LR_CARRID. SELECT @LC_I AS SIGN, CASE WHEN R~LOW IS NOT INITIAL AND R~HIGH IS INITIAL THEN @LC_EQ WHEN R~LOW IS NOT INITIAL AND R~HIGH IS NOT INITIAL THEN @LC_BT END AS OPTION, R~LOW, R~HIGH FROM @LR_CONNID AS R INTO CORRESPONDING FIELDS OF TABLE @LR_CONNID. SELECT @LC_I AS SIGN, CASE WHEN R~LOW IS NOT INITIAL AND R~HIGH IS INITIAL THEN @LC_EQ WHEN R~LOW IS NOT INITIAL AND R~HIGH IS NOT INITIAL THEN @LC_BT END AS OPTION, R~LOW, R~HIGH FROM @LR_FLDATE AS R INTO CORRESPONDING FIELDS OF TABLE @LR_FLDATE. &quot;根据Range表查询数据 SELECT CARRID, CONNID, FLDATE, PRICE, CURRENCY, PLANETYPE, SEATSMAX, SEATSOCC, PAYMENTSUM, SEATSMAX_B, SEATSOCC_B, SEATSMAX_F, SEATSOCC_F FROM SFLIGHT WHERE CARRID IN @LR_CARRID AND CONNID IN @LR_CONNID AND FLDATE IN @LR_FLDATE INTO TABLE @DATA(LT_SFLIGHT). MOVE-CORRESPONDING LT_SFLIGHT TO LT_TABLE. &quot;设置返回值 OUTPUT-MT_DEMO001_DEMO2ERP_RES-ET_TABLE = LT_TABLE.ENDMETHOD. 五、测试接口1.Postman测试接口打开Postman输入接口地址，然后在权限处选择Basic类型的权限，然后此处填入的是PO的登录账号。 2.传输筛选JSON编写筛选的JSON字符串，发送到接口查看取数是否正确。接口联通成功。 六、其他内容1.配置PO目标上面在配置PO时介绍了配置SAP端的代理类通信通道。那是其中一种配置的方式，如果只有个别接口需要使用代理类方式的话，可以使用那种方式配置。但是如果存在多个系统需要不断切换数据源时，或有特殊的需求比如需要PO端登录SAP的账号不同时，就比较麻烦了。所以这里再介绍一种通过目标来设置访问服务器的方式。 （1）目标链接位置 （2）目标页签位置 （3）创建目标对象点击上面的创建按钮，在下面先填写代理类的XI的Target URL（这个内容详见三、集成生成器 Integration Builder下的第三小项）。然后再配置下系统表示等字段内容，就可以继续配置登陆数据。 在登录数据页签中输入登录SAP的账号信息。之后点击保存按钮就可以将目标对象保存都PO的配置系统中，在后续的使用过程中可以直接引用该对象即可。 （4）引用目标对象这样的效果和上面的配置代理类通信通道的效果是一样的。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"代理类 PO接口","slug":"ABAP/代理类-PO接口","permalink":"https://www.yemaojun.top/categories/ABAP/%E4%BB%A3%E7%90%86%E7%B1%BB-PO%E6%8E%A5%E5%8F%A3/"},{"name":"PO接口","slug":"PO接口","permalink":"https://www.yemaojun.top/categories/PO%E6%8E%A5%E5%8F%A3/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP-GUI中显示PDF文件或网页","slug":"ABAP/SAP GUI中显示PDF文件/SAP-GUI中显示PDF文件或网页","date":"2023-11-23T03:24:10.000Z","updated":"2023-12-08T07:28:47.815Z","comments":true,"path":"2023/11/23/ABAP/SAP GUI中显示PDF文件/SAP-GUI中显示PDF文件或网页/","link":"","permalink":"https://www.yemaojun.top/2023/11/23/ABAP/SAP%20GUI%E4%B8%AD%E6%98%BE%E7%A4%BAPDF%E6%96%87%E4%BB%B6/SAP-GUI%E4%B8%AD%E6%98%BE%E7%A4%BAPDF%E6%96%87%E4%BB%B6%E6%88%96%E7%BD%91%E9%A1%B5/","excerpt":"这段时间碰到了一个需求。用户上传了很多的文件希望在SAP GUI中预览其中的PDF内容。然后在网上查阅了一些资料，发现了SAP中CL_GUI_HTML_VIEWER类的实例方法 LOAD_DATA。该类是一个HTML控件类，和OOALV中的ALV GRID控件类似，需要绑定容器使用。简单的理解就是在容器中展示一个网页或HTML元素，然后在这个网页中展示PDF文件。","text":"这段时间碰到了一个需求。用户上传了很多的文件希望在SAP GUI中预览其中的PDF内容。然后在网上查阅了一些资料，发现了SAP中CL_GUI_HTML_VIEWER类的实例方法 LOAD_DATA。该类是一个HTML控件类，和OOALV中的ALV GRID控件类似，需要绑定容器使用。简单的理解就是在容器中展示一个网页或HTML元素，然后在这个网页中展示PDF文件。 SAP-GUI中显示PDF文件或网页 一、展示PDF文件1.效果图展示 2.实现过程（1）定义容器与组件对象123DATA: GO_HTML_CONTROL TYPE REF TO CL_GUI_HTML_VIEWER, &quot;组件对象 GO_CONTAINER TYPE REF TO CL_GUI_DOCKING_CONTAINER. &quot;容器对象 （2）获取文件的二进制流实现PDF文件展示在SAP GUI中的思路是先将文件转换为二进制的形式，然后再通过网页展示文件内容。所以这里主要的工作是将文件转换为二进制，这样的方式有很多。你可以通过文件服务器直接将文件的二进制数据放在内表中，也可以使用SAP标准函数GUI_UPLOAD将本地文件转换为二进制形式。 本篇笔记采用第二种使用GUI_UPLOAD的方式获取本地文件的二进制流数据。 ① 获取文件路径——选择屏幕12PARAMETERS: P_FPATH TYPE RLGRAP-FILENAME MODIF ID FP. &quot;文件上传路径 ② 获取文件路径——搜索帮助12345678910AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_FPATH. PERFORM SEARCH_HELP_FILEPATH CHANGING P_FPATH. FORM SEARCH_HELP_FILEPATH CHANGING VALUE(PV_FILEPATH) TYPE RLGRAP-FILENAME. CALL FUNCTION &#x27;F4_FILENAME&#x27; EXPORTING FIELD_NAME = &#x27;C:\\&#x27; IMPORTING FILE_NAME = PV_FILEPATH.ENDFORM. ③ 获取文件的二进制流数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253FORM GET_FILE_DATA .*--------------------------Variables-----------------------------------* DATA: LV_FILEPATH TYPE STRING.*----------------------------Logic-------------------------------------* CHECK P_DDATA IS NOT INITIAL.&quot;选择屏幕的单选按钮，用来代表选中时程序用于展示PDF REFRESH: GT_BINTAB. &quot;文件的路径 LV_FILEPATH = P_FPATH. &quot;上传文件为二进制流数据 CALL FUNCTION &#x27;GUI_UPLOAD&#x27; EXPORTING FILENAME = LV_FILEPATH FILETYPE = &#x27;BIN&#x27;* HAS_FIELD_SEPARATOR = &#x27;&#x27;* HEADER_LENGTH = 0* READ_BY_LINE = &#x27;X&#x27;* DAT_MODE = &#x27; &#x27;* CODEPAGE = LV_CODEPAGE* IGNORE_CERR = ABAP_TRUE* REPLACEMENT = &#x27;#&#x27;* CHECK_BOM = &#x27; &#x27;* VIRUS_SCAN_PROFILE = NO_AUTH_CHECK = &#x27;X&#x27;* IMPORTING* FILELENGTH =* HEADER = TABLES DATA_TAB = GT_BINTAB &quot;内表类型为 TYPE W3MIMETABTYPE* CHANGING* ISSCANPERFORMED = &#x27; &#x27; EXCEPTIONS FILE_OPEN_ERROR = 1 FILE_READ_ERROR = 2 NO_BATCH = 3 GUI_REFUSE_FILETRANSFER = 4 INVALID_TYPE = 5 NO_AUTHORITY = 6 UNKNOWN_ERROR = 7 BAD_DATA_FORMAT = 8 HEADER_NOT_ALLOWED = 9 SEPARATOR_NOT_ALLOWED = 10 HEADER_TOO_LONG = 11 UNKNOWN_DP_ERROR = 12 ACCESS_DENIED = 13 DP_OUT_OF_MEMORY = 14 DISK_FULL = 15 DP_TIMEOUT = 16 OTHERS = 17. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.ENDFORM. （3）实例化容器与组件对象12345678910111213141516FORM CREATE_CONTAINER_ASSEMBLY . &quot;实例化容器对象 IF GO_CONTAINER IS INITIAL. CREATE OBJECT GO_CONTAINER EXPORTING REPID = SY-REPID DYNNR = SY-DYNGR SIDE = CL_GUI_DOCKING_CONTAINER=&gt;DOCK_AT_LEFT EXTENSION = 2000. ENDIF. &quot;实例化组件对象 CREATE OBJECT GO_HTML_CONTROL EXPORTING PARENT = GO_CONTAINER.ENDFORM. （4）将文件的二进制内容转为网页并展示12345678910111213141516171819202122232425262728FORM SET_ASSEMBLY_DATA .*--------------------------Variables-----------------------------------* DATA: LV_URL TYPE C LENGTH 200.*----------------------------Logic-------------------------------------* IF P_DDATA IS NOT INITIAL. &quot;转换PDF文件 CALL METHOD GO_HTML_CONTROL-&gt;LOAD_DATA( EXPORTING TYPE = &#x27;application&#x27; SUBTYPE = &#x27;PDF&#x27; IMPORTING ASSIGNED_URL = LV_URL CHANGING DATA_TABLE = GT_BINTAB EXCEPTIONS DP_INVALID_PARAMETER = 1 DP_ERROR_GENERAL = 2 CNTL_ERROR = 3 OTHERS = 4 ). ELSE. LV_URL = P_WWURL. ENDIF. &quot;展示组件内容 CALL METHOD GO_HTML_CONTROL-&gt;SHOW_URL( URL = LV_URL IN_PLACE = &#x27;X&#x27; ).ENDFORM. 二、展示网页内容该组件的本质还是一个网页组件，所以对于网页能做的事情，他基本都可以做。简单来说，其实就是你在SAP的GUI中插入了一个网页而已。所以无论是你自己手写的HTML代码还是说网址都是可以展示的。 下面就是展示必应官网的过程，实现的逻辑其实比展示PDF还要简单的多。 1.效果图 2.实现步骤因为这个的实现逻辑在上面的代码中已经存在了，所以就不再贴代码了。只文字说明下实现的步骤即可。后面会将整个程序的源码贴出来。 创建容器与组件对象 实例化组件与容器对象 调用SHOW_URL Function URL参数传递网页地址，例如必应的官网：HTTP:&#x2F;&#x2F;WWW.BING.COM&#x2F;?MKT&#x3D;ZH-CN 三、程序源码与截图1.主程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546REPORT YDISPLAY_PDF.*----------------------------------------------------------------------** Include*----------------------------------------------------------------------*INCLUDE YDISPLAY_PDF_TOP.INCLUDE YDISPLAY_PDF_SCR.*INCLUDE YDISPLAY_PDF_CLA.INCLUDE YDISPLAY_PDF_PBO.INCLUDE YDISPLAY_PDF_PAI.INCLUDE YDISPLAY_PDF_F01.*----------------------------------------------------------------------** INITIALIZATION*----------------------------------------------------------------------*INITIALIZATION.*----------------------------------------------------------------------** AT SELECTION-SCREEN OUTPUT*----------------------------------------------------------------------*AT SELECTION-SCREEN OUTPUT. &quot;展示和隐藏选择屏幕的输入框 PERFORM SELECT_SCREEN_DISPLAY.*----------------------------------------------------------------------** AT SELECTION-SCREEN*----------------------------------------------------------------------*AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_FPATH. &quot;上传文件地址搜索帮助 PERFORM SEARCH_HELP_FILEPATH CHANGING P_FPATH.*----------------------------------------------------------------------** START-OF-SELECTION*----------------------------------------------------------------------*START-OF-SELECTION. &quot;将文件转换为二进制流 PERFORM GET_FILE_DATA.*----------------------------------------------------------------------** END-OF-SELECTION*----------------------------------------------------------------------*END-OF-SELECTION. IF SY-BATCH IS INITIAL. &quot;展示网页组件的屏幕 CALL SCREEN 0100. ENDIF. 2.全局变量定义 TOP12345678910111213141516171819202122232425262728293031323334353637383940414243*&amp;---------------------------------------------------------------------**&amp; Include YDISPLAY_PDF_TOP*&amp;---------------------------------------------------------------------**----------------------------------------------------------------------** Constants*----------------------------------------------------------------------*CONSTANTS: GC_X TYPE C LENGTH 1 VALUE &#x27;X&#x27;, GC_S TYPE C LENGTH 1 VALUE &#x27;S&#x27;, GC_E TYPE C LENGTH 1 VALUE &#x27;E&#x27;, GC_NULL TYPE C LENGTH 1 VALUE &#x27;&#x27;.*----------------------------------------------------------------------** Variables*----------------------------------------------------------------------*DATA: GV_MESSAGE TYPE C, GV_SAVEOK TYPE SY-UCOMM, GV_OKCODE TYPE SY-UCOMM.*----------------------------------------------------------------------** Structure*----------------------------------------------------------------------*DATA: BEGIN OF GS_TABLE, FIELD, END OF GS_TABLE.*----------------------------------------------------------------------** Internal Table*----------------------------------------------------------------------*DATA: GT_TABLE LIKE TABLE OF GS_TABLE, GT_BINTAB TYPE W3MIMETABTYPE.*----------------------------------------------------------------------** Object*----------------------------------------------------------------------**CLASS LCL_EVENTS DEFINITION DEFERRED.DATA:* GO_EVENTS TYPE REF TO LCL_EVENTS, GO_HTML_CONTROL TYPE REF TO CL_GUI_HTML_VIEWER, GO_CONTAINER TYPE REF TO CL_GUI_DOCKING_CONTAINER. 3.选择屏幕的定义 SCR（1）源代码12345678910111213141516171819202122232425262728293031*&amp;---------------------------------------------------------------------**&amp; Include YDISPLAY_PDF_SCR*&amp;---------------------------------------------------------------------*&quot;程序执行类型SELECTION-SCREEN BEGIN OF BLOCK K01 WITH FRAME TITLE TEXT-T01.SELECTION-SCREEN BEGIN OF LINE.&quot;执行方式PARAMETERS: P_TEXT NO-DISPLAY.SELECTION-SCREEN COMMENT 1(23) TEXT-T03 FOR FIELD P_TEXT.&quot;展示网页SELECTION-SCREEN POSITION 32.PARAMETERS: P_DISPL RADIOBUTTON GROUP GR01 USER-COMMAND UC1 DEFAULT &#x27;X&#x27;.SELECTION-SCREEN COMMENT 35(15) TEXT-R01 FOR FIELD P_DISPL.&quot;展示PDF文件内容SELECTION-SCREEN POSITION 50.PARAMETERS: P_DDATA RADIOBUTTON GROUP GR01 .SELECTION-SCREEN COMMENT 52(15) TEXT-R02 FOR FIELD P_DDATA.SELECTION-SCREEN END OF LINE.SELECTION-SCREEN END OF BLOCK K01.&quot;输入内容SELECTION-SCREEN BEGIN OF BLOCK K02 WITH FRAME TITLE TEXT-T02.PARAMETERS: P_FPATH TYPE RLGRAP-FILENAME MODIF ID FP, &quot;文件上传路径 P_WWURL TYPE STRING MODIF ID WU. &quot;网址URLSELECTION-SCREEN END OF BLOCK K02. （2）效果图 4.逻辑部分代码（1）PBO1234567891011121314151617*&amp;---------------------------------------------------------------------**&amp; Module STATUS_0100 OUTPUT*&amp;---------------------------------------------------------------------**&amp;*&amp;---------------------------------------------------------------------*MODULE STATUS_0100 OUTPUT. SET PF-STATUS &#x27;G0100&#x27;. SET TITLEBAR &#x27;T0100&#x27;.ENDMODULE.*&amp;---------------------------------------------------------------------**&amp; Module INITIAL_0100 OUTPUT*&amp;---------------------------------------------------------------------**&amp;*&amp;---------------------------------------------------------------------*MODULE INITIAL_0100 OUTPUT. PERFORM INITIAL_0100.ENDMODULE. （2）PAI12345678*&amp;---------------------------------------------------------------------**&amp; Module EXIT INPUT*&amp;---------------------------------------------------------------------** text*----------------------------------------------------------------------*MODULE EXIT INPUT. PERFORM EXIT.ENDMODULE. （3）F01123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213*&amp;---------------------------------------------------------------------**&amp; Include YDISPLAY_PDF_F01*&amp;---------------------------------------------------------------------**&amp;---------------------------------------------------------------------**&amp; Form EXIT*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM EXIT .*--------------------------Variables-----------------------------------* CONSTANTS: LC_BACK TYPE SY-UCOMM VALUE &#x27;BACK&#x27;, LC_EXIT TYPE SY-UCOMM VALUE &#x27;EXIT&#x27;, LC_CANC TYPE SY-UCOMM VALUE &#x27;CANC&#x27;.*----------------------------Logic-------------------------------------* CLEAR: GV_SAVEOK. GV_SAVEOK = GV_OKCODE. CLEAR: GV_OKCODE. CASE GV_SAVEOK. WHEN LC_BACK OR LC_EXIT OR LC_CANC. LEAVE TO SCREEN 0. WHEN OTHERS. ENDCASE.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form INITIAL_0100*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM INITIAL_0100 . IF GO_HTML_CONTROL IS NOT BOUND. &quot;创建容器与组件对象 PERFORM CREATE_CONTAINER_ASSEMBLY. &quot;设置组件展示用的内容 PERFORM SET_ASSEMBLY_DATA. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CREATE_CONTAINER_ASSEMBLY*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CREATE_CONTAINER_ASSEMBLY . &quot;实例化容器对象 IF GO_CONTAINER IS INITIAL. CREATE OBJECT GO_CONTAINER EXPORTING REPID = SY-REPID DYNNR = SY-DYNGR SIDE = CL_GUI_DOCKING_CONTAINER=&gt;DOCK_AT_LEFT EXTENSION = 2000. ENDIF. &quot;实例化组件对象 CREATE OBJECT GO_HTML_CONTROL EXPORTING PARENT = GO_CONTAINER.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SET_ASSEMBLY_DATA*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SET_ASSEMBLY_DATA .*--------------------------Variables-----------------------------------* DATA: LV_URL TYPE C LENGTH 200.*----------------------------Logic-------------------------------------* &quot;展示PDF文件 IF P_DDATA IS NOT INITIAL. CALL METHOD GO_HTML_CONTROL-&gt;LOAD_DATA( EXPORTING TYPE = &#x27;application&#x27; SUBTYPE = &#x27;PDF&#x27; IMPORTING ASSIGNED_URL = LV_URL CHANGING DATA_TABLE = GT_BINTAB EXCEPTIONS DP_INVALID_PARAMETER = 1 DP_ERROR_GENERAL = 2 CNTL_ERROR = 3 OTHERS = 4 ). ELSE. LV_URL = P_WWURL. ENDIF. &quot;展示组件内容 CALL METHOD GO_HTML_CONTROL-&gt;SHOW_URL( URL = LV_URL IN_PLACE = &#x27;X&#x27; ).ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SELECT_SCREEN_DISPLAY*&amp;---------------------------------------------------------------------**&amp; text 根据选择屏幕单选按钮控制屏幕元素展示内容*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SELECT_SCREEN_DISPLAY .*--------------------------Variables-----------------------------------* CONSTANTS: LC_DISPL TYPE STRING VALUE &#x27;FP&#x27;, LC_DDATA TYPE STRING VALUE &#x27;WU&#x27;. DATA: LV_GROUP TYPE STRING.*----------------------------Logic-------------------------------------* CASE GC_X. WHEN P_DISPL. &quot;展示网页 LV_GROUP = LC_DISPL. WHEN P_DDATA. &quot;展示PDF文件内容 LV_GROUP = LC_DDATA. WHEN OTHERS. ENDCASE. &quot;隐藏屏幕元素 LOOP AT SCREEN. IF SCREEN-GROUP1 EQ LV_GROUP. SCREEN-ACTIVE = 0. ENDIF. MODIFY SCREEN. ENDLOOP.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form GET_FILE_DATA*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM GET_FILE_DATA .*--------------------------Variables-----------------------------------* DATA: LV_FILEPATH TYPE STRING.*----------------------------Logic-------------------------------------* CHECK P_DDATA IS NOT INITIAL. REFRESH: GT_BINTAB. LV_FILEPATH = P_FPATH. CALL FUNCTION &#x27;GUI_UPLOAD&#x27; EXPORTING FILENAME = LV_FILEPATH FILETYPE = &#x27;BIN&#x27;* HAS_FIELD_SEPARATOR = &#x27;&#x27;* HEADER_LENGTH = 0* READ_BY_LINE = &#x27;X&#x27;* DAT_MODE = &#x27; &#x27;* CODEPAGE = LV_CODEPAGE* IGNORE_CERR = ABAP_TRUE* REPLACEMENT = &#x27;#&#x27;* CHECK_BOM = &#x27; &#x27;* VIRUS_SCAN_PROFILE = NO_AUTH_CHECK = &#x27;X&#x27;* IMPORTING* FILELENGTH =* HEADER = TABLES DATA_TAB = GT_BINTAB* CHANGING* ISSCANPERFORMED = &#x27; &#x27; EXCEPTIONS FILE_OPEN_ERROR = 1 FILE_READ_ERROR = 2 NO_BATCH = 3 GUI_REFUSE_FILETRANSFER = 4 INVALID_TYPE = 5 NO_AUTHORITY = 6 UNKNOWN_ERROR = 7 BAD_DATA_FORMAT = 8 HEADER_NOT_ALLOWED = 9 SEPARATOR_NOT_ALLOWED = 10 HEADER_TOO_LONG = 11 UNKNOWN_DP_ERROR = 12 ACCESS_DENIED = 13 DP_OUT_OF_MEMORY = 14 DISK_FULL = 15 DP_TIMEOUT = 16 OTHERS = 17. IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SEARCH_HELP_FILEPATH*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; &lt;-- P_FPATH*&amp;---------------------------------------------------------------------*FORM SEARCH_HELP_FILEPATH CHANGING VALUE(PV_FILEPATH) TYPE RLGRAP-FILENAME. CALL FUNCTION &#x27;F4_FILENAME&#x27; EXPORTING FIELD_NAME = &#x27;C:\\&#x27; IMPORTING FILE_NAME = PV_FILEPATH.ENDFORM.","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"GUI_UPLOAD & GUI_DOWNLOAD 使用示例与解释","slug":"ABAP/GUI_UPLOAD & GUI_DOWNLOAD/GUI-UPLOAD-GUI-DOWNLOAD-使用示例与解释","date":"2023-10-31T03:31:45.000Z","updated":"2024-02-27T07:06:08.843Z","comments":true,"path":"2023/10/31/ABAP/GUI_UPLOAD & GUI_DOWNLOAD/GUI-UPLOAD-GUI-DOWNLOAD-使用示例与解释/","link":"","permalink":"https://www.yemaojun.top/2023/10/31/ABAP/GUI_UPLOAD%20&%20GUI_DOWNLOAD/GUI-UPLOAD-GUI-DOWNLOAD-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E4%B8%8E%E8%A7%A3%E9%87%8A/","excerpt":"这两天需要开发一个通过接口传输文件的需求。其中需要将文件转换为二进制流的形式传输文件，将上传和接收到的文件转换位二进制流文件就是通过Function GUI_UPLOAD和Function GUI_DOWNLOAD来实现的，但是文件中的字符有中文，英文或其他特殊字符等情况存在，贸然使用上面的Function会出现乱码等问题。所以本片笔记会针对上面的问题进行解释并提出解决方案。","text":"这两天需要开发一个通过接口传输文件的需求。其中需要将文件转换为二进制流的形式传输文件，将上传和接收到的文件转换位二进制流文件就是通过Function GUI_UPLOAD和Function GUI_DOWNLOAD来实现的，但是文件中的字符有中文，英文或其他特殊字符等情况存在，贸然使用上面的Function会出现乱码等问题。所以本片笔记会针对上面的问题进行解释并提出解决方案。 GUI_UPLOAD & GUI_DOWNLOAD 使用示例与解释 一、GUI_UPLOAD &amp; GUI_DOWNLOAD1.方法简介将本地文件上传到SAP内存中时可以使用Function GUI_UPLOAD。使用该Function可以上传多种类型的文件，不会限制文件的类型。 与上面的GUI_UPLOAD类似，在下载文件时，可以使用Function GUI_DOWNLOAD。 2.参数介绍（1）输入参数 FILETYPE如上面输入参数介绍的。此处填写的文件类型并非是指上传的文件类型，而是上传文件的处理类型。在此处介绍一下可以填入的三种类型值的含义。 ① ASCThe components of the internal table are filled from the file. Only data types with fixed length are allowed. The data must be contained in the file in its full length. 内部表格的组成部分由该文件填充。只允许使用固定长度的数据类型。数据必须以其完整长度包含在文件中。 此处的意思是指将文件中的内容读取到内表中，但是该内表的类型必须为固定长度类型的结构，且该结构的长度必须可以包含读取的内容的。 ② BINThe system reads a binary representation of the internal table from the file. The data is neither converted nor interpreted in this case. Usually, reasonable results are obtained only if the internal table consists of a single column of type ‘X’. 系统从文件中读取内部表的二进制表示形式。在这种情况下，既不转换数据，也不解释数据。通常，只有当内部表由“X”类型的单列组成时，才能获得合理的结果。 也就是说文件是通过二进制的文件流形式使用的，一般在传输文件时会使用这种类型的参数。且使用这种二进制类型参数接受文件时，内表的类型必须是XSTRING或RAW类型的内表。此处放一个我比较常用的标准二进制类型的内表 W3MIMETABTYPE。 ③ DATThe components of the internal table are filled from the file. If the table contains several columns, the entries in the file must be separated by tabs. No conversion exits are performed. The following applies for the different data types: I or N or P or F The numbers must be formatted according to the decimal representation defined in the user settings. D The date must be formatted according to the date format defined in the user settings. T The time must be formatted as hh:mm:ss. 内部表格的组成部分由该文件填充。如果表包含多个列，则文件中的条目必须用制表符分隔。不执行转换退出。 以下适用于不同的数据类型： I或N或P或F 数字必须根据用户设置中定义的十进制表示形式进行格式化。 D 日期必须根据用户设置中定义的日期格式进行格式化。 T 时间的格式必须为hh:mm:ss。 （2）输入参数 CODEPAGESAP 输入参数的描述：输出的字符表示。我的理解是上传文件时，对文件中字符处理的编码方式。当输出文件时便是输出文件的字符集。 CODEPAGE是NUMC类型4位长度的参数。在国内比较常用的几种类型如下： 8400&#x2F;8404 代表“GBK”中文简体 8300&#x2F;8304 (big5)代表台湾的中文繁体 8340&#x2F;8344 (Big5-HKSCS)代表香港的中文繁体，在媒体转换程序下载成TXT格式且不使用任何格式符，只是靠定义的字段长度时限制，用这种Codepage较好。 4110&#x2F;4310 为utf-8。Unicode为4103使用时需要将WRITE_BOM＝’X’（写入Unicode字节顺序标记）。 如果要查看字符集的数据可以去 TCP00A表查看。举两个例子。例如UTF字符集内容： 其中属性类型如下所示： 也可以使用Function NLS_GET_FRONTEND_CP根据语言代码查找对应的字符4位编码。 如果你能一开始就和用户约定好可以将文件的编码格式告知你，则你可以通过Function SCP_CODEPAGE_BY_EXTERNAL_NAME根据编码方式获取Codepage。 （3）GUI_UPLOAD参数介绍① 输入参数 参数名 类型 缺省值 说明 FILENAME STRING 文件地址，虽然参数翻译为文件名称，但传入的其实是文件地址 FILETYPE CHAR10 ‘ASC’ 此处填写的文件类型并非是指上传的文件类型，而是上传文件的处理类型，可填入的值有三种。ASC（默认）、BIN和DAT。 HAS_FIELD_SEPARATOR CHAR01 SPACE 上传时，使用ASCII制表符分割列。 HEADER_LENGTH I 0 二进制数据的头长度 READ_BY_LINE CHAR01 ‘X’ 逐行将文件内容读进内表中 DAT_MODE CHAR01 SPACE 以ws_download“DAT”格式导入的数字和日期字段 CODEPAGE ABAP_ENCODING SPACE 输出的字符表示 IGNORE_CERR ABAP_BOOL ABAP_TRUE 指定是否忽略转换字符集的错误 REPLACEMENT ABAP_REPL ‘#’ 不可转换字符的替换字符，存在无法转换的字符时会使用传入的内容进行替换 CHECK_BOM CHAR01 SPACE 将检查代码页和字节顺序标记的一致性 VIRUS_SCAN_PROFILE VSCAN_PROFILE 病毒扫描配置文件 NO_AUTH_CHECK CHAR01 SPACE 关闭访问权限检查 ② 输出参数 参数名 类型 说明 FILELENGTH I 上传的文件大小 HEADER XSTRING 二进制上传情况下的文件头 （4）GUI_DOWNLOAD 参数介绍① 输入参数 参数名 类型 缺省值 说明 BIN_FILESIZE I 二进制文件的文件长度 FILENAME STRING 文件名称（下载地址） FILETYPE CHAR10 ‘ASC’ 文件类型（ASC or BIN） APPEND CHAR01 SPACE 写入模式（覆盖、追加） WRITE_FIELD_SEPARATOR CHAR01 SPACE ASCII下载时用制表符分隔列 HEADER XSTRING ‘00’ 在文件开头以二进制模式写入的字节链 TRUNC_TRAILING_BLANKS CHAR01 SPACE 保留末尾空格 WRITE_LF CHAR01 ‘X’ 在每行的末尾插入一个行分隔符 COL_SELECT CHAR01 SPACE 激活列选择。您可以使用列选择来选择要传输到文件的列。此参数仅适用于FILETYPE“DAT”和“DBF”。 COL_SELECT_MASK CHAR255 SPACE 结合COL_SELECT，可以进行列选择。 DAT_MODE CHAR01 SPACE 以ws_download“DAT”格式编写的数字和日期字段 CONFIRM_OVERWRITE CHAR01 SPACE 仅在确认后覆盖文件 NO_AUTH_CHECK CHAR01 SPACE 关闭访问权限检查 CODEPAGE ABAP_ENCODING SPACE 输出的字符编码格式 IGNORE_CERR ABAP_BOOL ABAP_TRUE 指定是否忽略转换字符集的错误 REPLACEMENT ABAP_REPL ‘#’ 不可转换字符的替换字符 WRITE_BOM ABAP_BOOL SPACE 写入Unicode字节顺序标记 TRUNC_TRAILING_BLANKS_EOL CHAR01 ‘X’ 删除最后一列末尾的空格 WK1_N_FORMAT SPACE WK1类型文件中值列的格式 WK1_N_SIZE SPACE WK1类型文件中值列的列宽 WRITE_LF_AFTER_LAST_LINE ABAP_BOOL ABAP_TRUE 在最后一行之后写入行分隔符 SHOW_TRANSFER_STATUS ABAP_BOOL ABAP_TRUE VIRUS_SCAN_PROFILE VSCAN_PROFILE ‘&#x2F;SCET&#x2F;GUI_DOWNLOAD’ 病毒扫描配置文件 ② 输出参数 参数名 类型 说明 FILELENGTH I 传输的字节数 二、GUI_UPLOAD上传示例1.执行效果（1）选择屏幕 （2）ASC类型展示TXT文档 12345678910111213141516171819202122232425262728*--------------------------Variables-----------------------------------* FIELD-SYMBOLS: &lt;FLT_TABLE&gt; TYPE STANDARD TABLE.*----------------------------Logic-------------------------------------* IF GT_TABLE IS INITIAL AND GT_DTEXT IS INITIAL. &quot;展示数据为空 MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. CASE GC_X. WHEN P_DISPL. ASSIGN GT_TABLE TO &lt;FLT_TABLE&gt;. WHEN P_DTEXT. ASSIGN GT_DTEXT TO &lt;FLT_TABLE&gt;. WHEN OTHERS. ENDCASE. CHECK SY-SUBRC EQ 0. &quot;数据展示界面设置 CL_DEMO_OUTPUT=&gt;NEW( )-&gt;BEGIN_SECTION( `Upload File Information` )-&gt;NEXT_SECTION( `Upload File Path` )-&gt;WRITE_DATA( P_FPATH )-&gt;NEXT_SECTION( `File Data` )-&gt;WRITE_DATA( &lt;FLT_TABLE&gt; )-&gt;END_SECTION( )-&gt;DISPLAY( ). （3）DAT类型分列展示TXT文档 代码与上面的代码逻辑相同，两者共用了同一段逻辑，只是接收数据的类型与展示用的内表结构不一样。 （4）BIN类型展示PDF文档 此处是使用了一个自适应容器和LOAD_DATA Function实现的。后期会单独出一篇笔记记录。 2.示例源代码（1）Include TOP 全局变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*----------------------------------------------------------------------** Constants*----------------------------------------------------------------------*CONSTANTS: GC_X TYPE C LENGTH 1 VALUE &#x27;X&#x27;, GC_S TYPE C LENGTH 1 VALUE &#x27;S&#x27;, GC_E TYPE C LENGTH 1 VALUE &#x27;E&#x27;, GC_NULL TYPE C LENGTH 1 VALUE &#x27;&#x27;.*----------------------------------------------------------------------** Variables*----------------------------------------------------------------------*DATA: GV_MESSAGE TYPE C, GV_FILETYPE TYPE C LENGTH 100, GV_SAVEOK TYPE SY-UCOMM, GV_OKCODE TYPE SY-UCOMM.*----------------------------------------------------------------------** Structure*----------------------------------------------------------------------*DATA: BEGIN OF GS_TABLE, VALUE TYPE C LENGTH 100, END OF GS_TABLE, BEGIN OF GS_DTEXT, FILED1 TYPE C LENGTH 50, FILED2 TYPE C LENGTH 50, FILED3 TYPE C LENGTH 50, FILED4 TYPE C LENGTH 50, FILED5 TYPE C LENGTH 50, END OF GS_DTEXT, GS_BINTAB TYPE W3MIME.*----------------------------------------------------------------------** Internal Table*----------------------------------------------------------------------*DATA: GT_DTEXT LIKE TABLE OF GS_DTEXT, GT_TABLE LIKE TABLE OF GS_TABLE, GT_BINTAB TYPE W3MIMETABTYPE.*----------------------------------------------------------------------** Object*----------------------------------------------------------------------*DATA: GO_CONTAINER TYPE REF TO CL_GUI_DOCKING_CONTAINER, GO_HTML_CONTROL TYPE REF TO CL_GUI_HTML_VIEWER. （2）Include SCR 选择屏幕源码12345678910111213141516171819202122232425262728293031&quot;Selection ScreenSELECTION-SCREEN BEGIN OF BLOCK K01 WITH FRAME TITLE TEXT-T01.PARAMETERS: P_FPATH TYPE RLGRAP-FILENAME. &quot;文件上传路径SELECTION-SCREEN BEGIN OF LINE.&quot;执行方式PARAMETERS: P_TEXT NO-DISPLAY.SELECTION-SCREEN COMMENT 1(23) TEXT-T02 FOR FIELD P_TEXT.&quot;展示数据 ASCSELECTION-SCREEN POSITION 32.PARAMETERS: P_DISPL RADIOBUTTON GROUP GR01 USER-COMMAND UC1 DEFAULT &#x27;X&#x27;.SELECTION-SCREEN COMMENT 35(15) TEXT-R01 FOR FIELD P_DISPL.&quot;展示文件内容(PDF) BINSELECTION-SCREEN POSITION 50.PARAMETERS: P_DDATA RADIOBUTTON GROUP GR01 .SELECTION-SCREEN COMMENT 52(15) TEXT-R02 FOR FIELD P_DDATA.&quot;分列Text文件 DATSELECTION-SCREEN POSITION 75.PARAMETERS: P_DTEXT RADIOBUTTON GROUP GR01 .SELECTION-SCREEN COMMENT 77(15) TEXT-R03 FOR FIELD P_DTEXT.SELECTION-SCREEN END OF LINE.SELECTION-SCREEN END OF BLOCK K01. （3）Include PBO 自定义屏幕初始逻辑1234567891011121314151617*&amp;---------------------------------------------------------------------**&amp; Module STATUS_0100 OUTPUT*&amp;---------------------------------------------------------------------**&amp;*&amp;---------------------------------------------------------------------*MODULE STATUS_0100 OUTPUT. SET PF-STATUS &#x27;G0100&#x27;.* SET TITLEBAR &#x27;xxx&#x27;.ENDMODULE.*&amp;---------------------------------------------------------------------**&amp; Module INITIAL_0100 OUTPUT*&amp;---------------------------------------------------------------------**&amp;*&amp;---------------------------------------------------------------------*MODULE INITIAL_0100 OUTPUT. PERFORM INITIAL_0100.ENDMODULE. （4）Include PAI 自定义屏幕功能逻辑12345678*&amp;---------------------------------------------------------------------**&amp; Module EXIT INPUT*&amp;---------------------------------------------------------------------** text*----------------------------------------------------------------------*MODULE EXIT INPUT. PERFORM EXIT.ENDMODULE. （5）Include F01 程序逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251*&amp;---------------------------------------------------------------------**&amp; Form SEARCH_HELP_FILEPATH*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; &lt;-- P_FPATH*&amp;---------------------------------------------------------------------*FORM SEARCH_HELP_FILEPATH CHANGING VALUE(PV_FILEPATH) TYPE RLGRAP-FILENAME. CALL FUNCTION &#x27;F4_FILENAME&#x27; EXPORTING FIELD_NAME = &#x27;C:\\&#x27; IMPORTING FILE_NAME = PV_FILEPATH.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form GET_DATA*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM GET_DATA .*--------------------------Variables-----------------------------------* DATA: LT_FILE TYPE TABLE OF STRING, LV_INDEX TYPE SY-TABIX, LV_CODEPAGE TYPE ABAP_ENCODING, LV_FILEPATH TYPE STRING, LV_FILETYPE TYPE CHAR10, LV_SPFLIFLAG TYPE C. FIELD-SYMBOLS: &lt;FLT_TABLE&gt; TYPE STANDARD TABLE.*----------------------------Logic-------------------------------------* REFRESH: GT_TABLE,GT_BINTAB,GT_DTEXT. &quot;获取文件类型 SPLIT P_FPATH AT &#x27;.&#x27; INTO TABLE LT_FILE. LV_INDEX = LINES( LT_FILE ). READ TABLE LT_FILE INTO GV_FILETYPE INDEX LV_INDEX. CASE GC_X. WHEN P_DISPL. IF GV_FILETYPE NS &#x27;TXT&#x27;. &quot;文件类型不是TXT，无法展示 MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. LV_CODEPAGE = &#x27;4310&#x27;. &quot;UTF-8 LV_FILETYPE = &#x27;ASC&#x27;. LV_SPFLIFLAG = GC_NULL. ASSIGN GT_TABLE TO &lt;FLT_TABLE&gt;. CHECK SY-SUBRC EQ 0. WHEN P_DDATA. &quot;校验文件类型 IF GV_FILETYPE NS &#x27;PDF&#x27;. &quot;文件类型不是PDF，无法展示 MESSAGE TEXT-E02 TYPE GC_S DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. LV_FILETYPE = &#x27;BIN&#x27;. ASSIGN GT_BINTAB TO &lt;FLT_TABLE&gt;. CHECK SY-SUBRC EQ 0. WHEN P_DTEXT. IF GV_FILETYPE NS &#x27;TXT&#x27;. &quot;文件类型不是TXT，无法展示 MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. LV_CODEPAGE = &#x27;4310&#x27;. &quot;UTF-8 LV_FILETYPE = &#x27;DAT&#x27;. LV_SPFLIFLAG = GC_X. ASSIGN GT_DTEXT TO &lt;FLT_TABLE&gt;. CHECK SY-SUBRC EQ 0. WHEN OTHERS. ENDCASE. LV_FILEPATH = P_FPATH. CALL FUNCTION &#x27;GUI_UPLOAD&#x27; EXPORTING FILENAME = LV_FILEPATH FILETYPE = LV_FILETYPE HAS_FIELD_SEPARATOR = LV_SPFLIFLAG* HEADER_LENGTH = 0* READ_BY_LINE = &#x27;X&#x27;* DAT_MODE = &#x27; &#x27; CODEPAGE = LV_CODEPAGE* IGNORE_CERR = ABAP_TRUE* REPLACEMENT = &#x27;#&#x27;* CHECK_BOM = &#x27; &#x27;* VIRUS_SCAN_PROFILE = NO_AUTH_CHECK = &#x27;X&#x27;* IMPORTING* FILELENGTH =* HEADER = TABLES DATA_TAB = &lt;FLT_TABLE&gt;* CHANGING* ISSCANPERFORMED = &#x27; &#x27; EXCEPTIONS FILE_OPEN_ERROR = 1 FILE_READ_ERROR = 2 NO_BATCH = 3 GUI_REFUSE_FILETRANSFER = 4 INVALID_TYPE = 5 NO_AUTHORITY = 6 UNKNOWN_ERROR = 7 BAD_DATA_FORMAT = 8 HEADER_NOT_ALLOWED = 9 SEPARATOR_NOT_ALLOWED = 10 HEADER_TOO_LONG = 11 UNKNOWN_DP_ERROR = 12 ACCESS_DENIED = 13 DP_OUT_OF_MEMORY = 14 DISK_FULL = 15 DP_TIMEOUT = 16 OTHERS = 17 . IF SY-SUBRC &lt;&gt; 0.* Implement suitable error handling here ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form DATA_OPERATION*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM DATA_OPERATION . CASE GC_X. WHEN P_DISPL OR P_DTEXT. PERFORM DISPLAY_DATA. WHEN P_DDATA. IF SY-BATCH IS INITIAL. CALL SCREEN 0100. ENDIF. WHEN OTHERS. ENDCASE.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form DISPLAY_DATA*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM DISPLAY_DATA .*--------------------------Variables-----------------------------------* FIELD-SYMBOLS: &lt;FLT_TABLE&gt; TYPE STANDARD TABLE.*----------------------------Logic-------------------------------------* IF GT_TABLE IS INITIAL AND GT_DTEXT IS INITIAL. &quot;展示数据为空 MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. CASE GC_X. WHEN P_DISPL. ASSIGN GT_TABLE TO &lt;FLT_TABLE&gt;. WHEN P_DTEXT. ASSIGN GT_DTEXT TO &lt;FLT_TABLE&gt;. WHEN OTHERS. ENDCASE. CHECK SY-SUBRC EQ 0. &quot;数据展示界面设置 CL_DEMO_OUTPUT=&gt;NEW( )-&gt;BEGIN_SECTION( `Upload File Information` )-&gt;NEXT_SECTION( `Upload File Path` )-&gt;WRITE_DATA( P_FPATH )-&gt;NEXT_SECTION( `File Data` )-&gt;WRITE_DATA( &lt;FLT_TABLE&gt; )-&gt;END_SECTION( )-&gt;DISPLAY( ).ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form INITIAL_0100*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM INITIAL_0100 .*--------------------------Variables-----------------------------------* DATA: LV_URL TYPE C LENGTH 200.*----------------------------Logic-------------------------------------* IF GO_CONTAINER IS INITIAL. &quot;创建自适应容器对象 CREATE OBJECT GO_CONTAINER EXPORTING REPID = SY-REPID DYNNR = SY-DYNGR SIDE = CL_GUI_DOCKING_CONTAINER=&gt;DOCK_AT_LEFT EXTENSION = 2000. &quot;创建用于展示HTML页面的组件对象 CREATE OBJECT GO_HTML_CONTROL EXPORTING PARENT = GO_CONTAINER. &quot;将PDF的二进制流传入HTML页面组件对象，得到用于展示PDF的虚拟URL地址 CALL METHOD GO_HTML_CONTROL-&gt;LOAD_DATA( EXPORTING TYPE = &#x27;application&#x27; SUBTYPE = GV_FILETYPE IMPORTING ASSIGNED_URL = LV_URL CHANGING DATA_TABLE = GT_BINTAB EXCEPTIONS DP_INVALID_PARAMETER = 1 DP_ERROR_GENERAL = 2 CNTL_ERROR = 3 OTHERS = 4 ). &quot;根据URL地址展示HTML页面 CALL METHOD GO_HTML_CONTROL-&gt;SHOW_URL( URL = LV_URL IN_PLACE = &#x27;X&#x27; ). ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form EXIT*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM EXIT .*--------------------------Variables-----------------------------------* CONSTANTS: LC_BACK TYPE SY-UCOMM VALUE &#x27;BACK&#x27;, LC_EXIT TYPE SY-UCOMM VALUE &#x27;EXIT&#x27;, LC_CANC TYPE SY-UCOMM VALUE &#x27;CANC&#x27;.*----------------------------Logic-------------------------------------* CLEAR: GV_SAVEOK. GV_SAVEOK = GV_OKCODE. CLEAR: GV_OKCODE. CASE GV_SAVEOK. WHEN LC_BACK OR LC_EXIT OR LC_CANC. LEAVE TO SCREEN 0. WHEN OTHERS. ENDCASE.ENDFORM. 三、参考资料[SAP ABAP开发技术总结] 字符编码与解码、Unicode SAP GUI download文件中乱码问题Codepage参数说明 ABAP大虾帮忙：gui_download乱码","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"杂项收录","slug":"杂项收录","permalink":"https://www.yemaojun.top/categories/%E6%9D%82%E9%A1%B9%E6%94%B6%E5%BD%95/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"PO接口配置 RFC形式","slug":"ABAP/PO 接口/PO接口配置 RFC形式/PO接口配置-RFC形式","date":"2023-09-25T00:34:38.000Z","updated":"2023-12-08T02:24:26.071Z","comments":true,"path":"2023/09/25/ABAP/PO 接口/PO接口配置 RFC形式/PO接口配置-RFC形式/","link":"","permalink":"https://www.yemaojun.top/2023/09/25/ABAP/PO%20%E6%8E%A5%E5%8F%A3/PO%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%20RFC%E5%BD%A2%E5%BC%8F/PO%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE-RFC%E5%BD%A2%E5%BC%8F/","excerpt":"最近项目上涉及到PO接口相关的内容，所以在这里记录一下RFC的PO接口配置方式。后续还有代理类形式这种目前较为常用的配置方式。","text":"最近项目上涉及到PO接口相关的内容，所以在这里记录一下RFC的PO接口配置方式。后续还有代理类形式这种目前较为常用的配置方式。 PO接口配置 RFC形式 一、编写远程调用RFC使用PO的RFC形式接口，需要在SAP GUI先将远程调用的RFC编写完成。在编写RFC时，需要注意将RFC的属性，设置为远程启用的模块。 在设置这个属性时，需要将参数都设置为值传递。 除了需要设置导入和导出参数的值传递属性外，还需要在Table页签中将其中的所有参数勾选上可选的。这样做主要是为了将所有的校验过程都放在SAP中进行。如果你在此处有一个参数没选择可选的属性，那么外围系统在调用这个接口时会直接被PO端返回500的状态码和一些用于说明异常的乱码。但是这样的乱码对于代码的友好性不高，所以建议在此处将部分参数设置为可选的，而将输入校验放在SAP代码中进行校验，然后封装返回的Message传递给外围系统。 二、配置PO接口1.打开PO配置页面此处做一个提醒，在使用PO接口配置时，需要保证自己的PC环境中有Java的JDK包。不然无法生成服务和通道。 此处的PO配置页面地址可以向Basis或者PO顾问咨询，由他们提供给你PO的地址和账号。当然你也可以使用它们的账号为自己创建一个账号。打开的PO配置界面如下。 在这个页面有很多的内容项。基本上你要使用和操作的大部分功能都需要登陆PO之后才可以进行。而登录的方式也很简单，只需要你随意点击界面上的一个链接，然后就会进入下图所示的登陆界面，输入你的PO管理员账号登陆即可。 2.配置PO账号既然在此处提到了配置PO的管理员账号，那就在这里提一嘴。 点击下图中红框圈中的超链接，进入PO的配置界面。 按照图中圈中的页签，进入到PO的身份管理界面。 进入后你可以在上面的输入框中输入**然后点击查询，查询出当前PO的全部管理员账号信息。然后可以点击上面的创建用户*按钮新建用户账号信息。也可以找到其他人的账号进行复制就行。一般情况下我们都是直接复制别人的账号然后修改一下账号和密码与用户信息即可。这样最方便。 配置完账号属性与信息之后点击上面的保存按钮就创建好PO的管理员账号了。之后可以使用这个账号对PO进行配置和操作。 3.配置PO接口对象点击下图中红圈圈中的企业服务生成器，第一次进入时需要输入你的PO管理员账号。 输入完成账号信息之后，浏览器会为你下载一个PO的配置文件，打开该文件进入PO配置文件。 4.导入RFC（1）找到导入RFC的路径进入PO的服务生成器后，就可以通过下图所示的路径，导入RFC。此处有个注意事项，此处可以导入的只有在RFC属性中选择了远程启用的模块属性的Function。如果你在此处找不到你需要导入的Function，则可以看看是不是这个属性没有设置。 在RFCs上单击鼠标右键，唤出Import of SAP Objects按钮。 在导入RFC前需要登陆你要导入的SAP系统。需要填入SAP系统的IP地址和编码，最后再输入账号和密码。 （2）查找需要导入的RFC进行完上面的操作之后，就会弹出下图所示的弹框。在该弹框中会有两个页签。分别是IDoc页签和RFC页签。因为我们导入的是RFC对象，所以我们展开RFC页签。展开时因为RFC对象数量较多，所以会等待一小段时间。等待系统将找到的RFC列举出来后，在上方的搜索输入框中输入需要导入的Function名称，点击查询，就可以找到需要导入的Function了。 点击上面红色框圈起来的按钮后，就会将你的RFC导入到PO系统中，如下图所示。 可以看到刚刚导入的RFC和其余的RFC并不一样，这是因为这个新导入的RFC没有激活。 （3）激活导入的RFC对象在PO中激活对象的方式是在没有激活的对象上单击右键，然后点击Activate按钮。之后在弹出来的框中选中你要激活的对象然后点击左下角的Activate按钮，激活对象。 值得注意的是，没有变更过的对象，单击鼠标右键是不会出现激活这个选项按钮的。只有在未激活的对象上右键才会出现这个选项按钮。 进行完以上操作之后，导入RFC的操作就全部完成了。接下来就是创建服务的过程了。 5.创建PO服务为了方便后续的维护，我们可以创建一个关于这个接口的文件夹，将与这个接口有关的内容全部放在这个文件夹中。我当前的这个接口是与WMS的MM模块进行交互的接口，所以我将文件夹建在WMS的MM区域中。 （1）创建接口文件夹 编写文件夹名称与描述。 点击保存按钮，将文件夹与其属性保存到PO。此时的文件夹是非激活状态，等后面我们创建的东西多起来之后一起激活。 （2）创建Service与上面创建文件夹类似，在新创建的文件夹上右键，点击New按钮。然后按照下图所示的内容新建Service Interface。并为其起一个名字。方便后面使用和查找。 先修改服务节点为异步。在其中填入刚刚导入的RFC的Request与Response对象。此处填写这两个对象时有个注意事项。导入RFC的两个对象时，不要点击搜索帮助按钮。点击搜索帮助按钮后面的下拉框箭头，然后选择RFC Message。打开帮助弹框，选择刚刚导入的RFC对象。 此处有个注意事项，虽然该服务的分类（Category）为Outbound，但其实代表的却是数据的输入源，也就是外围系统传输数据到PO的这一个过程，所以此处如果你设置了不同的映射字段，此处就需要根据具体的需求填写不同的MT对象。 根据角色Role列的信息，在第一行导入RFC的Request对象。 在第二行，导入RFC的Response对象。 导入完成之后点击上面的保存按钮，将Service保存到刚刚新建的文件中即可。 6.Request Message Mapping（Request报文字段映射）这里是映射外围系统报文字段与SAP系统字段的地方，如果外围系统的字段名称与SAP的名称不一致，就需要在这里对他们进行例外映射。相反如果字段名称一致，那么只需要选中他们的抬头结构点击映射按钮，系统就会自动根据字段的名称进行映射了。字段名称不一样的处理方式我会在创建代理类的PO中进行介绍，此处就介绍下如果两边系统字段名称一致时的处理方式。 所以开发时建议业务顾问和外围系统对接时，能将两边的字段统一一下。这样无论是开发还是调试都会方便很多。 （1）新建Request Message Mapping对象 （2）填写映射字段结构新建完映射对象后，会来到下图所的界面。这个界面就是用来映射请求的字段对应的界面。点击图中红框圈中的搜索帮助按钮。打开PO中现在存在和导入的结构。 在两边的搜索列表中选择我们之前导入的RFC对象。 （3）映射字段之后选中两边结构的抬头，点击红框圈中的映射按钮，看到两边的字段前面的圆点颜色变成绿色则代表该字段映射成功。或者你也可以点击其中的某一个字段，看到最下面出现映射结构则也代表映射成功。 完成上面的操作之后，就和保存文件夹一样，点击最上面的保存按钮，将Request Message Mapping保存好。 7.Response Message Mapping（Response报文字段映射）（1）导入映射字段结构这个和上面的Request Message Mapping一样，只不过上面是用来映射Request的报文字段的，这个是用来映射Response的报文字段的。所以这里直接从上面的点击搜索帮助导入字段结构开始。 之前导入的是RFC对象，这次导入RFC的Response对象。 （2）映射接口字段在两侧都导入RFC的Response对象后，和上面的映射操作一样。先选择抬头的结构，然后点击映射按钮。在点击映射按钮之前可以看到字段在未映射之前，前面的圆点颜色是灰色的。而且现在点击的字段在最下面也是没有映射结构的。 在点击映射按钮后就可以看到比较明显的变化了。字段前圆点变为绿色，下面出现字段映射结构。 之后点击保存按钮，保存Message Mapping。 8.关联接口的出入参数我们在上面将接口的SAP端传入参数与外围系统的传入参数进行了映射，此外还将SAP端的传出参数与外围系统的传出参数也同样进行了映射。但是并没有将传入参数与传出参数进行映射。将传入参数与传出参数进行映射的对象为Operation Mapping。 （1）新建Operation Mapping对象（映射传入与传出参数）同样是在接口文件夹上右键新建下图所示的对象。并为其分配一个用于快速定位的名字。 （2）填写映射的对象新建好的Operation Mapping对象界面如下图所示，图中红圈圈中的输入框就是要填入的属性参数。 Source Operation：源操作 Target Operation：目标操作 ① Source Operation 源操作点击输入框的搜索帮助按钮，将服务对象导入。 ② Target Operation 目标操作此时将SAP的导入的RFC对象引用进输入框中。 ③ 填入Response映射结构此处填写参数映射时有个注意事项，因为新建的Operation Mapping对象在一开始不会显示输入与输出参数映射的页签。需要点击下图箭头指向的按钮，将参数页签刷新出来。 之后再根据输入框的搜索帮助将之前设置的Message Mapping对象填入即可。 ④ 填入Request映射结构只要唤出参数页签，填写参数映射对象的方式就都是一样的。 9.激活接口对象配置完以上内容之后，就完成了PO接口的配置了。接口的文件夹结构如下。 然后将其激活就可以进行下一步的操作了，配置接口的通道。 三、配置PO通道集成1.进入集成界面点击下图红圈圈中的超链接，进入与PO配置类似的网页浏览器下载PO集成软件。同样的，如果你是刚进入PO的话需要登陆之后才可以进行下一步操作，但如果你登陆过后就不需要再次登陆了。 进入到下载软件界面 之后将下载好的软件打开运行最后会进入到下面的界面中。 2.更改视图结构此处不一定要和我一样，只是我习惯这样而已。点击图中红圈圈中的下拉框，选中文件夹形式。 展开文件夹，因为是和WMS系统交互的接口，所以我们打开WMS的文件夹。在这个文件夹下添加接口的通道和集成。 3.通信通道（1）创建通信通道在WMS的文件夹上右键点击New按钮，新增如下图所示的通信通道对象（Communication Channel）。 通信组件（Communication Component）：将PO顾问配置好的外围系统的Business Component对象放置在此处，这个输入框最后面有搜索帮助按钮，所以可以通过搜索帮助弹框快速键入外围系统的Business Component。 通信通道（Communication Channel）：此处就是新建的通信通道的名称了，为了方便后面查找，建议规范命名形式。 （2）填写接口类型新建好的通信通道界面如下所示，在这个界面你需要选择接口的适配器类型。方式有很多种，点击红框圈中的搜索帮助可以看到很多的适配器类型。 PO端支持的适配器类型入下面弹框所示的内容，还有一部分适配器类型在下拉框下面就不展示了，因为本接口使用的是Rest类型的适配器，所以这次就将其设置为Rest类型的适配器，然后向下配置适配器的参数内容。 （3）填写Rest适配器参数 用于获取Element Name与Element Namespace的界面。注意命名空间填写的是冒号中间的内容。 （4）设置接口的URL因为PO接口地址的前缀都是一样的，所以此处只需要设置PO个例的URL后缀即可。例如下图所示的内容，他的URL就是：http://poappdev:50000/RESTAdapter/ERP/ZMMFM010 PO URL的公共前缀：http://poappdev:50000/RESTAdapter （5）设置请求方式此处设置的就是接口的请求方式。GET、POST、PUT、DELETE和PATCH等。 （6）添加服务到业务组件此处主要是为了创建集成配置时导入使用的。点击需要交互的外围系统所对应的Business Component业务组件，跳转到Sender页签中点击编辑按钮，将之前PO接口的服务添加到其中。 4.集成配置（1）创建集成对象如果上面没有添加服务到业务组件中，此处Interface的搜索帮助是无法带出你想要的服务对象的。 （2）入站设置 Inbound Processing使用第一个输入框的搜索帮助按钮，将之前创建的通信通道填进去。 （3）接收者 Receiver因为是外围系统调用SAP，所以接收者就是SAP系统的Business Component业务组件。使用搜索帮助按钮将SAP系统的业务组件填入即可。 （4）接收者接口 Receiver Interfaces此处填写的是PO接口中，参数映射对象，也就是Operation Mapping对象。 （5）出站设置 Outbound Processing传入上面创建的通信通道。 （6）高级设置 Advanced Settings此处主要用来设置接口返回的报文与日志信息。 进行完上面的操作之后，保存并激活所有的对象，就完成测试了。 四、接口测试1.测试工具 Postman之前测试接口介绍过Soap UI这个测试工具，这次换一种。使用Postman对接口进行测试，但是使用这个软件测试时如果是第一次使用需要创建一个账号。不然没法创建工作空间保存测试的接口地址和报文信息。 首先附上Postman的下载地址：Download Postman | Get Started for Free 2.新建测试界面安装好Postman并创建好工作空间之后，来介绍一下如何创建一个测试界面。 点击Postman左上角的汉堡按钮，点击File –&gt; new按钮，选择图中所示的测试类型界面。 3.测试界面介绍如下图所示，是测试要填写的内容。接口名称是为了方便自己区分接口而起的。默认情况下接口名称是测试用的URL地址。 4.添加接口认证账号填充完上图的内容并不能直接调用接口，因为还需要填写PO服务端的认证账号。如果不填写账号就会出现下图所示的返回报文。 认证账号在下图所示的位置。 5.运行的测试结果进行完上面的设置之后，就可以测试看接口是否创建和配置成功。如下图示的内容，返回了报文的内容，则代表接口创建和调用成功了。 五、接口调试1.设置调试账号在开发过程中我们避免不了需要测试接口是否正确执行了或解决没有按照预期的内容进行运行。此时就需要我们对内部的程序进行调试。因为是外部程序调用接口，所以我们就需要设置程序的外部断点。而个人设置的断点也只有个人会生效，但是PO在调用SAP时使用的是SAP分配给PO的账号，如果以个人账号访问是无法使断点相应的。 所以在启用外部断点前需要知道自己的PO系统连接SAP系统的账号是什么。以我的程序为例子，我的账号在报文中体现为WMS的账号。 所以我需要找PO顾问要到PO访问SAP的账号后，在程序的实用程序—&gt;设置打开设置弹框。 在ABAP 编辑器页签转到调试子页签，在用户处填入账号，当系统以你填入的账号调用程序时，若你在调用程序中设置了外部断点，则会进行程序调试界面。 2.添加外部断点进行完上面的操作后，就可以添加外部断点，然后使用Postman调用接口进入调试界面。如果你确认完上面的操作，在调用接口后没有进入调试界面的话，建议看看是不是你断点设置的系统Client是否和PO调用的Client一致。 使用Postman调用接口。 使用Postman调用接口后，Postman会进入下图所示的界面。 SAP GUI端的调试窗口如下。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"RFC PO接口","slug":"ABAP/RFC-PO接口","permalink":"https://www.yemaojun.top/categories/ABAP/RFC-PO%E6%8E%A5%E5%8F%A3/"},{"name":"PO接口","slug":"PO接口","permalink":"https://www.yemaojun.top/categories/PO%E6%8E%A5%E5%8F%A3/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"销售订单抬头与BAPI增强","slug":"ABAP/SAP 增强/销售订单增强/销售订单抬头增强/销售订单抬头增强","date":"2023-09-12T23:45:31.000Z","updated":"2023-10-16T05:49:41.942Z","comments":true,"path":"2023/09/13/ABAP/SAP 增强/销售订单增强/销售订单抬头增强/销售订单抬头增强/","link":"","permalink":"https://www.yemaojun.top/2023/09/13/ABAP/SAP%20%E5%A2%9E%E5%BC%BA/%E9%94%80%E5%94%AE%E8%AE%A2%E5%8D%95%E5%A2%9E%E5%BC%BA/%E9%94%80%E5%94%AE%E8%AE%A2%E5%8D%95%E6%8A%AC%E5%A4%B4%E5%A2%9E%E5%BC%BA/%E9%94%80%E5%94%AE%E8%AE%A2%E5%8D%95%E6%8A%AC%E5%A4%B4%E5%A2%9E%E5%BC%BA/","excerpt":"销售订单抬头的屏幕与BAPI增强过程与行项目的基本一致，只是添加字段的业务表与结构不同而已。","text":"销售订单抬头的屏幕与BAPI增强过程与行项目的基本一致，只是添加字段的业务表与结构不同而已。 销售订单抬头与BAPI增强 一、增强简介对销售订单抬头增强时，需要用的业务表是VBAK。在其中新增一个APPEND结构，将屏幕增强字段填入。 对其BAPI增强用到的结构为：BAPE_VBAK、BAPE_VBAKX、VBAKKOZ与VBAKKOZX。 二、增强步骤1.添加增强字段销售订单抬头增强时需要在VBAK表中新建一个APPEND结构，在其中添加屏幕增强的字段。 新建一个结构，并在其中添加增强字段。 和销售订单行项目增强一样，此处有一个注意事项。在组件类型的Data Element里面需要勾选下面的更改文档复选框，这样后面就可以在BAPI的日志文件中查看这几个增强字段的内容了。 2.添加增强字段赋值到屏幕使用TCODE SE80&#x2F;SE38 打开程序SAPMV45A，打开该程序的8309屏幕。打开布局，在其中添加上增强字段的输入框和文本框等内容。 将增强字段添加到屏幕上。点击弹框左上角样式的按钮，输入VBAK将表中的增强字段填入屏幕。这样的好处是当你维护了增强字段的文本描述之后，此处的文本也会跟着改变。 3.添加屏幕逻辑当我们需要向该屏幕添加逻辑时，PBO的MODULE放到程序：MV45AOZZ中，PAI的MODULE放到程序：MV45AIZZ中。 所以，使用查看的TCODE进入屏幕时，这几个屏幕字段应该设置为不可编辑状态。此段逻辑添加在MV45AOZZ中。 12345678LOOP AT SCREEN. IF sy-tcode = &#x27;VA03&#x27; OR sy-tcode = &#x27;VA23&#x27; OR sy-tcode = &#x27;VA43&#x27;. screen-input = 0. MODIFY SCREEN. ENDIF.ENDLOOP. 三、测试界面使用事务码VA03，进入销售订单界面。然后从转到—》抬头—》更多功能—》附加数据B（或黄色框框中的按钮）。进入屏幕增强的界面，查看增强字段。 四、BAPI结构增强销售订单抬头在屏幕增强之后，如果调用BAPI也想同步更新增强字段的话，则需要在下面的四个结构中将屏幕增强的字段也添加进去。 BAPE_VBAK：客户增强表 VBAK 的 BAPI 界面 BAPE_VBAKX：客户增强表 VBAK 的 BAPI 复选框 VBAKKOZ：抬头的通讯字段：客户修改 VBAKKOZX：抬头中的通讯字段：消费者修改 1.维护BAPE_VBAK操作步骤和向业务表VBAK添加增强结构一样。而且因为维护的字段是一样的，所以可以直接使用业务表VBAK中的Data Element（组件类型）。 2.维护BAPE_VBAKX修改标记结构，类型推荐使用CHAR1或者CHAR01。 3.维护VBAKKOZ维护的方式和上面的BAPE_VBAK一样，将业务表VBAK中的Data Element（组件类型）拿过来直接使用即可。 4.维护VBAKKOZX","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"SAP增强","slug":"ABAP/SAP增强","permalink":"https://www.yemaojun.top/categories/ABAP/SAP%E5%A2%9E%E5%BC%BA/"},{"name":"SAP一代增强","slug":"SAP一代增强","permalink":"https://www.yemaojun.top/categories/SAP%E4%B8%80%E4%BB%A3%E5%A2%9E%E5%BC%BA/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"销售订单行项目屏幕与BAPI增强","slug":"ABAP/SAP 增强/销售订单增强/销售订单行项目增强/销售订单行项目增强","date":"2023-09-07T01:27:53.000Z","updated":"2023-09-18T02:11:45.872Z","comments":true,"path":"2023/09/07/ABAP/SAP 增强/销售订单增强/销售订单行项目增强/销售订单行项目增强/","link":"","permalink":"https://www.yemaojun.top/2023/09/07/ABAP/SAP%20%E5%A2%9E%E5%BC%BA/%E9%94%80%E5%94%AE%E8%AE%A2%E5%8D%95%E5%A2%9E%E5%BC%BA/%E9%94%80%E5%94%AE%E8%AE%A2%E5%8D%95%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%BC%BA/%E9%94%80%E5%94%AE%E8%AE%A2%E5%8D%95%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%BC%BA/","excerpt":"这两天做了个销售订单行项目的屏幕与BAPI增强，使用了一代增强。这里写篇笔记记录一下，然后发现行项目的屏幕增强和销售订单抬头的屏幕增强方式都是一样的，如果后面有条件的话做一篇抬头的增强吧。","text":"这两天做了个销售订单行项目的屏幕与BAPI增强，使用了一代增强。这里写篇笔记记录一下，然后发现行项目的屏幕增强和销售订单抬头的屏幕增强方式都是一样的，如果后面有条件的话做一篇抬头的增强吧。 销售订单行项目屏幕与BAPI增强 一、增强简介对销售订单行项目增强时，需要用的业务表是VBAP。在其中新增一个APPEND结构，将屏幕增强字段填入。 对其BAPI增强用到的结构为：BAPE_VBAP、BAPE_VBAPX、VBAPKOZ与VBAPKOZX。 二、增强步骤1.添加增强字段在销售订单行项目表VBAP点击附加结构，将增强字段添加到Append结构中。 新建一个结构，并在其中添加增强字段。 在这里有一个注意事项，在组件类型的Data Element里面需要勾选下面的更改文档复选框，这样后面就可以在BAPI的日志文件中查看这几个增强字段的内容了。 2.添加增强字段赋值到屏幕使用TCODE SE80&#x2F;SE38 打开程序SAPMV45A。这个程序的来源我会在下面记录如何查找。打开该程序的8459屏幕。打开布局，在其中添加上增强字段的输入框和文本框等内容。 将增强字段添加到屏幕上。 3.添加屏幕逻辑当我们需要向该屏幕添加逻辑时，PBO的MODULE放到程序：MV45AOZZ中，PAI的MODULE放到程序：MV45AIZZ中。 所以，使用查看的TCODE进入屏幕时，这几个屏幕字段应该设置为不可编辑状态。此段逻辑添加在MV45AOZZ中。 12345678910MODULE STATUS_8459 OUTPUT. LOOP AT SCREEN. IF sy-tcode EQ &#x27;VA03&#x27; OR sy-tcode EQ &#x27;VA23&#x27; OR sy-tcode EQ &#x27;VA43&#x27;. screen-input = 0. MODIFY SCREEN. ENDIF. ENDLOOP.ENDMODULE. 三、测试界面使用事务码VA03，进入销售订单界面。然后从转到—》项目—》更多功能—》附加数据B。进入屏幕增强的界面，查看增强字段。 四、查找程序和屏幕用这次增强的内容举例子，我们是对销售订单的屏幕增强。所以需要先使用事务码进入到销售订单的界面。然后进入到想要增强的屏幕中，按照系统 —》状态查看当前的程序名与主屏幕号。 值得注意的是，如果你增强的内容在主屏幕上，那么就已经找到了你要增强的程序和屏幕了。但如果你要增强的东西在子屏幕上，那么就需要你找到子屏幕上的一个组件，然后按F1，打开它的技术信息查看程序和子屏幕号。 五、BAPI结构增强销售订单行项目在屏幕增强之后，如果调用BAPI也想同步更新增强字段的话，则需要在下面的四个结构中将屏幕增强的字段也添加进去。 BAPE_VBAP：客户增强表 VBAP 的 BAPI 界面 BAPE_VBAPX：客户增强表 VBAP 的 BAPI 复选框 VBAPKOZ：项目的通讯字段：客户修改 VBAPKOZX：项目中的通讯字段：消费者修改 1.维护BAPE_VBAP因为维护的字段是一样的，所以可以直接使用业务表VBAP中的Data Element（组件类型）。 2.维护BAPE_VBAPX修改标记结构，类型推荐使用CHAR1或者CHAR01。 3.维护VBAPKOZ维护的方式和上面的BAPE_VBAP一样，将业务表VBAP中的Data Element（组件类型）拿过来直接使用即可。 4.维护VBAPKOZX该结构是VBAPKOZ的修改标记字段，维护方式同上面的BAPE_VBAPX维护方式一样。类型推荐使用CHAR1或者CHAR01。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"SAP增强","slug":"ABAP/SAP增强","permalink":"https://www.yemaojun.top/categories/ABAP/SAP%E5%A2%9E%E5%BC%BA/"},{"name":"SAP一代增强","slug":"SAP一代增强","permalink":"https://www.yemaojun.top/categories/SAP%E4%B8%80%E4%BB%A3%E5%A2%9E%E5%BC%BA/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"代码读取Session日志信息","slug":"ABAP/Session/代码读取Session日志信息/代码读取Session日志信息","date":"2023-08-11T03:13:57.000Z","updated":"2023-08-14T07:33:44.235Z","comments":true,"path":"2023/08/11/ABAP/Session/代码读取Session日志信息/代码读取Session日志信息/","link":"","permalink":"https://www.yemaojun.top/2023/08/11/ABAP/Session/%E4%BB%A3%E7%A0%81%E8%AF%BB%E5%8F%96Session%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF/%E4%BB%A3%E7%A0%81%E8%AF%BB%E5%8F%96Session%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF/","excerpt":"之前在写BDC批量导入笔记的时候，遇到了需要通过代码读取Session日志相关的内容。最后研究了一下发现主要是通过APQI和APQLE这两个数据库获取日志信息。所以此处记录一下读取的过程。","text":"之前在写BDC批量导入笔记的时候，遇到了需要通过代码读取Session日志相关的内容。最后研究了一下发现主要是通过APQI和APQLE这两个数据库获取日志信息。所以此处记录一下读取的过程。 代码读取Session日志信息 一、SM35界面与数据库表间关系通常我们是通过SM35去查看Session日志信息的。图片内容如下所示： 选择想要查看的日志，双击进入查看该Session的日志内容。 而我们需要获取的就是上面的两图中的信息。第一张图的信息存储在数据库表APQI中，可以从该表中查看到执行成功和失败的Message数量，以及后续关联详细Message信息的数据库表APQLE的主键QID值。 下图是数据库表APQI根据Session Name（GROUPID）的值查找出来的Session数据。红框圈起来的部分与第一张图中的事务码、异常、成功和屏幕等信息对应。 第二张图中的详细Message信息则存放在数据库表APQLE中。通过主键QID字段确定一个Session中的所有Message内容。如下图所示。 二、从数据库读取页面内容1.信息获取流程从上面的对应关系我们可以知道想要读取SM35中Session的流程是： 选通过数据库表APQI的主键Group name（GROUPID），查找到自己新建的Session数据的QID 通过上面的QID去数据库表APQLE中查找到自己对应事务码的Message信息 2.Group name再通过代码创建Session会话时，会使用到下面的Function。该Function是用于打开批量输入会话的。在使用过程中需要传入一个GROUP的参数，这个参数对应的就是数据库表APQI的Group name字段。而这个Function还有一个可选的输入参数QID字段。如下图所示。在这里拿到QID的话就可以在后面直接去数据库表APQLE中拿到该Session的Message内容了。 123456789101112131415161718192021222324252627282930313233343536FORM OPEN_GROUP .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;. DATA: LV_HOLDDATE TYPE SY-DATUM, LV_USER TYPE C LENGTH 12.*----------------------------Logic-------------------------------------* LV_USER = SY-UNAME.* LV_HOLDDATE = SY-DATUM. CALL FUNCTION &#x27;BDC_OPEN_GROUP&#x27; EXPORTING CLIENT = SY-MANDT GROUP = LC_GROUP HOLDDATE = LV_HOLDDATE &quot;&#x27; &#x27;=Delete,&#x27;X&#x27;=keep after processing KEEP = GC_X USER = LV_USER EXCEPTIONS CLIENT_INVALID = 1 DESTINATION_INVALID = 2 GROUP_INVALID = 3 GROUP_IS_LOCKED = 4 HOLDDATE_INVALID = 5 INTERNAL_ERROR = 6 QUEUE_ERROR = 7 RUNNING = 8 SYSTEM_LOCK_ERROR = 9 USER_INVALID = 10 OTHERS = 11 . IF SY-SUBRC &lt;&gt; 0. MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4. ENDIF.ENDFORM. 3.通过Group name读取Message如果你无法直接获得QID字段，则可以通过GROUPID字段的值取到QID，然后再通过QID查询到具体的Session的Message内容。 123456789101112131415161718192021222324252627282930FORM GET_SESSION_STATE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;.*----------------------------Logic-------------------------------------* REFRESH:GT_FMESG. SELECT MAX( M~CREDATE ) AS CREDATE, MAX( M~CRETIME ) AS CRETIME, I~MART, I~MID, I~MNR, I~MSGV1, I~MSGV2, I~MSGV3, I~MSGV4 FROM APQI AS M INNER JOIN APQLE AS I ON M~QID = I~QID INTO CORRESPONDING FIELDS OF TABLE @GT_FMESG WHERE M~GROUPID = @LC_GROUP AND I~TCODE = @GC_MM02 AND I~MID &lt;&gt; @GC_NULL GROUP BY I~MART, I~MID, I~MNR, I~MSGV1, I~MSGV2, I~MSGV3, I~MSGV4. IF SY-SUBRC NE 0. &quot;Session尚未运行完成，请等待 MESSAGE S000 WITH TEXT-E04 DISPLAY LIKE GC_E. IF GV_RUNFLAG IS INITIAL. GV_RUNFLAG = GC_X.&quot;仅执行一次的标记 WAIT UP TO 5 SECONDS. PERFORM GET_SESSION_STATE. ELSE. &quot;Session运行异常 MESSAGE S000 WITH TEXT-E05 DISPLAY LIKE GC_E. EXIT. ENDIF. ENDIF.ENDFORM. 4.展示Message内容如果想要将该Message的内容使用弹框的形式展示出来，则可以考虑是下面的方式。 现将获得到的Message放入类型为ESP1_MESSAGE_TAB_TYPE的内表中，最后调用Function C14Z_MESSAGES_SHOW_AS_POPUP，将内容展示出来。 （1）内容转换12345678910111213141516171819202122232425262728293031323334353637*--------------------------Variables-----------------------------------*&quot;全局变量定义DATA: BEGIN OF GS_FMESG, &quot;Session日志的Message结构 MART LIKE APQLE-MART, MID LIKE APQLE-MID, MNR LIKE APQLE-MNR, MSGV1 LIKE APQLE-MSGV1, MSGV2 LIKE APQLE-MSGV2, MSGV3 LIKE APQLE-MSGV3, MSGV4 LIKE APQLE-MSGV4, END OF GS_FMESG, GS_MESSAGEP TYPE ESP1_MESSAGE_WA_TYPE.&quot;最后弹框展示Message的结构DATA: GT_FMESG LIKE TABLE OF GS_FMESG, GT_MESSAGEP TYPE ESP1_MESSAGE_TAB_TYPE.*----------------------------Logic-------------------------------------*FORM SET_MESSAGE_VALUE . CHECK GT_FMESG IS NOT INITIAL. REFRESH: GT_MESSAGEP. CLEAR: GS_MESSAGEP,GS_FMESG. LOOP AT GT_FMESG INTO GS_FMESG. GS_MESSAGEP-LINENO = SY-TABIX. GS_MESSAGEP-MSGID = GS_FMESG-MID. GS_MESSAGEP-MSGNO = GS_FMESG-MNR. GS_MESSAGEP-MSGTY = GS_FMESG-MART. GS_MESSAGEP-MSGV1 = GS_FMESG-MSGV1. GS_MESSAGEP-MSGV2 = GS_FMESG-MSGV2. GS_MESSAGEP-MSGV3 = GS_FMESG-MSGV3. GS_MESSAGEP-MSGV4 = GS_FMESG-MSGV4. INSERT GS_MESSAGEP INTO TABLE GT_MESSAGEP. CLEAR: GS_FMESG,GS_MESSAGEP. ENDLOOP. FREE: GT_FMESG.ENDFORM. （2）调用Message弹框1234567FORM DISPLAY_RESULT . CHECK GT_MESSAGEP IS NOT INITIAL. CALL FUNCTION &#x27;C14Z_MESSAGES_SHOW_AS_POPUP&#x27; TABLES I_MESSAGE_TAB = GT_MESSAGEP. FREE: GT_MESSAGEP.ENDFORM. 5.效果展示（1）SM35界面 （2）程序Message弹框","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Session日志","slug":"ABAP/Session日志","permalink":"https://www.yemaojun.top/categories/ABAP/Session%E6%97%A5%E5%BF%97/"},{"name":"Session","slug":"Session","permalink":"https://www.yemaojun.top/categories/Session/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP BDC批量导入数据","slug":"ABAP/SAP 批量导入数据/BDC批量导入数据/SAP-BDC批量导入数据","date":"2023-08-04T02:12:23.000Z","updated":"2023-08-11T03:11:26.444Z","comments":true,"path":"2023/08/04/ABAP/SAP 批量导入数据/BDC批量导入数据/SAP-BDC批量导入数据/","link":"","permalink":"https://www.yemaojun.top/2023/08/04/ABAP/SAP%20%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/BDC%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/SAP-BDC%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/","excerpt":"在使用BDC录屏的过程中，查了一些资料。发现了一些有意思的东西，比如现在常用的Call Transaction的优缺点和BDC Insert等。BDC在文件服务器上生成的日志文件等操作。现将其记录如下。","text":"在使用BDC录屏的过程中，查了一些资料。发现了一些有意思的东西，比如现在常用的Call Transaction的优缺点和BDC Insert等。BDC在文件服务器上生成的日志文件等操作。现将其记录如下。 SAP BDC批量导入数据 一、BDC简介BDC即Batch Data Conversion。当我们需要大量并且重复的输入保存变更删除数据的操作，且没有对应的BAPI可以使用的时候，可以使用BDC的方式进行。但是如果有可以使用的BAPI的话，则建议优先使用BAPI进行操作。因为BAPI的效率相较于BDC会高一些。 但是BDC相较于LSMW、CATT等其他数据传输方式要更加灵活。 二、创建BDC录屏本次为了和下面BDC日志的优化相匹配，所以从事务码SM35开始介绍。 1.事务码SM35SM35事务码是列出了所有通过BDC所执行的会话记录。 点击上面红色框圈中的记录按钮，会进入事务码SHDB的界面。 2.事务码SHDB点击新建记录按钮，创建BDC录屏。本次使用事务码MM02进行录屏。 3.创建录屏在事务码处填入需要录制的TCODE。在记录处填写本次录屏的名称。 4.事务码选择屏幕填入资产、子编号和公司代码字段的值，然后按回车键。进入资产维护界面。 5.修改物料描述修改完资产描述字段和资产主号文本字段值后点击保存按钮。 6.生成事务记录点击完保存按钮后，系统会将你刚刚的操作生成记录。如下图所示，从上到下是操作的顺序和输入的字段值。 字段名称：屏幕操作中所具体对应的动作。 BDC_CURSOR：当你点击某一个字段或或部分按钮时，对应的字段名称。 BDC_OKCODE：当你触发PAI相关的事件之后，会在字段名称列显示该名称。 BDC_SUBSCR：当你点击某一个页签或切换屏幕时会显示该字段名称，因为该字段名称指代的就是屏幕号字段。 字段指：字段名所对应的参数内容，如按钮的命令、输入框的值等。 确认完生成的记录没有问题之后，点击最上面工具栏中的保存按钮。保存记录流程。 三、生成批量导入程序1.生成批量导入程序点击返回按钮，进入到当前BDC录屏的界面。点击上面的程序按钮，可以生成BDC批量导入数据的程序。 从文件中读取：表示测试数据来自于SAP服务器上的文件。 从记录中传输：表示测试数据来自内存中，比如内表或数据库表等。 测试数据：如果需要生成测试数据文件，则需要设定文件名，将会在服务器上的系统用户文件路径中创建一个数据集文件用于保存测试数据。 点击对勾按钮，设置程序属性。设置完成后点击源代码按钮，既可以查看和修改生成的BDC批导程序代码。 2.生成的核心代码直接生成好的程序还是需要我们再手动对其进行修改，以满足不同的需求。 下面展示一下批导程序中的核心逻辑部分。下图所示的部分就是BDC批导的操作流程，将这些流程全部封装到一个内表中，然后在最后调用事务码，事务码就会按照单步BDC的操作流程对内表中封装的数据进行操作。 3.批导代码讲解（1）BDC_DYNPRO① 含义PERFORM BDC_DYNPRO USING ‘SAPLMGMM’ ‘0060’. 定位到当前屏幕SAPLMGMM程序的 0600 Screen ②源码1234567FORM BDC_DYNPRO USING PROGRAM DYNPRO. CLEAR BDCDATA. BDCDATA-PROGRAM = PROGRAM. BDCDATA-DYNPRO = DYNPRO. BDCDATA-DYNBEGIN = &#x27;X&#x27;. APPEND BDCDATA.ENDFORM. （2）BDC_FIELD① 含义PERFORM BDC_FIELD USING ‘BDC_CURSOR’ ‘RMMG1-MATNR’. 将光标移动到RMMG1-MATNR输入框中。 PERFORM BDC_FIELD USING ‘BDC_OKCODE’ ‘&#x3D;ENTR’. 触发按钮逻辑，按钮事件的Function Code值为 &#x3D;ENTR（回车）。 PERFORM BDC_FIELD USING ‘RMMG1-MATNR’ RECORD-MATNR_001. 在输入框名称为RMMG1-MATNR的屏幕字段中填入RECORD-MATNR_001的变量值。 ② 源码12345678FORM BDC_FIELD USING FNAM FVAL. IF FVAL &lt;&gt; NODATA. CLEAR BDCDATA. BDCDATA-FNAM = FNAM. BDCDATA-FVAL = FVAL. APPEND BDCDATA. ENDIF.ENDFORM. （3）CALL TRANSACTION TCODE下面的内容是我从这篇SAP ABAP BDC 的使用及代码详解内容里面摘抄过来的，这篇笔记的BDC写的很清楚易懂。 1234CALL TRANSACTION TCODE (调用的事务码) USING BDCDATA (创建好的BDC录屏数据 TYPE BDCDATA) OPTIONGS FROM OPTION (调用选项 TYPE CTU_PARAMS) MESSAGE INTO MESSTAB. (成功与否的消息 TYPE BDCMSGCOLL) 上面的结构体变量OPTION封装了MODE和其他属性。下面对其进行简单介绍。 1234OPTION TYPE CTU_PARAMS-DISMODE (E:有错误是跳转前台; A:一直前台执行; N：均后台执行)-UPDMODE(A:异步; S: 同步; L：Local Update)-RACOMMIT (后台遇到commit work代码时是否结束BDC ,赋值为X时不结束。此处在实际业务中经常碰到问题，注意此参数设置) 后续可以使用下面的Function来判断执行的结果是否成功。 12345CALL FUNCTION &#x27;CONERT_BDCMESGCALL_TO_BAPIRET2&#x27; TABLES IMT_BDC_MESGCOLL = lt_mes EXT_RETURN = lt_return根据lt_return的值判断是否执行成功 （4）CALL FUNCTION ‘BDC_INSERT’这是一种不直接运行，而是将BDC程序生成session，但不立即运行，需要手工或通过RSBDCSUB专用程序来运行会话。优点是通过T-code SM35可以进行运行管理及日志管理，方便查错。缺点是相对上面的方法来说实现起来比较繁琐。 该方法的使用流程如下： 需要在程序中调用 function ‘BDC_INSERT’来把BDCDATA生成SESSION。 通过程序RSBDCSUB来执行SESSION（后续建立JOB中使用，目前手动运行会话） 建立BATCH JOB来定期执行RSBDCSUB，从而实现SESSION自动执行的目的 当然，不使用程序RSBDCSUB和JOB，每次手工在SM35中执行SESSION也是可以的。 12345CALL FUNCTION &#x27;BDC_INSERT&#x27; EXPORTING TCODE = &#x27;MM02&#x27; TABLES DYNPROTAB = GT_BDCDATA. 4.程序运行界面 四、BDC测试文件1.文件监视器在前面创建程序时选择了生成测试文件，详见上面的生成批量导入程序中的图片。生成这些文件之后可以对这些文件进行操作。 在SM35的界面点击Recoding或记录按钮，进入SHDB的界面（也可以直接使用事务码SHDB直接进入对应界面）。然后在最上面的Menu按钮中点击转到–&gt;文件监视器打开文件路径列表。 2.测试文件路径SAP会为每个文件夹存放的路径定义一个“目录参数的名称”，如用户所创建的文件存放在SAP应用服务器的“DIR_SAPUSERS”下。 双击可以查看到该文件下的所有文件，比如本次创建的测试数据文件 MM02_BDCLOG_CYH。 双击进入查看测试文件中测试数据的内容。 3.下载测试文件到本地使用事务码CG3Y，将本次的测试文件下载到本地。 4.上传本地文件到服务器使用事务码CG3Z，将在本地的测试文件上传到文件服务器。 五、源码1.全部代码（1）Master Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273*&amp;---------------------------------------------------------------------**&amp; Report ZBDCMM02_CYH*&amp;---------------------------------------------------------------------**&amp; Module / Submodule: ABAP / New Train*&amp;---------------------------------------------------------------------**T_CODE : N/A **CREATER : KF543 **CREATE ON : 2023.08.08 **TYPE : Report **Description : Two Call Methods for Modifying BDC in Material ** Description ************************************************************************** Change History ** -------- ---------- ------------- -----------------------------------** Version Date Change By Description ** -------- ---------- ------------- -----------------------------------** N 2023.08.08 KF543 Creater *************************************************************************REPORT ZBDCMM02_CYH MESSAGE-ID ZMESCLA_CYH.*----------------------------------------------------------------------** Include*----------------------------------------------------------------------*INCLUDE ZBDCMM02_CYH_TOP.INCLUDE ZBDCMM02_CYH_SCR.INCLUDE ZBDCMM02_CYH_CLA.INCLUDE ZBDCMM02_CYH_PBO.INCLUDE ZBDCMM02_CYH_PAI.INCLUDE ZBDCMM02_CYH_F01.*----------------------------------------------------------------------** INITIALIZATION*----------------------------------------------------------------------*INITIALIZATION.*----------------------------------------------------------------------** AT SELECTION-SCREEN OUTPUT*----------------------------------------------------------------------**AT SELECTION-SCREEN OUTPUT.*----------------------------------------------------------------------** AT SELECTION-SCREEN*----------------------------------------------------------------------**AT SELECTION-SCREEN.*----------------------------------------------------------------------** AT SELECTION-SCREEN ON*----------------------------------------------------------------------*AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_FPATH. PERFORM SEARCH_HELP_FPATH CHANGING P_FPATH.*----------------------------------------------------------------------** START-OF-SELECTION*----------------------------------------------------------------------*START-OF-SELECTION. &quot;校验文件路径 PERFORM CHECK_FILE_PATH. &quot;获取Excel中的数据 PERFORM GET_EXCEL_DATA. &quot;校验上传的数据 PERFORM CHECK_UPLOAD_DATA.*----------------------------------------------------------------------** END-OF-SELECTION*----------------------------------------------------------------------*END-OF-SELECTION. &quot;调用BDC PERFORM CALL_BDC. &quot;运行结果 PERFORM DISPLAY_RESULT. （2）Include TOP 全局变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051*&amp;---------------------------------------------------------------------**&amp; 包含 ZBDCMM02_CYH_TOP*&amp;---------------------------------------------------------------------**----------------------------------------------------------------------** Constants*----------------------------------------------------------------------*CONSTANTS: GC_X TYPE C LENGTH 1 VALUE &#x27;X&#x27;, GC_S TYPE C LENGTH 1 VALUE &#x27;S&#x27;, GC_E TYPE C LENGTH 1 VALUE &#x27;E&#x27;, GC_NULL TYPE C LENGTH 1 VALUE &#x27;&#x27;, GC_MM02 TYPE C LENGTH 4 VALUE &#x27;MM02&#x27;.*----------------------------------------------------------------------** Variables*----------------------------------------------------------------------*DATA: GV_RUNFLAG TYPE C, &quot;运行标记，只运行一次的标记 GV_MESSAGE TYPE C. &quot;异常终止代码流程标记*----------------------------------------------------------------------** Structure*----------------------------------------------------------------------*DATA: BEGIN OF GS_TABLE, &quot;存放修改数据的结构，与Excel中结构对应 MATNR LIKE MARA-MATNR, MAKTX LIKE MAKT-MAKTX, END OF GS_TABLE, BEGIN OF GS_FMESG, &quot;Session日志的Message结构 MART LIKE APQLE-MART, MID LIKE APQLE-MID, MNR LIKE APQLE-MNR, MSGV1 LIKE APQLE-MSGV1, MSGV2 LIKE APQLE-MSGV2, MSGV3 LIKE APQLE-MSGV3, MSGV4 LIKE APQLE-MSGV4, END OF GS_FMESG.DATA: GS_BDCTAB TYPE BDCDATA, &quot;存放有BDC操作的结构 GS_MESSAGE TYPE BDCMSGCOLL,&quot;事务码调用返回的Message结构 GS_MESSAGEP TYPE ESP1_MESSAGE_WA_TYPE.&quot;最后弹框展示Message的结构*----------------------------------------------------------------------** Internal Table*----------------------------------------------------------------------*DATA: GT_BDCTAB TYPE TABLE OF BDCDATA,&quot;存放有BDC操作的内表 GT_TABLE LIKE TABLE OF GS_TABLE, GT_FMESG LIKE TABLE OF GS_FMESG, GT_MESSAGE TYPE TABLE OF BDCMSGCOLL, GT_MESSAGEP TYPE ESP1_MESSAGE_TAB_TYPE. （3）Include SCR 选择屏幕123456789101112131415161718192021222324252627282930*&amp;---------------------------------------------------------------------**&amp; 包含 ZBDCMM02_CYH_SCR*&amp;---------------------------------------------------------------------*&quot;执行模式SELECTION-SCREEN BEGIN OF BLOCK K01 WITH FRAME TITLE TEXT-T01.SELECTION-SCREEN BEGIN OF LINE.&quot;执行模式:PARAMETERS: P_TEXT NO-DISPLAY.SELECTION-SCREEN COMMENT 1(23) TEXT-001 FOR FIELD P_TEXT.&quot;调用事务码SELECTION-SCREEN POSITION 32.PARAMETERS: P_TCODE RADIOBUTTON GROUP GR01 USER-COMMAND UC1 DEFAULT &#x27;X&#x27;.SELECTION-SCREEN COMMENT 34(23) TEXT-R01 FOR FIELD P_TCODE.&quot;调用FunctionSELECTION-SCREEN POSITION 57.PARAMETERS: P_CFUNC RADIOBUTTON GROUP GR01 .SELECTION-SCREEN COMMENT 59(20) TEXT-R02 FOR FIELD P_CFUNC.SELECTION-SCREEN END OF LINE.SELECTION-SCREEN END OF BLOCK K01.&quot;上传文件SELECTION-SCREEN BEGIN OF BLOCK K02 WITH FRAME TITLE TEXT-T02.PARAMETERS: P_FPATH TYPE STRING.SELECTION-SCREEN END OF BLOCK K02. （4）Include F01 逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506*&amp;---------------------------------------------------------------------**&amp; 包含 ZBDCMM02_CYH_F01*&amp;---------------------------------------------------------------------**&amp;---------------------------------------------------------------------**&amp; Form SEARCH_HELP_FPATH*&amp;---------------------------------------------------------------------**&amp; text 获取文件上传路径*&amp;---------------------------------------------------------------------**&amp; &lt;-- P_FPATH*&amp;---------------------------------------------------------------------*FORM SEARCH_HELP_FPATH CHANGING VALUE(PV_PATH) TYPE STRING.*--------------------------Variables-----------------------------------* DATA: LV_DEF_PATH TYPE STRING, LT_FILE_TABLE TYPE FILETABLE, LV_RC TYPE I, LV_ACTION TYPE I.*----------------------------Logic-------------------------------------* CLEAR GV_MESSAGE. CL_GUI_FRONTEND_SERVICES=&gt;DIRECTORY_GET_CURRENT( CHANGING CURRENT_DIRECTORY = LV_DEF_PATH ). CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;FILE_OPEN_DIALOG EXPORTING WINDOW_TITLE = &#x27;Upload File&#x27; DEFAULT_EXTENSION = &#x27;xls&#x27; DEFAULT_FILENAME = &#x27;Export&#x27; FILE_FILTER = CL_GUI_FRONTEND_SERVICES=&gt;FILETYPE_EXCEL INITIAL_DIRECTORY = LV_DEF_PATH CHANGING FILE_TABLE = LT_FILE_TABLE RC = LV_RC USER_ACTION = LV_ACTION EXCEPTIONS FILE_OPEN_DIALOG_FAILED = 1 CNTL_ERROR = 2 ERROR_NO_GUI = 3 NOT_SUPPORTED_BY_GUI = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot;Error when uploading the document MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. GV_MESSAGE = GC_X. EXIT. ENDIF. &quot;用户取消上传操作 IF LV_ACTION = CL_GUI_FRONTEND_SERVICES=&gt;ACTION_CANCEL. GV_MESSAGE = GC_X. EXIT. ENDIF. CHECK LT_FILE_TABLE IS NOT INITIAL. READ TABLE LT_FILE_TABLE INTO DATA(LS_FILE) INDEX 1. CHECK SY-SUBRC EQ 0. IF STRLEN( LS_FILE ) GE 128. &quot;The lengtn of file path should be less than 128. &quot;文件路径长度不可大于128 MESSAGE TEXT-E02 TYPE GC_S DISPLAY LIKE GC_E. ELSE. PV_PATH = LS_FILE. TRANSLATE PV_PATH TO UPPER CASE. ENDIF. FREE: LT_FILE_TABLE.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CHECK_FILE_PATH*&amp;---------------------------------------------------------------------**&amp; text 校验上传文件路径或文件格式*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CHECK_FILE_PATH .*--------------------------Variables-----------------------------------* CONSTANTS: LC_DROP TYPE C LENGTH 1 VALUE &#x27;.&#x27;, LC_XLS TYPE C LENGTH 3 VALUE &#x27;XLS&#x27;, LC_XLSX TYPE C LENGTH 4 VALUE &#x27;XLSX&#x27;. DATA: LV_LINES TYPE I, LV_FTYPE TYPE STRING, LT_FTYPE TYPE TABLE OF STRING.*----------------------------Logic-------------------------------------* &quot;根据点区分文件类型 SPLIT P_FPATH AT LC_DROP INTO TABLE LT_FTYPE. &quot;获取最后一行数据Index LV_LINES = LINES( LT_FTYPE ). &quot;获取文件类型 READ TABLE LT_FTYPE INTO LV_FTYPE INDEX LV_LINES. IF SY-SUBRC EQ 0. IF LV_FTYPE NE LC_XLS AND LV_FTYPE NE LC_XLSX. &quot;上传文件类型异常 MESSAGE S000 WITH TEXT-E01 DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. ENDIF. FREE: LT_FTYPE.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form GET_EXCEL_DATA*&amp;---------------------------------------------------------------------**&amp; text 获取Excel中的数据，并调用格式转换Function转换物料编号格式*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM GET_EXCEL_DATA .*--------------------------Variables-----------------------------------* DATA: LV_PATH TYPE RLGRAP-FILENAME, LT_DATA LIKE GT_TABLE, LT_ROWTAB TYPE TRUXS_T_TEXT_DATA.*----------------------------Logic-------------------------------------* REFRESH: GT_TABLE. LV_PATH = P_FPATH. CALL FUNCTION &#x27;TEXT_CONVERT_XLS_TO_SAP&#x27; EXPORTING* I_FIELD_SEPERATOR = I_LINE_HEADER = GC_X I_TAB_RAW_DATA = LT_ROWTAB I_FILENAME = LV_PATH TABLES I_TAB_CONVERTED_DATA = LT_DATA EXCEPTIONS CONVERSION_FAILED = 1 OTHERS = 2. IF SY-SUBRC &lt;&gt; 0. &quot;获取Excel数据失败 MESSAGE S000 WITH TEXT-E02 DISPLAY LIKE GC_E. ENDIF. DELETE ADJACENT DUPLICATES FROM LT_DATA COMPARING MATNR. LOOP AT LT_DATA INTO DATA(LS_DATA). CALL FUNCTION &#x27;CONVERSION_EXIT_MATN1_INPUT&#x27; EXPORTING INPUT = LS_DATA-MATNR IMPORTING OUTPUT = LS_DATA-MATNR EXCEPTIONS LENGTH_ERROR = 1 OTHERS = 2. CLEAR: LS_DATA. ENDLOOP. MOVE-CORRESPONDING LT_DATA TO GT_TABLE. FREE: LT_ROWTAB,LT_DATA.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CHECK_UPLOAD_DATA*&amp;---------------------------------------------------------------------**&amp; text 对上传的数据进行校验，本次为了查看Error信息内容就不写了*&amp; 但是为了提醒这一步在上传过程中不能省略所以留一个空Form*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CHECK_UPLOAD_DATA .*--------------------------Variables-----------------------------------**----------------------------Logic-------------------------------------*ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CALL_BDC*&amp;---------------------------------------------------------------------**&amp; text 编写批量操作流程与数据*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CALL_BDC . REFRESH:GT_MESSAGEP. IF P_CFUNC IS NOT INITIAL. PERFORM OPEN_GROUP. ENDIF. &quot;填充BDC数据 LOOP AT GT_TABLE INTO GS_TABLE. REFRESH: GT_BDCTAB,GT_MESSAGE. PERFORM BDC_DYNPRO USING &#x27;SAPLMGMM&#x27; &#x27;0060&#x27;. PERFORM BDC_FIELD USING &#x27;BDC_CURSOR&#x27; &#x27;RMMG1-MATNR&#x27;. PERFORM BDC_FIELD USING &#x27;BDC_OKCODE&#x27; &#x27;=ENTR&#x27;. PERFORM BDC_FIELD USING &#x27;RMMG1-MATNR&#x27; GS_TABLE-MATNR. PERFORM BDC_DYNPRO USING &#x27;SAPLMGMM&#x27; &#x27;0070&#x27;. PERFORM BDC_FIELD USING &#x27;BDC_CURSOR&#x27; &#x27;MSICHTAUSW-DYTXT(02)&#x27;. PERFORM BDC_FIELD USING &#x27;BDC_OKCODE&#x27; &#x27;=ENTR&#x27;. PERFORM BDC_FIELD USING &#x27;MSICHTAUSW-KZSEL(01)&#x27; &#x27;X&#x27;. PERFORM BDC_FIELD USING &#x27;MSICHTAUSW-KZSEL(02)&#x27; &#x27;X&#x27;. PERFORM BDC_DYNPRO USING &#x27;SAPLMGMM&#x27; &#x27;4004&#x27;. PERFORM BDC_FIELD USING &#x27;BDC_OKCODE&#x27; &#x27;=BU&#x27;. PERFORM BDC_FIELD USING &#x27;BDC_CURSOR&#x27; &#x27;MAKT-MAKTX&#x27;. PERFORM BDC_FIELD USING &#x27;MAKT-MAKTX&#x27; GS_TABLE-MAKTX. &quot;根据选择调用合适的事务码 CASE GC_X. WHEN P_TCODE. &quot;事务码形式调用 PERFORM CALL_TRANSACTION_CODE. WHEN P_CFUNC. &quot;Session形式调用 PERFORM CALL_FUNCTION. WHEN OTHERS. ENDCASE. CLEAR: GS_TABLE. ENDLOOP. IF P_CFUNC IS NOT INITIAL. PERFORM CLOSE_GROUP. PERFORM RUN_SESSION. PERFORM GET_SESSION_STATE. PERFORM SET_MESSAGE_VALUE. ENDIF.ENDFORM.*----------------------------------------------------------------------** Start new screen **----------------------------------------------------------------------*FORM BDC_DYNPRO USING PROGRAM DYNPRO. CLEAR GS_BDCTAB. GS_BDCTAB-PROGRAM = PROGRAM. GS_BDCTAB-DYNPRO = DYNPRO. GS_BDCTAB-DYNBEGIN = &#x27;X&#x27;. APPEND GS_BDCTAB TO GT_BDCTAB.ENDFORM.*----------------------------------------------------------------------** Insert field **----------------------------------------------------------------------*FORM BDC_FIELD USING FNAM FVAL. CLEAR GS_BDCTAB. GS_BDCTAB-FNAM = FNAM. GS_BDCTAB-FVAL = FVAL. APPEND GS_BDCTAB TO GT_BDCTAB.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CALL_TRANSACTION_CODE*&amp;---------------------------------------------------------------------**&amp; text 通过调用事务码形式，执行批量操作*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CALL_TRANSACTION_CODE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_A TYPE C LENGTH 1 VALUE &#x27;A&#x27;, LC_N TYPE C LENGTH 1 VALUE &#x27;N&#x27;. DATA: LS_OPTION TYPE CTU_PARAMS.*----------------------------Logic-------------------------------------* &quot;DISMODE (E:有错误是跳转前台; A:一直前台执行; N：均后台执行) &quot;UPDMODE(A:异步; S: 同步; L：Local Update) &quot;RACOMMIT (后台遇到commit work代码时是否结束BDC ,赋值为X时不结束。此处在实际业务中经常碰到问题，注意此参数设置) &quot;设置属性 LS_OPTION-DISMODE = LC_N. LS_OPTION-UPDMODE = LC_A. LS_OPTION-RACOMMIT = GC_X. CALL TRANSACTION GC_MM02 USING GT_BDCTAB OPTIONS FROM LS_OPTION MESSAGES INTO GT_MESSAGE. IF SY-SUBRC NE 0. &quot;BDC调用失败 MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E.* EXIT. ENDIF. LOOP AT GT_MESSAGE INTO GS_MESSAGE. GS_MESSAGEP-LINENO = SY-TABIX. GS_MESSAGEP-MSGID = GS_MESSAGE-MSGID. GS_MESSAGEP-MSGNO = GS_MESSAGE-MSGNR. GS_MESSAGEP-MSGTY = GS_MESSAGE-MSGTYP. GS_MESSAGEP-MSGV1 = GS_MESSAGE-MSGV1. GS_MESSAGEP-MSGV2 = GS_MESSAGE-MSGV2. GS_MESSAGEP-MSGV3 = GS_MESSAGE-MSGV3. GS_MESSAGEP-MSGV4 = GS_MESSAGE-MSGV4. APPEND GS_MESSAGEP TO GT_MESSAGEP. CLEAR: GS_MESSAGE,GS_MESSAGEP. ENDLOOP.* SORT GT_MESSAGE BY MSGTYP.* READ TABLE GT_MESSAGE INTO GS_MESSAGE WITH KEY MSGTYP = GC_E.* IF SY-SUBRC EQ 0.* MESSAGE ID GS_MESSAGE-MSGID TYPE GC_S NUMBER GS_MESSAGE-MSGNR* WITH GS_MESSAGE-MSGV1 GS_MESSAGE-MSGV2* GS_MESSAGE-MSGV3 GS_MESSAGE-MSGV4* DISPLAY LIKE GC_E.* ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CALL_FUNCTION*&amp;---------------------------------------------------------------------**&amp; text 在批量输入会话中插入批量输入事务*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CALL_FUNCTION .*--------------------------Variables-----------------------------------* DATA: LV_TCODE TYPE TSTC-TCODE.*----------------------------Logic-------------------------------------* LV_TCODE = GC_MM02. CALL FUNCTION &#x27;BDC_INSERT&#x27; EXPORTING TCODE = LV_TCODE* POST_LOCAL = NOVBLOCAL* PRINTING = NOPRINT* SIMUBATCH = &#x27; &#x27;* CTUPARAMS = &#x27; &#x27; TABLES DYNPROTAB = GT_BDCTAB EXCEPTIONS INTERNAL_ERROR = 1 NOT_OPEN = 2 QUEUE_ERROR = 3 TCODE_INVALID = 4 PRINTING_INVALID = 5 POSTING_INVALID = 6 OTHERS = 7. IF SY-SUBRC &lt;&gt; 0. &quot;BDC调用失败 MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E. EXIT. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form DISPLAY_RESULT*&amp;---------------------------------------------------------------------**&amp; text 弹框显示最后的运行结果*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM DISPLAY_RESULT . CHECK GT_MESSAGEP IS NOT INITIAL. CALL FUNCTION &#x27;C14Z_MESSAGES_SHOW_AS_POPUP&#x27; TABLES I_MESSAGE_TAB = GT_MESSAGEP. FREE: GT_MESSAGEP.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form OPEN_GROUP*&amp;---------------------------------------------------------------------**&amp; text 打开批量输入会话*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM OPEN_GROUP .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;. DATA: LV_HOLDDATE TYPE SY-DATUM, LV_USER TYPE C LENGTH 12.*----------------------------Logic-------------------------------------* LV_USER = SY-UNAME.* LV_HOLDDATE = SY-DATUM. CALL FUNCTION &#x27;BDC_OPEN_GROUP&#x27; EXPORTING CLIENT = SY-MANDT GROUP = LC_GROUP HOLDDATE = LV_HOLDDATE &quot;&#x27; &#x27;=Delete,&#x27;X&#x27;=keep after processing KEEP = GC_X USER = LV_USER EXCEPTIONS CLIENT_INVALID = 1 DESTINATION_INVALID = 2 GROUP_INVALID = 3 GROUP_IS_LOCKED = 4 HOLDDATE_INVALID = 5 INTERNAL_ERROR = 6 QUEUE_ERROR = 7 RUNNING = 8 SYSTEM_LOCK_ERROR = 9 USER_INVALID = 10 OTHERS = 11 . IF SY-SUBRC &lt;&gt; 0. MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CLOSE_GROUP*&amp;---------------------------------------------------------------------**&amp; text 关闭批量输入会话*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CLOSE_GROUP . CALL FUNCTION &#x27;BDC_CLOSE_GROUP&#x27; EXCEPTIONS NOT_OPEN = 1 QUEUE_ERROR = 2 OTHERS = 3. IF SY-SUBRC &lt;&gt; 0. MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form RUN_SESSION*&amp;---------------------------------------------------------------------**&amp; text 调用RSBDCSUB执行Session进程*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM RUN_SESSION .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;.*----------------------------Logic-------------------------------------* SUBMIT RSBDCSUB WITH MAPPE EQ LC_GROUP WITH VON EQ SY-DATUM WITH BIS EQ SY-DATUM WITH FEHLER EQ &#x27;.&#x27; EXPORTING LIST TO MEMORY AND RETURN. WAIT UP TO 5 SECONDS.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form GET_SESSION_STATE*&amp;---------------------------------------------------------------------**&amp; text 从数据库表中获取Session日志信息*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM GET_SESSION_STATE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;.*----------------------------Logic-------------------------------------* REFRESH:GT_FMESG. SELECT MAX( M~CREDATE ) AS CREDATE, MAX( M~CRETIME ) AS CRETIME, I~MART, I~MID, I~MNR, I~MSGV1, I~MSGV2, I~MSGV3, I~MSGV4 FROM APQI AS M INNER JOIN APQLE AS I ON M~QID = I~QID INTO CORRESPONDING FIELDS OF TABLE @GT_FMESG WHERE M~GROUPID = @LC_GROUP AND I~TCODE = @GC_MM02 AND I~MID &lt;&gt; @GC_NULL GROUP BY I~MART, I~MID, I~MNR, I~MSGV1, I~MSGV2, I~MSGV3, I~MSGV4. IF SY-SUBRC NE 0. &quot;Session尚未运行完成，请等待 MESSAGE S000 WITH TEXT-E04 DISPLAY LIKE GC_E. IF GV_RUNFLAG IS INITIAL. GV_RUNFLAG = GC_X.&quot;仅执行一次的标记 WAIT UP TO 5 SECONDS. PERFORM GET_SESSION_STATE. ELSE. &quot;Session运行异常 MESSAGE S000 WITH TEXT-E05 DISPLAY LIKE GC_E. EXIT. ENDIF. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SET_MESSAGE_VALUE*&amp;---------------------------------------------------------------------**&amp; text 将Session日志中的Message信息更新到弹框Message的内表中*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SET_MESSAGE_VALUE . CHECK GT_FMESG IS NOT INITIAL. REFRESH: GT_MESSAGEP. CLEAR: GS_MESSAGEP,GS_FMESG. LOOP AT GT_FMESG INTO GS_FMESG. GS_MESSAGEP-LINENO = SY-TABIX. GS_MESSAGEP-MSGID = GS_FMESG-MID. GS_MESSAGEP-MSGNO = GS_FMESG-MNR. GS_MESSAGEP-MSGTY = GS_FMESG-MART. GS_MESSAGEP-MSGV1 = GS_FMESG-MSGV1. GS_MESSAGEP-MSGV2 = GS_FMESG-MSGV2. GS_MESSAGEP-MSGV3 = GS_FMESG-MSGV3. GS_MESSAGEP-MSGV4 = GS_FMESG-MSGV4. INSERT GS_MESSAGEP INTO TABLE GT_MESSAGEP. CLEAR: GS_FMESG,GS_MESSAGEP. ENDLOOP. FREE: GT_FMESG.ENDFORM. 2.事务码调用虽然上面已经给出过所有的代码了，但是此处再单独将事务码调用的代码单独提出来。方便阅读。通过这种形式执行BDC操作十分简便，但是如果想要将在执行的日志信息记录下来的话则需要自己再新建一个日志表，将执行的结果存放到日志表中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*&amp;---------------------------------------------------------------------**&amp; Form CALL_TRANSACTION_CODE*&amp;---------------------------------------------------------------------**&amp; text 通过调用事务码形式，执行批量操作*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CALL_TRANSACTION_CODE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_A TYPE C LENGTH 1 VALUE &#x27;A&#x27;, LC_N TYPE C LENGTH 1 VALUE &#x27;N&#x27;. DATA: LS_OPTION TYPE CTU_PARAMS.*----------------------------Logic-------------------------------------* &quot;DISMODE (E:有错误是跳转前台; A:一直前台执行; N：均后台执行) &quot;UPDMODE(A:异步; S: 同步; L：Local Update) &quot;RACOMMIT (后台遇到commit work代码时是否结束BDC ,赋值为X时不结束。此处在实际业务中经常碰到问题，注意此参数设置) &quot;设置属性 LS_OPTION-DISMODE = LC_N. LS_OPTION-UPDMODE = LC_A. LS_OPTION-RACOMMIT = GC_X. CALL TRANSACTION GC_MM02 USING GT_BDCTAB OPTIONS FROM LS_OPTION MESSAGES INTO GT_MESSAGE. IF SY-SUBRC NE 0. &quot;BDC调用失败 MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E.* EXIT. ENDIF. LOOP AT GT_MESSAGE INTO GS_MESSAGE. GS_MESSAGEP-LINENO = SY-TABIX. GS_MESSAGEP-MSGID = GS_MESSAGE-MSGID. GS_MESSAGEP-MSGNO = GS_MESSAGE-MSGNR. GS_MESSAGEP-MSGTY = GS_MESSAGE-MSGTYP. GS_MESSAGEP-MSGV1 = GS_MESSAGE-MSGV1. GS_MESSAGEP-MSGV2 = GS_MESSAGE-MSGV2. GS_MESSAGEP-MSGV3 = GS_MESSAGE-MSGV3. GS_MESSAGEP-MSGV4 = GS_MESSAGE-MSGV4. APPEND GS_MESSAGEP TO GT_MESSAGEP. CLEAR: GS_MESSAGE,GS_MESSAGEP. ENDLOOP.ENDFORM. 3.通过Session执行本方式的执行过程较为复杂和麻烦，但是优点则是可以制作成一个后台JOB程序定时进行批量操作。他们的日志信息会被存入数据库表APQI和APQLE中。之后可以通过这两个表将日志信息读取出来。或者也可以直接使用事务码SM35去Session界面查看日志信息,如下图所示。 选择要查看的Session信息，然后按照下图所示的内容选择，即可查看到当前Session的日志信息。 下面介绍一下通过Session调用和执行的逻辑添加位置。下图中红框圈出来的就是通过Session调用的代码逻辑。流程是需要先打开批量输入会话 -&gt; 调用BDC_INSERT Function 在批量输入会话中插入批量输入事务 -&gt; 关闭批量输入会话 -&gt; 调用RSBDCSUB程序运行Session（不运行Session的话就一直是一个进程） -&gt; 从数据库中查询Session日志信息 -&gt; 将Session的日志信息放入弹框Message内表中。 （1）打开批量输入会话123456789101112131415161718192021222324252627282930313233343536FORM OPEN_GROUP .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;. DATA: LV_HOLDDATE TYPE SY-DATUM, LV_USER TYPE C LENGTH 12.*----------------------------Logic-------------------------------------* LV_USER = SY-UNAME.* LV_HOLDDATE = SY-DATUM. CALL FUNCTION &#x27;BDC_OPEN_GROUP&#x27; EXPORTING CLIENT = SY-MANDT GROUP = LC_GROUP HOLDDATE = LV_HOLDDATE &quot;&#x27; &#x27;=Delete,&#x27;X&#x27;=keep after processing KEEP = GC_X USER = LV_USER EXCEPTIONS CLIENT_INVALID = 1 DESTINATION_INVALID = 2 GROUP_INVALID = 3 GROUP_IS_LOCKED = 4 HOLDDATE_INVALID = 5 INTERNAL_ERROR = 6 QUEUE_ERROR = 7 RUNNING = 8 SYSTEM_LOCK_ERROR = 9 USER_INVALID = 10 OTHERS = 11 . IF SY-SUBRC &lt;&gt; 0. MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4. ENDIF.ENDFORM. （2）在批量输入会话中插入批量输入事务123456789101112131415161718192021222324252627282930FORM CALL_FUNCTION .*--------------------------Variables-----------------------------------* DATA: LV_TCODE TYPE TSTC-TCODE.*----------------------------Logic-------------------------------------* LV_TCODE = GC_MM02. CALL FUNCTION &#x27;BDC_INSERT&#x27; EXPORTING TCODE = LV_TCODE* POST_LOCAL = NOVBLOCAL* PRINTING = NOPRINT* SIMUBATCH = &#x27; &#x27;* CTUPARAMS = &#x27; &#x27; TABLES DYNPROTAB = GT_BDCTAB EXCEPTIONS INTERNAL_ERROR = 1 NOT_OPEN = 2 QUEUE_ERROR = 3 TCODE_INVALID = 4 PRINTING_INVALID = 5 POSTING_INVALID = 6 OTHERS = 7. IF SY-SUBRC &lt;&gt; 0. &quot;BDC调用失败 MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E. EXIT. ENDIF.ENDFORM. （3）关闭批量输入会话1234567891011FORM CLOSE_GROUP . CALL FUNCTION &#x27;BDC_CLOSE_GROUP&#x27; EXCEPTIONS NOT_OPEN = 1 QUEUE_ERROR = 2 OTHERS = 3. IF SY-SUBRC &lt;&gt; 0. MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4. ENDIF.ENDFORM. （4）调用RSBDCSUB程序运行Session12345678910111213FORM RUN_SESSION .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;.*----------------------------Logic-------------------------------------* SUBMIT RSBDCSUB WITH MAPPE EQ LC_GROUP WITH VON EQ SY-DATUM WITH BIS EQ SY-DATUM WITH FEHLER EQ &#x27;.&#x27; EXPORTING LIST TO MEMORY AND RETURN. WAIT UP TO 5 SECONDS.ENDFORM. （5）获取Session日志信息123456789101112131415161718192021222324252627282930FORM GET_SESSION_STATE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GROUP TYPE C LENGTH 12 VALUE &#x27;INTERNAL_ORD&#x27;.*----------------------------Logic-------------------------------------* REFRESH:GT_FMESG. SELECT MAX( M~CREDATE ) AS CREDATE, MAX( M~CRETIME ) AS CRETIME, I~MART, I~MID, I~MNR, I~MSGV1, I~MSGV2, I~MSGV3, I~MSGV4 FROM APQI AS M INNER JOIN APQLE AS I ON M~QID = I~QID INTO CORRESPONDING FIELDS OF TABLE @GT_FMESG WHERE M~GROUPID = @LC_GROUP AND I~TCODE = @GC_MM02 AND I~MID &lt;&gt; @GC_NULL GROUP BY I~MART, I~MID, I~MNR, I~MSGV1, I~MSGV2, I~MSGV3, I~MSGV4. IF SY-SUBRC NE 0. &quot;Session尚未运行完成，请等待 MESSAGE S000 WITH TEXT-E04 DISPLAY LIKE GC_E. IF GV_RUNFLAG IS INITIAL. GV_RUNFLAG = GC_X.&quot;仅执行一次的标记 WAIT UP TO 5 SECONDS. PERFORM GET_SESSION_STATE. ELSE. &quot;Session运行异常 MESSAGE S000 WITH TEXT-E05 DISPLAY LIKE GC_E. EXIT. ENDIF. ENDIF.ENDFORM. （6）展示Session日志信息12345678910111213141516171819FORM SET_MESSAGE_VALUE . CHECK GT_FMESG IS NOT INITIAL. REFRESH: GT_MESSAGEP. CLEAR: GS_MESSAGEP,GS_FMESG. LOOP AT GT_FMESG INTO GS_FMESG. GS_MESSAGEP-LINENO = SY-TABIX. GS_MESSAGEP-MSGID = GS_FMESG-MID. GS_MESSAGEP-MSGNO = GS_FMESG-MNR. GS_MESSAGEP-MSGTY = GS_FMESG-MART. GS_MESSAGEP-MSGV1 = GS_FMESG-MSGV1. GS_MESSAGEP-MSGV2 = GS_FMESG-MSGV2. GS_MESSAGEP-MSGV3 = GS_FMESG-MSGV3. GS_MESSAGEP-MSGV4 = GS_FMESG-MSGV4. INSERT GS_MESSAGEP INTO TABLE GT_MESSAGEP. CLEAR: GS_FMESG,GS_MESSAGEP. ENDLOOP. FREE: GT_FMESG.ENDFORM. 六、参考资料","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"BDC录屏","slug":"ABAP/BDC录屏","permalink":"https://www.yemaojun.top/categories/ABAP/BDC%E5%BD%95%E5%B1%8F/"},{"name":"批量导入","slug":"批量导入","permalink":"https://www.yemaojun.top/categories/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"Smartform 案例","slug":"ABAP/Smartform 案例与详解/Smartform-案例与详解","date":"2023-07-17T01:05:02.000Z","updated":"2023-08-04T02:29:42.126Z","comments":true,"path":"2023/07/17/ABAP/Smartform 案例与详解/Smartform-案例与详解/","link":"","permalink":"https://www.yemaojun.top/2023/07/17/ABAP/Smartform%20%E6%A1%88%E4%BE%8B%E4%B8%8E%E8%AF%A6%E8%A7%A3/Smartform-%E6%A1%88%E4%BE%8B%E4%B8%8E%E8%AF%A6%E8%A7%A3/","excerpt":"本篇笔记记录一下Smartforms相关技术的内容，供后面学习和参考。","text":"本篇笔记记录一下Smartforms相关技术的内容，供后面学习和参考。 Smartforms 案例 一、Smartform概述1.简介Smartform是在SAPScript的基础上产生的一种新的表单制作方式，它完全兼容SAPScript，但是相较于SAPScript更加的独立，且使用起来更加方便。 2.SAPscript与Smartform区别 Smartform在激活时会自动创建一个功能模块，但是SAPscript不会生成； Smartform可以直接书写子程序，使用程序行节点。而SAPscript则只能使用控制命令语句PERFORM调用SUBROUTINE； SAPscript是基于Client的，而Smartform不区分任何Client； Smartform的字体可使用Color，但是SAPscript不可以； SAPscript的每个page都只能统一按照横向和竖向页面格式，而Smartform则可以不统一格式。 以上内容摘自[SmartForm]SAPscript 与 smartform 区别[转]。 二、Smartform功能介绍1.事务码 Smartforms虽然技术的名称叫做Smartform，但是事务码却是Smartforms。 进入Smartform的界面后在界面上有三个对应的功能对象。 Form：Smartform表单对象 Style：Smartform表单中各类文本对象的样式 Text Module：文本模块 2.Style 文本样式（1）介绍在上图中新建一个Style后会进入到下面的页面中。 在该页面可以设置段落和字体样式，在设置的同时，在最下方也有一个可供预览的窗口。窗口中的内容是可以进行变更的，而你设置的无论是段落的样式还是字体的样式都可以在下方看到具体的变化内容。 接下来对其中的功能进行简单介绍。 标准段落：设置默认的段落格式。当在Smartform中设置了Style但是没有设置段落样式时，使用该样式。 每英寸字符数：设置字符间距，设置逻辑为每英寸中字符数。 制表空格：制表符间距。 每英寸行数：设置行字符间距，设置逻辑为每行中字符数。 字体：设置字体样式，可以通过SE73对SAP中的字体进行维护。 字体大小：设置字体的大小。 字体样式：设置字体的 空(默认)&#x2F;斜体&#x2F;粗体&#x2F;斜粗体。 下划线：文字添加下划线。 颜色：字体颜色。 在创建自定义的段落格式与字符格式时，两者的样式名称只能为2个字符。但是在使用时，会将样式的名称与描述同时显示出来。所以建议在设置自定义样式时写清楚描述内容。 （2）段落格式① 缩进和空格用来自定义控制文本段落样式的功能，和普通的Word文档的段落设置内容类似。可以用来设置段落的对齐方式，默认是居左对齐的方式，此外还有居中、右对齐和已调整的等对齐方式。 ② 字体字体的设置内容与上面介绍的字体样式内容一致，所以此处只展示一下界面。 ③ 标签当某个段落需要分为多个列，而需要设置每个列的宽度与对齐方式时，可以在此处设置。但是Smartform的段落格式可以通过模板或表格来定位，标签的应用一般较少。所以在实际使用过程中使用标签的需求很少，所以也不建议使用。 如上图所示，设置了三个列，均是左对齐，三个列总长为1cm + 2cm + 3cm &#x3D; 6cm。 （3）字符格式① 标准设置在此处可以设置条形码，在名称处选择你上传或需要使用的条形码名称。此外还可以在此处设置字体的上标或下标样式。 ② 字体内容和上面的字体样式设置界面一致，所以此处就只展示一下界面。 3.Text Module 文本模块（1）介绍文本模块主要用于设置一段固定的文本信息，如报表头名称，或者是报表附加条款说明等信息。 （2）文本页签进入后的界面和文本输入界面类似，在其中输入想要展示的文本内容即可。此外可以在后一个页签管理中设置该文本框中文本样式。 （3）管理页签在该页签主要用于设置前面文本输入框属性的样式设置，此处的样式也可以使用自己自定义的Style文本样式，若不设置则会使用系统默认的文本样式SYSTEM。 4.Form 表单（1）介绍打印报表内容的设置，可以在其中设置表格或循环打印数据等。 在新建的Smartform界面中可以分为三个部分，左侧的部分是报表的各项属性与页内容的设置，中间则是Smartform内容的详细设置，而右侧部分则是Smartform内容的预览。 （2）节点元素Form中元素的输出顺序由Pages and Windows（页和窗口）中的后继节点结构和顺序来决定，导航树中的第一个页节点是Form处理的起始页，该节点在Form创建过程中被自动创建。导航树中的所有节点按照从上到下的顺序依次进行处理（包含页和窗口之间的节点）。 除了Pages and Windows（页和窗口）以外，其它所有节点都是可以加上执行条件属性设置的。只要满足的执行条件，则该节点才会被处理。 5.Form 全局设置（1）表格属性此处主要设置报表打印的格式，例如在输出选项中设置打印格式为A4纸的形式或设置报表文本的默认Style样式等。如果在此处设置了Style样式，则在后续的样式使用过程中会默认使用这个样式。 （2）表格接口因为Smartform在最后调用时是通过Function Module的形式调用的，所以在表格接口处用于设置Funtion Module的参数。毕竟打印展示用的数据还需要通过这些参数进行获取和传递。 （3）全局定义此处主要适用于定义Smartform全局变量、类型、初始化逻辑和映射货币或单位字段的位置。在此处设置的类型、变量和常量，在后续的所有节点和子结点中都是可以访问的。 6.页和窗口（1）介绍该功能模块就是用来设置Smartform展示内容的，所有的内容样式展示都是在这里进行设置的。可以在其中添加Page页节点、窗口、图形和地址等节点。然后在这些节点下再添加子元素节点用详细展示内容或进行逻辑处理。 （2）Page 节点每一个Form都至少包含一个页节点。Page节点是Pages and Windows（页和窗口）的子节点，如果某个Page内容超出一页，则会将其他内容输出到Page节点的Next Page属性所指定的页面。每多出来一页内容就会产生分页，一般Next Page分页默认为自己。因为这样的Page节点格式类似，数据循环展示，所以只需要将数据重新加载进Page页自身即可。而如果需要有固定的报表头或报表页脚则需要重新新建Page节点。 此处的Page节点指代的是某一类页面的统称，而这个Page节点的内容则由其下的子节点确定。每Page页面除了通过Next Page静态属性来设置下一页，还可以再通过COMMAND节点的Go To New Page属性来设置。而设置页面跳转的条件则是通过CONDITION条件节点设置的。 （3）窗口节点页面中包含主窗口（Main Windows）和子窗口（Secondary Windows）。其中，主窗口中的数据可以分页展示数据。每个Page节点中只能包含一个主窗口，但是可以有多个子窗口。在分页中，子窗口每次都会出现，就类似于页头和页脚。 一个Smartform中只能顶一个主窗体； 不同的Page上的主窗体必须宽度相同，但是高度可以不相同； 一个没有主窗体的Page指向的下一个页面不能是自身； 窗口中的模板宽度与高度不能超过窗口的宽度与高度，否则显示不出来； 表格的宽度也不能比窗口的宽，否则编译会报错。 （4）图形节点Smartform中可以使用SAP在SE78中上传的图片。 ① 使用SE78上传图片使用TCODE SE78上传图片时，需要先将图片使用系统自带的画图软件将其转化为bmp格式的图片。 然后再使用TCODE SE78，点击上传按钮将图片上传到SE78。 上传成功后会在右侧显示图片的属性等信息。在上传图片时的一些设置也在可以右侧进行修改。 ② Smartform添加图片在Page页&#x2F;窗口界面添加图形，然后拖动图形到界面上合适的位置。 创建完图片并填写完图片的名称等属性后，便可以在最右侧的Smartform预览窗口中看到添加的Image图片。然后可以自己将其拖动到合适的位置。 （5）地址节点地址是经常出现在各种信函中的文本，在Smartform中与文本元素类似，所以可以在输出选项页签中设置样式等。通过地址的好处是保证地址是根据发信人国家的书写规范输出，使用地址节点有一个前提条件，即该用户必须具有SAP CAA的管理员权限，否则只有通过文本节点进行地址添加。 （6）文本节点① 常规属性当需要在Smartform中添加文字或文本内容时就需要使用到文本节点。 Smartform中包含下面类型的文本： 文本元素：使用Smart Form中的PC Editor在Form创建过程中编辑的新文本。 文本模块：独立于Smart Form，可以直接添加至Form，或参照文本模块生成Form文本元素。 包含文本：已经插入设计好的SAPScript标准文本(在SO10中创建，可通过SE75查找)，体现了二者之间的兼容性。 动态文本：传入一个变量，展示的内容与变量值一致。可以参考这一片内容SMARTFORMS 输出动态文本(字符长度超出255)。 ② 输出选项在输出选项中可以对当前文本节点的样式进行设置，此处设置的样式只会在当前文本节点生效。若此处不设置样式，则会使用之前在全局设置中表格属性的样式。 （7）字段列表Smartform自身拥有很多的变量，而当我们在文本节点中需要使用这些变量时，可以通过打开字段列表然后将字段拖进文本节点的方式引入变量。 打开字段列表的方式有三种，一种是直接使用界面上的字段列表打开&#x2F;关闭按钮；或是在最上侧的导航栏中 实用程序-&gt;字段列表打开&#x2F;关闭；第三种则是直接使用快捷方式Crtl + Shift + F4。本片笔记就暂时记录最常使用的第一种方式。 可以在左下角的小窗口中看到Smartform中系统变量、输入参数（导入接口）和输出参数（导出接口）。如果要在文本节点中使用下面的参数可以直接点击要使用的变量然后拖动到文本框中即可。 （8）模板节点模板节点相较于表格节点要更为灵活，模板节点中的单元格可以添加图片和文本等子节点，用于展示图片内容或文本内容。此外模板节点的行高是可以自定义设置的。但是表格节点无法自定义行高或宽。 ① 表绘制器默认为15TW。在实际工作中建议设置为20TW，用来适应针式打印机，激光打印机，喷墨打印机等。因为在实际工作中所使用的打印机不一样，导致有的边框线条打印不出来，所以建议设计成20TW（为临界值）。 ② 模板详细信息例如上图所示，将上面的模板分成两列两行。然后进入详细信息界面对四个格子的列宽和行高进行设置。行定义中的Form和To选项用于指定当前的设置应用于哪些行。行号起始值为1，且行号不能出现间隔和重复。也可以指定Reference的值将其他行的设置应用到当前行。指定引用号后，系统将自动拷贝该行的行高和列宽等到当前行。 ③ 表格与子节点的绑定当你需要将子节点文本节点或图片节点绑定到模板对应的位置，则需要先将子节点放在模板节点下。之后可以在子节点的输出选项页签下通过输出结构设定子节点在模板表格中的位置。 例如我如果想将文本子节点放在模板的第一行第一个格子中，则在下图的行中输入1，列输入1。 （9）表节点表节点与模板类似，但是不同的地方是表节点本身就是为了展示数据而设置的。所以在创建完表节点后需要为表节点设置表头，表体和表的脚注（表头和表的脚注可选，不一定要有）。此外还需要设置表体中的数据源，用于获取展示的数据。 创建好表节点后，在子节点的表页签界面设置列。 在创建表的行子元素节点时会要求设置行类型，也就是上图中划分的列。此时选择好行类型后，会根据行类型中的列数自动生成列子节点，如下图所示。 （10）table和template的区别以下内容是我从百度文库中找到的。 table可以动态添加行，数据输出时会根据列宽自动换行，可以固定列宽，但是默认情况下控制不了行高，如果要像template一样固定行高，需要将table的无换页属性打勾。 template是静态的，固定列宽、行高，当输出数据过长时会自动截断，通常被用于静态表单开发。template跟loop嵌套使用，可以实现固定行高、列宽的表单开发。 三、Smartform实例制作一个下图所示的Smartform，在OOALV的报表中选择想要展示的航班信息。然后进行预览，最后将其下载成PDF文件。 1.设置Style（1）设置Style的默认格式设置此处之后在进入文本节点时，会以该格式为默认的格式设置字体样式。 （2）设置段落格式此处的段落格式和Word中的段落设置内容类似。可以设置其对齐方式、缩进、间距和字体样式等。在设置段落和字符格式时，最好在描述处写上这个段落或字符的样式简介，因为后续在使用时是通过段落与字符的描述对其设置样式的内容进行区分的。 然后我们分别设置左对齐格式、居中加粗（标题用）和普通大小的居中样式。 其他的两个段落样式节点设置原理相同，所以下面只列出节点的样式属性。 D2段落节点： 描述：居中加粗标题 缩进和空格：定中心（居中） 字体： 字体族：COURIER 字体大小：14磅 字体样式：粗体 D3段落节点： 描述：正文居中格式 缩进和空格：定中心（居中） 字体： 字体族：COURIER 字体大小：12磅 （3）设置字符格式想要单独设置字符的样式可以直接添加字符节点，当你只想设置墨迹个字符，或段落中的某一段字符的样式时，可以通古字符子节点实现。字符子节点只能设置字符的样式，所以页签属性相较于段落节点较少。 这次的案例只需要两种样式的字符格式，一种是正文的字符样式，另一种是正文字符的加粗样式。 2.设置Smartform（1）设置全局Style与纸张格式将上面创建好的Style与Smartform的Style绑定。 （2）设置接收展示数据接口变量因为我们需要传递多条数据进来，所以需要在接口的表页签中添加一个表变量。用于传入Smartform展示和打印的数据。本次使用SAP的标准表SFLIGHT作为展示用的表和数据源。 （3）设置全局变量在上面设置了输入数据的表变量，为了能够遍历上面的表变量，所以还需要设置一个与表结构相同的结构体。而后续肯定在编写过程中肯定还会涉及到其他的全局变量。届时再在这里进行介绍。 全局变量介绍： GS_SFLIGHT：IT_DATA相同结构的结构体，用于遍历数据时使用。 GV_FLAG：换页标记变量，当该变量值为X时，会控制主窗口进行换页。 GV_RUNFLAG：用来判断执行与否的标记，用来作为只执行一次逻辑的判断标记。 GV_COUNT：汇总统计展示的数据条数。 （4）创建TABLE（Table分页）① 设置数据源创建完表节点之后会需要你先设置表的数据来源。如下图所示，因为之前添加了一个用于传递输入参数的接口表变量和对应的结构体全局变量，所以此处将这两个变量填入下图所示的输入框，之后再主要区域中会对这个内表中的值进行循环展示。 ② 设置列宽度展开Page节点，在Main主窗口下新建一个Table节点。然后开始为Table节点设置行列属性。 ③ 设置表格边框 设置好的带有边框的单元格四周不再是虚线，可以和上面的图片进行对比可以查看出两者的不同与区别。 ④ 设置填充表头设置表头内容，先设置表的标题，然后再设置打印输出的日期。最后将表头填充进去。 先设置表头，将航班信息四个子通过文本子节点填充进去。 和上面的方式类似，设置表格表头的的第二行，打印时间。 最后再将字段列名设置好，这样表头就设置好了。 ⑤ 设置主要区域（分页逻辑）此区域就是用来展示数据用的循环区域，此处只需要将第一步设置的结构体字段按照需求填入即可。因为在第一部设置的内表会将数据Loop进上面设置的结构体中，所以只此处只需要将结构体的字段变量填入即可自动实现数据的循环展示。但是本次是打算一页展示10条数据，所以还需要对其进行强制分页。 在开发Smartform的时候，有时候会遇上展示或打印的数据在最后一页不够10条的情况。此时会有需求将数据补齐到10条。这部分逻辑因为只执行一次，所以我将其放在了表头区域中的代码行中。并使用GV_RUNFLAG标记来限制其只执行一次。但是在这里的程序行中无法直接使用和访问全局变量，需要通过输入参数和输出参数将全局变量传入才可以使用。 本代码行的输出参数GV_RUNFLAG用来判断下面的逻辑是否只执行了一次。而IT_DATA则是用来获取数据条数的。 在上面设置好补充条数的逻辑之后，就可以在主要区域中设置用来分页的逻辑。在主窗口中的主要区域是数据的循环区域，所以将程序行放在主要区域中，当每展示一行数据就会执行一次在主要区域中设置的程序行和命令。所以可以在其中设置一个用于统计和汇总数据展示条数的变量GV_COUNT，然后使用该变量对10取余，等于0时就可以换页。 换页时将GV_FLAG变量设置为X，不换页时置为空。此外此处补充一点，输入和输出参数可以设置多个，不是只有界面上的两个。点击两个输入框右侧的下拉按钮，可以拉出来新的输入框，在其中设置其余需要设置的输入和输出参数即可。 设置完上面的两段逻辑之后，就可以在主要区域中设置翻页用的命令了。 ⑥ 设置页码和总页数此处因为一直在表格的最下侧，所以将其设置在表节点的脚标处即可。其中的当前页和总页数为系统变量。 因为脚标为一行单元格，所以在行类型处选择表头的TITLE类型即可。 在其中新建一个文本节点，然后将当前页和总页数的系统变量插入。 （5）创建模板（模板分页）此处只作为记录，将模板分页的核心内容和步骤记录如下。但后续的创建新窗口等操作依然是在上面的Table表格分页基础上进行的。即若第四项后续的操作是下面的第六项。 ① 新建抬头窗口 详细信息列表 TABLELINE的详细数据如下： 12 名称 从 至 高度 单位 1 2 3 4 5 6 TABLELINE 3 3 10 MM 2.50 CM 2.50 CM 3.50 CM 2.50 CM 2.50 CM 2.50 CM 在实际效果图中为下图圈中的部分。 ② 创建循环逻辑循环逻辑和表的循环属性设置类似，都是填入循环用的内表和循环的结构体，之后可以在循环中使用结构体中的数据。 ③ 创建行模板行模板需要创建在LOOP循环节点下，且属性设置的内容与上面的TABLELINE属性内容一致。 ④ 编写初始化逻辑和前面Table分页一样，在进入循环之前，编写一些设置初始值的逻辑。或是将数据补充和填充的逻辑写在里面。 其中输入参数为： GV_RUNFLAG：用来判断执行次数的逻辑，主要是用来限制中间逻辑只执行一次 GV_LINES：接口传入的数据IT_DATA经过数据填充后的实际数据条数 IT_DATA：接口中Table页签中设置的用于接收传入展示数据的内表 输出参数和上面的一致。 ⑤ 创建分页命令此处分页命令和Table中的一样，一样是跳转到本页，使用GV_FLAG的作为分页的标记。此外需要注意的是，该命令是放在LOOP循环节点下的。 ⑥ 编写分页逻辑分页逻辑和上面的Table分页逻辑类似，但是不一样的是模板分页逻辑是放在Loop循环节点下的，不是放在模板行节点中。 输入参数为GV_COUNT、GV_FLAG和GV_LINES。除了GV_FLAG是分页的标记外，其余的变量上面都有介绍过，所以就不再介绍了。 输出参数为GV_COUNT和GV_FLAG。 进行完以上的操作后，通过模板实现的循环分页就完成了。最终的实际效果如下： （6）创建新窗口创建一个新窗口，然后创建一个模板，将其分为两行，将打印的标题放进其中。创建好的模板不需要去设置边框，分成两行一列，然后将文本节点的内容放在第二行第一列即可。 设置两行一列的位置。 （7）设置打印Logo这个如果只是粗略的展示图片，则可以考虑将图片节点新建在Page节点下，之后可以在最右侧的预览界面将图片节点拖动到合适的位置即可。 （8）打印预览设置完上面的内容之后就可以去预览界面对Smartform进行预览了。点击上面的执行按钮，系统会根据设计自动生成对应的功能Function，然后运行这个Function，选择打印预览。 预览效果如上图所示。 3.编写打印程序（1）打印预览报表先编写一个OOALV报表程序，展示用于打印的航班表数据。 OOALV报表相关的技术文档可以查看我写的这三篇技术笔记OOALV 基础知识、OOALV 容器和OOALV 事件类。他们介绍了如何创建一个OOALV的报表程序。 我们创建一个下面的报表，并添加两个按钮。一个按钮用于展示你在报表中选中的数据，另一个按钮是将选中的数据以Smartform的样式下载成PDF。 下面是两个按钮的部分逻辑。两个按钮都拥有公共的代码部分，分别是获取打印数据和通过Smartform的名称获取Smartform Function的调用名称。 ① 按钮逻辑1234567891011121314151617181920212223242526272829303132*--------------------------Variables-----------------------------------* CONSTANTS: LC_PRINT TYPE C LENGTH 6 VALUE &#x27;PRINT&#x27;, LC_DOWPDF TYPE C LENGTH 6 VALUE &#x27;DOWPDF&#x27;. DATA: LT_TABLE TYPE TABLE OF YSFLIGHT_CYH, LV_FNAME TYPE RS38L_FNAM.*----------------------------Logic-------------------------------------* CLEAR: GV_MESSAGE. &quot;获取打印用数据 PERFORM GET_PRINT_DATA TABLES LT_TABLE. CHECK GV_MESSAGE IS INITIAL. &quot;Get Smartform Function Name PERFORM GET_SMARTFORM_NAME CHANGING LV_FNAME. CHECK GV_MESSAGE IS INITIAL. CASE PV_UCOMM. WHEN LC_PRINT. &quot;预览Smartform PERFORM UCOMMAND_PRINT TABLES LT_TABLE USING LV_FNAME. WHEN LC_DOWPDF. &quot;下载成PDF PERFORM UCOMMAND_DOWPDF TABLES LT_TABLE USING LV_FNAME. WHEN OTHERS. ENDCASE. &quot;Refresh ALV PERFORM REFRESH_ALV. FREE: LT_TABLE.ENDFORM. ② 获取打印数据——GET_PRINT_DATA1234567891011121314151617181920212223242526272829303132333435363738FORM GET_PRINT_DATA TABLES PT_TABLE STRUCTURE YSFLIGHT_CYH.*--------------------------Variables-----------------------------------* DATA: LT_ROWS TYPE LVC_T_ROW, LS_ROWS TYPE LVC_S_ROW.*----------------------------Logic-------------------------------------* REFRESH: PT_TABLE. &quot;获取选行的索引 IF GO_ALV IS NOT INITIAL. CALL METHOD GO_ALV-&gt;GET_SELECTED_ROWS IMPORTING ET_INDEX_ROWS = LT_ROWS. IF SY-SUBRC NE 0. GV_MESSAGE = GC_X. &quot;请选择要打印的数据 MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E. EXIT. ENDIF. ENDIF. &quot;获取选中的数据 LOOP AT LT_ROWS INTO LS_ROWS. READ TABLE GT_TABLE INTO GS_TABLE INDEX LS_ROWS-INDEX. IF SY-SUBRC EQ 0. MOVE-CORRESPONDING GS_TABLE TO PT_TABLE. APPEND PT_TABLE. ENDIF. CLEAR: LS_ROWS,GS_TABLE,PT_TABLE. ENDLOOP. IF PT_TABLE[] IS INITIAL. GV_MESSAGE = GC_X. &quot;请选择要打印的数据 MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E. ENDIF. FREE: LT_ROWS.ENDFORM. ③ 获取Smartform Function名称——GET_SMARTFORM_NAME12345678910111213141516171819202122232425FORM GET_SMARTFORM_NAME CHANGING VALUE(PV_FNAME) TYPE RS38L_FNAM.*--------------------------Variables-----------------------------------* CONSTANTS: LC_SMARTNAME TYPE TDSFNAME VALUE &#x27;YSMARTFORM0718_CYH&#x27;.*----------------------------Logic-------------------------------------* &quot;Get Smartform Function CALL FUNCTION &#x27;SSF_FUNCTION_MODULE_NAME&#x27; EXPORTING* FORMNAME = LC_SMARTNAME FORMNAME = &#x27;YSMARTFORM0718_CYH&#x27;* VARIANT = &#x27; &#x27;* DIRECT_CALL = &#x27; &#x27; IMPORTING FM_NAME = PV_FNAME EXCEPTIONS NO_FORM = 1 NO_FUNCTION_MODULE = 2 OTHERS = 3. IF SY-SUBRC &lt;&gt; 0 OR PV_FNAME IS INITIAL. GV_MESSAGE = GC_X. &quot;获取Smartform Function名称异常 MESSAGE S000 WITH TEXT-E01 DISPLAY LIKE GC_E. EXIT. ENDIF.ENDFORM. （2）展示表格逻辑逻辑流程是选择想要在Smartform上展示的数据，然后通过Smartform的名称获取到动态的Function名称。通过这个名称调用展示Smartform。 调用Smartform的逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647FORM UCOMMAND_PRINT TABLES PT_TABLE STRUCTURE YSFLIGHT_CYH &quot;展示用数据 USING VALUE(PV_FNAME) TYPE RS38L_FNAM. &quot;Smartform Function名称*--------------------------Variables-----------------------------------* DATA: LS_SSFCRESOP TYPE SSFCRESOP, LS_SSFCRESCL TYPE SSFCRESCL, LS_SSFCTRLOP TYPE SSFCTRLOP, &quot;打印参数 LS_SSFCOMPOP TYPE SSFCOMPOP. &quot;弹出框参数*----------------------------Logic-------------------------------------* &quot;Set Printing Parameters &quot;No pop-up window 无弹窗 LS_SSFCTRLOP-NO_DIALOG = GC_X. &quot;预览 LS_SSFCTRLOP-PREVIEW = GC_X. &quot;Output参数 LS_SSFCOMPOP-TDDEST = &#x27;SAP&#x27;. &quot;调用Smartform CALL FUNCTION PV_FNAME EXPORTING* ARCHIVE_INDEX =* ARCHIVE_INDEX_TAB =* ARCHIVE_PARAMETERS = CONTROL_PARAMETERS = LS_SSFCTRLOP* MAIL_APPL_OBJ =* MAIL_RECIPIENT =* MAIL_SENDER = OUTPUT_OPTIONS = LS_SSFCOMPOP* USER_SETTINGS = &#x27;X&#x27; IMPORTING* DOCUMENT_OUTPUT_INFO = JOB_OUTPUT_INFO = LS_SSFCRESCL JOB_OUTPUT_OPTIONS = LS_SSFCRESOP TABLES IT_DATA = PT_TABLE[] EXCEPTIONS FORMATTING_ERROR = 1 INTERNAL_ERROR = 2 SEND_ERROR = 3 USER_CANCELED = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot;调用Smartform 异常 MESSAGE S000 WITH TEXT-E02 DISPLAY LIKE GC_E. EXIT. ENDIF.ENDFORM. （3）下载为PDF文件下载为PDF的逻辑分为以下几个步骤。 获取需要下载成PDF的数据（上面的GET_PRINT_DATA） 获取Smartform的Function名称（上面的GET_SMARTFORM_NAME） 调用Smartform的Function获取OTF数据 将OTF数据转换为二进制数据 获取下载PDF的路径 下载成PDF文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124FORM UCOMMAND_DOWPDF TABLES PT_TABLE STRUCTURE YSFLIGHT_CYH USING VALUE(PV_FNAME) TYPE RS38L_FNAM.*--------------------------Variables-----------------------------------* DATA: LV_SSFCRESPD TYPE SSFCRESPD, LS_SSFCRESCL TYPE SSFCRESCL, LS_SSFCRESOP TYPE SSFCRESOP, LS_SSFCTRLOP TYPE SSFCTRLOP, &quot;打印参数 LS_SSFCOMPOP TYPE SSFCOMPOP. &quot;弹出框参数 &quot;下载PDF数据 DATA: LV_PDFDATA TYPE XSTRING, LV_PDFLINE TYPE I, LV_FILELENGTH TYPE I. DATA: LS_DOCTABLE TYPE DOCS, LT_DOCTABLE TYPE TABLE OF DOCS, &quot;DOC LT_PDFTABLE TYPE TABLE OF TLINE. &quot;转换为PDF数据 &quot;下载地址 DATA: LV_POST TYPE STRING.*----------------------------Logic-------------------------------------* &quot;获取下载位置 PERFORM GET_DOWNLOAD_POST CHANGING LV_POST. CHECK GV_MESSAGE IS INITIAL. &quot;设置打印参数 &quot;无弹窗 LS_SSFCTRLOP-NO_DIALOG = GC_X. &quot;获取OTF数据，不print,fax,display LS_SSFCTRLOP-GETOTF = GC_X. &quot;调用Smartform，生成PDF所需要的OTF数据 CALL FUNCTION PV_FNAME EXPORTING* ARCHIVE_INDEX =* ARCHIVE_INDEX_TAB =* ARCHIVE_PARAMETERS = CONTROL_PARAMETERS = LS_SSFCTRLOP* MAIL_APPL_OBJ =* MAIL_RECIPIENT =* MAIL_SENDER = OUTPUT_OPTIONS = LS_SSFCOMPOP* USER_SETTINGS = &#x27;X&#x27; IMPORTING* DOCUMENT_OUTPUT_INFO = JOB_OUTPUT_INFO = LS_SSFCRESCL JOB_OUTPUT_OPTIONS = LS_SSFCRESOP TABLES IT_DATA = PT_TABLE[] EXCEPTIONS FORMATTING_ERROR = 1 INTERNAL_ERROR = 2 SEND_ERROR = 3 USER_CANCELED = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot;OTF数据生成异常 MESSAGE S000 WITH TEXT-E04 DISPLAY LIKE GC_E. EXIT. ENDIF. &quot;OTF数据转换为PDF二进制文件 CALL FUNCTION &#x27;CONVERT_OTF&#x27; EXPORTING FORMAT = &#x27;PDF&#x27; MAX_LINEWIDTH = 132 TABLES OTF = LS_SSFCRESCL-OTFDATA[] LINES = LT_PDFTABLE EXCEPTIONS ERR_MAX_LINEWIDTH = 1 ERR_FORMAT = 2 ERR_CONV_NOT_POSSIBLE = 3 ERR_BAD_OTF = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot;OTF数据转换为PDF异常 MESSAGE S000 WITH TEXT-E05 DISPLAY LIKE GC_E. EXIT. ENDIF. &quot;下载PDF CALL FUNCTION &#x27;GUI_DOWNLOAD&#x27; EXPORTING BIN_FILESIZE = LV_PDFLINE FILENAME = LV_POST FILETYPE = &#x27;DAT&#x27; IMPORTING FILELENGTH = LV_FILELENGTH TABLES DATA_TAB = LT_PDFTABLE EXCEPTIONS FILE_WRITE_ERROR = 1 NO_BATCH = 2 GUI_REFUSE_FILETRANSFER = 3 INVALID_TYPE = 4 NO_AUTHORITY = 5 UNKNOWN_ERROR = 6 HEADER_NOT_ALLOWED = 7 SEPARATOR_NOT_ALLOWED = 8 FILESIZE_NOT_ALLOWED = 9 HEADER_TOO_LONG = 10 DP_ERROR_CREATE = 11 DP_ERROR_SEND = 12 DP_ERROR_WRITE = 13 UNKNOWN_DP_ERROR = 14 ACCESS_DENIED = 15 DP_OUT_OF_MEMORY = 16 DISK_FULL = 17 DP_TIMEOUT = 18 FILE_NOT_FOUND = 19 DATAPROVIDER_EXCEPTION = 20 CONTROL_FLUSH_ERROR = 21 OTHERS = 22. IF SY-SUBRC &lt;&gt; 0. &quot;PDF 下载失败 MESSAGE S000 WITH TEXT-E08 DISPLAY LIKE GC_E. EXIT. ENDIF.ENDFORM. ① 获取下载PDF的路径123456789FORM GET_DOWNLOAD_POST CHANGING VALUE(PV_FULLPATH) TYPE STRING. CLEAR: GV_MESSAGE. &quot;Get download path PERFORM GET_DOWNLOAD_FILE CHANGING PV_FULLPATH. CHECK GV_MESSAGE IS INITIAL. &quot;Check that download files exist,and if they do,delete &quot;PERFORM CHECK_FILE_EXIS USING PV_FULLPATH.ENDFORM. 1234567891011121314151617181920212223242526272829303132333435363738394041424344FORM GET_DOWNLOAD_FILE CHANGING VALUE(PV_PATH) TYPE STRING.*---------------------------Variables----------------------------* CONSTANTS: LC__ TYPE C LENGTH 1 VALUE &#x27;_&#x27;. DATA: LV_FNAME TYPE STRING, LV_PATH TYPE STRING, LV_FILENAME TYPE STRING, LV_TYPENAME TYPE STRING VALUE &#x27;pdf&#x27;, LV_TITLE TYPE STRING VALUE &#x27;PDF Downolad&#x27;.*-----------------------------Logic------------------------------* &quot;Set Download file Name CONCATENATE GV_TITLE SY-DATUM SY-UZEIT INTO LV_FILENAME SEPARATED BY LC__. &quot;Gets the current default path. CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;DIRECTORY_GET_CURRENT CHANGING CURRENT_DIRECTORY = PV_PATH. &quot;Shell selection save path CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;FILE_SAVE_DIALOG EXPORTING WINDOW_TITLE = LV_TITLE DEFAULT_EXTENSION = LV_TYPENAME DEFAULT_FILE_NAME = LV_FILENAME FILE_FILTER = CL_GUI_FRONTEND_SERVICES=&gt;FILETYPE_ALL INITIAL_DIRECTORY = PV_PATH CHANGING FILENAME = LV_FNAME PATH = LV_PATH FULLPATH = PV_PATH EXCEPTIONS CNTL_ERROR = 1 ERROR_NO_GUI = 2 NOT_SUPPORTED_BY_GUI = 3 OTHERS = 5. IF PV_PATH IS INITIAL. GV_MESSAGE = GC_X. &quot;PDF下载路径获取失败 MESSAGE S000 WITH TEXT-E08 DISPLAY LIKE GC_E. EXIT. ENDIF.ENDFORM. 四、Smartform其余内容汇总1.Smartform系统参数 字段名称&#x2F;SFSY 变量含义 PAGE 当前页号&#x2F;页数 FORMPAGES 表格总页数 JOBPAGES 打印作业的总页数 COPYCOUNT 复制计数器（1&#x3D;原文，2&#x3D;第一个拷贝，…） COPYCOUNT0 复制计数器（0&#x3D;原文，1&#x3D;第一个拷贝，…） DATE 系统日期 TIME 系统时间 SUBRC 返回码 USERNAME 用户名 PAGENAME 页名称 WINDOWNAME 窗口名称 XSF XSF输出活动&#x2F;未激活 XDF SAP Smart Forms：XDF输出活动 XDF2 SAP Smart Forms：XDF输出活动 2.常用打印参数介绍（1）对话框参数12345DATA: LS_SSFCOMPOP TYPE SSFCOMPOP.LS_SSFCOMPOP-TDDEST = &#x27;LP01&#x27;. &quot;打印设备LS_SSFCOMPOP-TDPAGESLCT = &#x27;1,2,4&#x27;. &quot;打印的页数，多页使用逗号进行分割LS_SSFCOMPOP-TDNOPREV = &#x27;X&#x27;. &quot;隐藏打印预览按钮 （2）控制对话框参数1234DATA: LS_SSFCTRLOP TYPE SSFCTRLOP.LS_SSFCTRLOP-NO_DIALOG = &#x27;X&#x27;. &quot;打印前不显示打印对话框LS_SSFCTRLOP-PREVIEW = &#x27;X&#x27;. &quot;直接展示预览界面 3.一次性输出多张报表有时候需要一次性打印多张不同的报表，直接调用Smartform时，每次打印一张报表后，会在循环中反复出现打印对话框，影响程序执行效率。SAP打印控制提供了假脱机功能，允许将多张需要打印的报表缓存。最后再一次性提交打印请求。 12345678910111213141516171819202122232425262728293031FORM CALL_SMARTFORM. DATA: LV_FNAME TYPE RS381_FNAM, LS_SSFCTRLOP TYPE SSFCTRLOP. DO 3 TIMES. CASE SY-INDEX. WHEN 1. LS_SSFCTRLOP-NO_OPEN = SPACE. &quot;首次运行时打开打印对话框 LS_SSFCTRLOP-NO_CLOSE = &#x27;X&#x27;. &quot;并且不关闭假脱机请求 WHEN 2. LS_SSFCTRLOP-NO_OPEN = &#x27;X&#x27;. LS_SSFCTRLOP-NO_CLOSE = &#x27;X&#x27;. WHEN 3. LS_SSFCTRLOP-NO_OPEN = &#x27;X&#x27;. LS_SSFCTRLOP-NO_CLOSE = SPACE.&quot;最后关闭假脱机准备打印 ENDCASE. &quot;调用Function通过SMartform Name获取Smartform Function CALL FUNCTION &#x27;SSF_FUNCTION_MODULE_NAME&#x27; EXPORTING FORMNAME = &#x27;Smartform Name&#x27; IMPORTING FM_NAME = LV_FNAME. &quot;调用Smartform CALL FUNCTION LV_FNAME EXPORTING CONTROL_PARAMETERS = LS_SSFCTRLOP. ENDDO.ENDFORM. 4.转换PDF乱码问题将Smartform转换为PDF文件时或许会出现乱码等问题。此时使用TCODE：SPAD（假脱机管理工具）设置打印设备类型为CN开头的类型即可。之后在程序和Smartform中使用这个设备即可。 5.自定义页格式（1）设置纸张格式对于Smartform打印的纸张等问题，除了可以使用SAP自带的国际上标准的A4等纸张格式外，还可以在TCODE：SPAD中设置打印纸张的格式。 先点击上面的完全管理按钮，调出剩下的设备管理页签。 之后点击设备类型，在下方的页格式处设置页面格式。 （2）设置格式类型在上面设置完纸张格式并没办法直接调用使用，还需要设置该纸张格式的类型用于限制调用的程序类型。 在同一个页签中的格式类型中，输入格式类型名。然后选择类型。 其中S SAPscript的格式类型是在Smartform中使用的格式类型，L ABAP列表的格式类型则是在ALV报表中使用的格式。 （3）分配页格式到指定的设备定义好上面的页格式和格式类型之后还需要将页格式分配到指定的设备，可以理解成是相互绑定。每个输出设备需要设定设备类型。所以当打印时，只有属于该打印设备的页格式才能被操作。若没有维护的话，预览不会存在问题，但在选择打印时，系统提示错误。 目前对中文输出所使用的设备类型大部分都默认为“CNSAPWIN”，在“设备类型”中输入“CNSAPWIN”，再点击“显示”，出现以下界面： 进入下面的界面后，点击上面的创建按钮。将自己之前创建的格式类型填入，此处填入的是格式类型，这一点需要注意。 点击上面的对勾按钮后进入下面的界面。之后需要对打印机操作维护基本的指令，没维护指令时，操作该类型的报表数据可能会出现打印机不切纸或者不执行打印问题。需维护的指令和打印机的驱动存在关系，可以参照CNSAPWIN下已经维护好的格式类型来维护。 以SAP标准的A4纸张（DINA4）为例，一般需要维护操作包括：打印初始化、尾页、行结束，如： 之后就可以在Smartform中使用自己的页格式了。 五、参考资料Smart Forms&amp;ScriptFrom ABAP Smartforms SAP中SmartForms报表工具的使用，一个简单的报表Demo","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Smartforms","slug":"ABAP/Smartforms","permalink":"https://www.yemaojun.top/categories/ABAP/Smartforms/"},{"name":"SAP打印","slug":"SAP打印","permalink":"https://www.yemaojun.top/categories/SAP%E6%89%93%E5%8D%B0/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"ABAP 字符串操作详解","slug":"ABAP/ABAP基础/ABAP 字符串操作详解/ABAP-字符串操作详解","date":"2023-07-12T08:43:44.000Z","updated":"2024-08-20T05:13:30.254Z","comments":true,"path":"2023/07/12/ABAP/ABAP基础/ABAP 字符串操作详解/ABAP-字符串操作详解/","link":"","permalink":"https://www.yemaojun.top/2023/07/12/ABAP/ABAP%E5%9F%BA%E7%A1%80/ABAP%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/ABAP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/","excerpt":"本篇笔记主要用于记录ABAP开发过程中常用的字符串操作。其中除了常规的操作外还涉及到CO、CN、CA、NA、CS、NS、CP和NP等相关的内容。","text":"本篇笔记主要用于记录ABAP开发过程中常用的字符串操作。其中除了常规的操作外还涉及到CO、CN、CA、NA、CS、NS、CP和NP等相关的内容。 ABAP 字符串操作详解 一、获取字符串长度1.介绍用于获取常见的字符串长度，语法有两种。 STRLEN( str )，变量与括号之间需要有空格进行区分 DESCRIBE FIND &lt;字符串&gt; LENGTH &lt;数值变量&gt; [IN BYTE | CHARACTER MODE] 2.语法结构12345&quot;获取变量内容的长度STRLEN( str ).&quot;获取变量定义的长度DESCRIBE FIND &lt;字符串&gt; LENGTH &lt;数值变量&gt; [IN BYTE | CHARACTER MODE] 3.语法解释与应用（1）STRLEN( str )通过这种方式获取到的字符串长度是字符串内容的实际长度，即便定义的字符串长度固定为80，他返回的也是字符串中实际值的长度。 1234567891011121314151617181920212223DATA: LV_LENGTH TYPE I, LV_STRING1 TYPE STRING VALUE &#x27;Learn from yesterday, live for today, hope for tomorrow.&#x27;， LV_STRING2 TYPE STRING VALUE `Don&#x27;t look back, just haven&#x27;t found leave your reasons.`.WRITE:/ &#x27;STRLEN 语法测试，第一个语句为String类型，第二个为Char80&#x27;.WRITE:/.LV_LENGTH = STRLEN( LV_STRING1 ).WRITE:/ LV_STRING1.WRITE:/ &#x27;上述短文的长度为： &#x27;,LV_LENGTH.LV_LENGTH = STRLEN( LV_STRING2 ).WRITE:/ LV_STRING2.WRITE:/ &#x27;上述短文的长度为： &#x27;,LV_LENGTH.&quot;运行结果：&quot;STRLEN 语法测试，第一个语句为String类型，第二个为Char80&quot;Learn from yesterday, live for today, hope for tomorrow.&quot;上述短文的长度为： 54&quot;Don&#x27;t look back, just haven&#x27;t found leave your reasons.&quot;上述短文的长度为： 54 （2）DESCRIBE通过这种方式只能获取固定长度变量的定义的长度，无法获取到变量中存在的值的长度。拥有两种获取长度的方式。一种是获取位的长度（IN BYTE MODE）；一种是获取变量定义的字符长度（IN CHARACTER MODE）。但是获取字符长度的定一个是无法应用于String类型的变量。因为其是不定长的，但是获取位长度的方式可以获取到String类型变量的系统默认位长度为8. 12345678910111213141516171819202122232425262728293031DATA: LV_LENGTH TYPE I, LV_STRING1 TYPE STRING VALUE &#x27;Learn from yesterday, live for today, hope for tomorrow.&#x27;， LV_STRING2 TYPE STRING VALUE `Don&#x27;t look back, just haven&#x27;t found leave your reasons.`. WRITE:/ &#x27;DESCRIBE FIELD 语法测试，第一个语句为String类型，第二个为Char80&#x27;.WRITE:/.&quot;这种方式获取的是定义的变量长度，若值的长度小于定义长度，系统会自动填充到指定长度DESCRIBE FIELD LV_STRING1 LENGTH LV_LENGTH IN BYTE MODE.WRITE:/ LV_STRING1.WRITE:/ &#x27;位长度，上述短文的长度为： &#x27;,LV_LENGTH.DESCRIBE FIELD LV_STRING2 LENGTH LV_LENGTH IN BYTE MODE.WRITE:/ LV_STRING2.WRITE:/ &#x27;位长度，上述短文的长度为： &#x27;,LV_LENGTH.&quot;这种形式的获取长度方式无法获取String类型变量的长度，所以只能获取固定长度类型变量的定义时的长度DESCRIBE FIELD LV_STRING2 LENGTH LV_LENGTH IN CHARACTER MODE.WRITE:/ LV_STRING2.WRITE:/ &#x27;字符长度，上述短文的长度为： &#x27;,LV_LENGTH.&quot;运行结果：&quot;DESCRIBE FIELD 语法测试，第一个语句为String类型，第二个为Char80&quot;Learn from yesterday, live for today, hope for tomorrow.&quot;位长度，上述短文的长度为： 8&quot;Learn from yesterday, live for today, hope for tomorrow.&quot;位长度，上述短文的长度为： 160&quot;Don&#x27;t look back, just haven&#x27;t found leave your reasons.&quot;字符长度，上述短文的长度为： 80 二、查找字符串 Find1.介绍Find关键字用于查询特定字符或字符串是否存在于字符串，也可以查找字符是否存在于内表。使用系统变量 SY-SUBRC 来获取查询结果。若系统变量为0则查找到相关内容，反之若为4则没有查找到。并且使用该语句查询的字符是默认严格区分大小写的，若存在相同的字符，但是大小写不一致也是会按照没有查找到数据返回的。当然这只是默认的情况，也可以通过下面介绍的关键词IGNORING CASE来取消区分大小写。此外还有一个SAP已经淘汰的查询关键词Search关键字，其效果和Find类似，依然可以在SAP中使用。 2.语法结构1234567891011121314151617FIND [&#123;FIRST OCCURRENCE&#125; | &#123;ALL OCCURRENCES&#125; OF] pattern(查找的内容) IN [section of] dobj [&#123;RESPECTING | IGNORING&#125; CASE] [MATCH COUNT mcnt] | &#123; &#123;[MATCH OFFSET moff] [MATCH LENGTH mlen]&#125; | [RESULTS result_tab | result_wa] &#125; [SUBMATCHES s1 s2 ...] ...search &lt;被操作字符串&gt; for &lt;子串&gt;[in (byte|character) mode][starting at &lt;数字&gt;][ending at &lt;数字&gt;][ABBREVIATED][and mark] Starting at:指定查询范围 Ending at :指定查询范围&quot;查找字符串中是否有对应子串，如果查找到sy-subrc = 0,没找到sy-subrc=4。在sy-fdpos中存放查找到子串字符开始位置 3.语法解释与应用（1）仅查找 FIND主要用于在字符串中查找对应的内容 1234567891011121314151617181920DATA: LV_FIND TYPE STRING VALUE &#x27;AA&#x27;, LV_STRING0 TYPE STRING VALUE &#x27;DHFIOASDHFJKAASHDFIUASHDFPAASDFJHASIFHDFJKLGSDJIKFGN&#x27;, LV_STRING4 TYPE STRING VALUE &#x27;AHDFGIUFHASIOUDFHASDHFFHFHAIOSDFHFHAKLSJDFHKJLASHDFD&#x27;.FIND LV_FIND IN LV_STRING0.IF SY-SUBRC EQ 0. WRITE:/ &#x27;查找到了&#x27;.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果： 查找到了FIND LV_FIND IN LV_STRING4.IF SY-SUBRC EQ 0. WRITE:/ &#x27;查找到了&#x27;.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果： 未查找到 （2）查找位置与长度信息 MATCH OFFSET &#x2F; LENGTH可以使用MATCH OFFSET 和 MATCH LENGTH 关键词获取查找内容的位置与长度。若未查找数据，则不会更新MATCH OFFSET 和 MATCH LENGTH 关键词后接受位置信息与长度信息的变量，所以在使用前请清空用于存放位置信息与长度信息的变量。 12345678910111213141516171819202122232425&quot;沿用上面的变量DATA: LV_POSTION TYPE I, LV_LENGTH TYPE I. FIND LV_FIND IN LV_STRING0 MATCH OFFSET LV_POSTION MATCH LENGTH LV_LENGTH.IF SY-SUBRC EQ 0. WRITE:/ &#x27;位置为： &#x27;, LV_POSTION, &#x27;长度为： &#x27;, LV_LENGTH.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果： 位置为： 12 ， 长度为： 2CLEAR: LV_POSTION,LV_LENGTH. &quot;使用之前需要清空位置与长度变量，因为查找失败之后并不会修改LV_POSTION,LV_LENGTH的变量值，这两个变量还是原先的值FIND LV_FIND IN LV_STRING0 MATCH OFFSET LV_POSTION MATCH LENGTH LV_LENGTH.IF SY-SUBRC EQ 0. WRITE:/ &#x27;位置为： &#x27;, LV_POSTION, &#x27;长度为： &#x27;, LV_LENGTH.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果： 未查找到 （3）查找并返回出现次数 MATCH COUNT使用MATCH COUNT关键词，当查询到相对应的内容时会返回对应内容出现的次数。另外值得注意的是和上面获取位置与长度信息类似，在使用获取查找内容次数的变量前需要清空，不然变量会延续上一次的值，可能会造成逻辑异常。 12345678910111213141516171819202122&quot;沿用上面的变量DATA: LV_COUNT TYPE I. FIND ALL OCCURRENCES OF LV_FIND IN LV_SRING0 MATCH COUNT LV_COUNT.IF SY-SUBRC EQ 0. WRITE:/ &#x27;出现次数为： &#x27;, LV_COUNT.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果： 出现次数为： 2CLEAR: LV_COUNT.FIND ALL OCCURRENCES OF LV_FIND IN LV_STRING4 MATCH COUNT LV_COUNT.IF SY-SUBRC EQ 0. WRITE:/ &#x27;出现次数为： &#x27;, LV_COUNT.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果： 未查找到 （4）查找内容并将结果放入内表 RESULTS使用RESULTS关键词可以将查找到的内容和结果放入内表中，但是到目前为止似乎无法使用Find关键词进行模糊查询。 1234567891011121314151617181920212223242526272829&quot;沿用上面的变量DATA: LT_RESULT TYPE MATCH_RESULT_TAB.FIELD-SYMBOLS: &lt;FS_RESULT&gt; LIKE LINE OF LT_RESULT.FIND ALL OCCURRENCES OF LV_FIND IN LV_STRING0 RESULT LT_RESULT.IF SY-SUBRC EQ 0. LOOP AT LT_RESULT ASSIGNING &lt;FS_RESULT&gt;. WRITE:/ &#x27;所在位置为： &#x27;,&lt;FS_RESULT&gt;-OFFSET,&#x27; 查找内容长度为： &#x27;,&lt;FS_RESULT&gt;-LENGTH. ENDLOOP.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果：所在位置为： 12 查找内容长度为： 2&quot; 所在位置为： 26 查找内容长度为： 2REFRESH LT_RESULT.FIND ALL OCCURRENCES OF LV_FIND IN LV_STRING4 RESULT LT_RESULT.IF SY-SUBRC EQ 0. LOOP AT LT_RESULT ASSIGNING &lt;FS_RESULT&gt;. WRITE:/ &#x27;所在位置为： &#x27;,&lt;FS_RESULT&gt;-OFFSET,&#x27; 查找内容长度为： &#x27;,&lt;FS_RESULT&gt;-LENGTH. ENDLOOP.ELSE. WRITE:/ &#x27;未查找到&#x27;.ENDIF.&quot;运行结果： 未查找到 （5）查找内容并将结果放入内表 IN TABLE使用关键词IN TABLE此处虽然可以查询内表中的内容，但是只能获取到查找到内容在内表中的行数，位置和长度等信息。但是查找的内表只能是但字段的内表。 1234567891011121314151617181920212223242526&quot;沿用上面的变量DATA: BEGIN OF LS_ITAB, STR TYPE CHAR30, END OF LS_ITAB, LT_ITAB LIKE TABLE OF LS_ITAB.LS_ITAB-STR = &#x27;DHFIOASDHFJKAA&#x27;.APPEND LS_ITAB TO LT_ITAB.LS_ITAB-STR = &#x27;SHDFIUASHDFPAASDFJHA&#x27;.APPEND LS_ITAB TO LT_ITAB.LS_ITAB-STR = &#x27;SIFHDFJKLGSDJIKFGN&#x27;.APPEND LS_ITAB TO LT_ITAB.FIND ALL OCCURRENCES OF LV_FIND IN TABLE LT_ITAB RESULT LT_RESULT.LOOP AT LT_RESULT ASSIGNING &lt;FS_RESULT&gt;. WRITE:/ &#x27;内容在内表的行数： &#x27;,&lt;FS_RESULT&gt;-LINE, &#x27; 查找内容在当前行的位置： &#x27;,&lt;FS_RESULT&gt;-OFFSET, &#x27; 查找内容的长度： &#x27;,&lt;FS_RESULT&gt;-LENGTH.ENDLOOP.&quot;运行结果：&quot;内容在内表的行数： 1 查找内容在当前行的位置： 12 查找内容的长度： 2&quot;内容在内表的行数： 2 查找内容在当前行的位置： 12 查找内容的长度： 2 （6）取消或区分大小写匹配FIND 关键词一般情况下是默认区分大小写匹配的，但是也可以使用下面的关键词进行取消和区分大小写匹配原则。 RESPECTING CASE：严格匹配，区分大小写匹配原则 IGNORING CASE：不严格匹配，不区分大小写匹配原则 12345678910111213141516171819202122232425262728&quot;沿用上面的变量LV_FIND = &#x27;aa&#x27;.&quot;严格匹配，区分大小写FIND LV_FIND IN LV_STRING0.IF SY-SUBRC EQ 0. WRITE:/ &#x27;匹配值为： &#x27;,LV_FIND,&#x27;查询到了&#x27;.ELSE. WRITE:/ &#x27;小写关键字未查询到&#x27;.ENDIF.&quot;运行结果：小写关键字未查询到FIND LV_FIND IN LV_STRING RESPECTING CASE.IF SY-SUBRC EQ 0. WRITE:/ &#x27;匹配值为： &#x27;,LV_FIND,&#x27;查询到了&#x27;.ELSE. WRITE:/ &#x27;小写关键字未查询到&#x27;.ENDIF.&quot;运行结果：小写关键字未查询到&quot;不严格匹配，不区分大小写FIND LV_FIND IN LV_STRING IGNORING CASE.IF SY-SUBRC EQ 0. WRITE:/ &#x27;匹配值为： &#x27;,LV_FIND,&#x27;查询到了&#x27;.ELSE. WRITE:/ &#x27;小写关键字未查询到&#x27;.ENDIF.&quot;运行结果：&quot;匹配值为： aa 查询到了 三、字符串替换 REPLACE1.介绍一般用于替换字符串中的内容，有两种语法结构。一种结构是根据字串进行匹配然后替换，另一种是根据位置和长度信息进行替换。 2.语法结构1234567REPLACE [&#123;FIRST OCCURRENCE&#125;|&#123;ALL OCCURRENCES&#125; OF] pattern IN [section_of] dobj WITH new [IN &#123;CHARACTER|BYTE&#125; MODE] [replace_options]. REPLACE SECTION [OFFSET off] [LENGTH len] OF dobj WITH new [IN &#123;CHARACTER|BYTE&#125; MODE]. 3.语法解释与应用（1）替换首次出现的内容 FIRST OCCURRENCE（默认）12345678910111213141516*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWERTYUIOPASDFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM&#x27;, LV_REPLACE TYPE STRING VALUE &#x27;QWE&#x27;.*----------------------------Logic-------------------------------------* &quot;替换首次出现的内容 &quot;REPLACE LV_REPLACE IN LV_STRING WITH &#x27;&#x27;. 上下两句效果相同 REPLACE FIRST OCCURRENCE OF LV_REPLACE IN LV_STRING WITH &#x27;&#x27;. IF SY-SUBRC NE 0. &quot;替换失败 MESSAGE S000 WITH &#x27;替换失败&#x27; DISPLAY LIKE GC_E. ENDIF. WRITE: LV_STRING. &quot;运行结果： &quot;RTYUIOPASDFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM （2）替换所有出现的内容 ALL OCCURRENCES123456789101112131415*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWERTYUIOPASDFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM&#x27;, LV_REPLACE TYPE STRING VALUE &#x27;QWE&#x27;.*----------------------------Logic-------------------------------------* &quot;替换首次出现的内容 REPLACE ALL OCCURRENCES OF LV_REPLACE IN LV_STRING WITH &#x27;&#x27;. IF SY-SUBRC NE 0. &quot;替换失败 MESSAGE S000 WITH &#x27;替换失败&#x27; DISPLAY LIKE GC_E. ENDIF. WRITE: LV_STRING. &quot;运行结果： &quot;RTYUIOPASDFGHJKLZXCVBNM|RTYUIOPASDFGHJKLZXCVBNM （3）以字符模式 IN CHARACTER MODE （默认）按照字符的形式，逐个替换对应的内容。效果其实和上面的一致。 123456789101112131415*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWERTYUIOPASDFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM&#x27;, LV_REPLACE TYPE STRING VALUE &#x27;QWE&#x27;.*----------------------------Logic-------------------------------------* &quot;以字符模式 REPLACE LV_REPLACE IN LV_STRING WITH &#x27;&#x27; IN CHARACTER MODE. IF SY-SUBRC NE 0. &quot;替换失败 MESSAGE S000 WITH &#x27;替换失败&#x27; DISPLAY LIKE GC_E. ENDIF. WRITE: LV_STRING. &quot;运行结果： &quot;RTYUIOPASDFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM （4）以字节模式 IN BYTE MODE按照字节的形式进行替换，替换语句中的所有变量类型均为X或XSTRING类型。 （5）按照长度与位置替换 REPLACE SECTION1234567891011121314151617181920212223242526*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWERTYUIOPASDFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM&#x27;, LV_REPLACE TYPE STRING VALUE &#x27;QWE&#x27;.*----------------------------Logic-------------------------------------* &quot;根据字符位置与长度替换 &quot;从5号字符开始，将之后的8个字符替换为空 REPLACE SECTION OFFSET 5 LENGTH 8 OF LV_STRING WITH &#x27;&#x27;. IF SY-SUBRC NE 0. &quot;替换失败 MESSAGE S000 WITH &#x27;替换失败&#x27; DISPLAY LIKE GC_E. ENDIF. WRITE: LV_STRING. &quot;运行结果： &quot;QWERTFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM &quot;从0号字符开始，将之后的3个字符替换为123 REPLACE SECTION OFFSET 0 LENGTH 3 OF LV_STRING WITH &#x27;123&#x27;. IF SY-SUBRC NE 0. &quot;替换失败 MESSAGE S000 WITH &#x27;替换失败&#x27; DISPLAY LIKE GC_E. ENDIF. WRITE: LV_STRING. &quot;运行结果： &quot;123RTFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM （6）替换字符串的其余属性长度属性不知道为什么，运行出来的结果一直是0。即便换成替换第一个出现的也是一样的效果。但是其余的两个属性都是正常的。 1234567891011121314151617181920212223242526272829*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWERTYUIOPASDFGHJKLZXCVBNM|QWERTYUIOPASDFGHJKLZXCVBNM&#x27;, LV_REPLACE TYPE STRING VALUE &#x27;QWE&#x27;, LV_COUNT TYPE I, LV_OFFSET TYPE I, LV_LENGTH TYPE I.*----------------------------Logic-------------------------------------* REPLACE ALL OCCURRENCES OF LV_REPLACE IN LV_STRING WITH &#x27;&#x27; &quot;替换次数 REPLACEMENT COUNT LV_COUNT &quot;最后一次替换位置 REPLACEMENT OFFSET LV_OFFSET &quot;替换字符串的长度 REPLACEMENT LENGTH LV_LENGTH. IF SY-SUBRC NE 0. &quot;替换失败 MESSAGE S000 WITH &#x27;替换失败&#x27; DISPLAY LIKE GC_E. ENDIF. WRITE: LV_STRING. WRITE: / &#x27;替换次数:&#x27;, LV_COUNT, / &#x27;最后一次替换位置:&#x27;,LV_OFFSET, / &#x27;替换字符串的长度:&#x27;,LV_LENGTH. &quot;运行结果： &quot;RTYUIOPASDFGHJKLZXCVBNM|RTYUIOPASDFGHJKLZXCVBNM &quot;替换次数:2 &quot;最后一次替换位置:24 &quot;替换字符串的长度:0 四、移位操作 SHIFT1.介绍对字符串整体进行移位操作，可以整体左移也可以整体右移。默认情况下是移动一位，但是也可以根据自身的需求进行设置。在右移时，类型为String类型的变量移位不会改变原有的有内容的部分，只会在原有内容前新增空行。因为该类型的变量是不定长的，所以右移新增行时，长度是会随着移位操作变长的。但是定长的变量在移位过程中的内容是会受到影响的。 2.语法结构12SHIFT dobj [ &#123;[places][direction]&#125; | deleting ] [IN &#123;CHARACTER|BYTE&#125; MODE]. 3.语法解释与应用（1）移动一位操作 SHIFT① 左移一位12345678910111213*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;0001000200030004000&#x27;, LV_CHAR TYPE CHAR10 VALUE &#x27;0001234567&#x27;.*----------------------------Logic-------------------------------------* &quot;默认左移一位 SHIFT LV_STRING. SHIFT LV_CHAR. WRITE: / LV_STRING, / LV_CHAR. &quot;运行结果： &quot;001000200030004000 &quot;001234567 ② 右移一位123456789101112131415161718*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;0001000200030004000&#x27;, LV_CHAR TYPE CHAR10 VALUE &#x27;0001234567&#x27;.*----------------------------Logic-------------------------------------* WRITE: / LV_STRING, / LV_CHAR. &quot;右移一位 SHIFT LV_STRING RIGHT. SHIFT LV_CHAR RIGHT. WRITE: / LV_STRING, / LV_CHAR. &quot;运行结果： &quot;0001000200030004000 &quot;0001234567 &quot; 0001000200030004000 &quot; 000123456 （2）移动多位 BY n PLACES① 左移5位12345678910111213*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;0001000200030004000&#x27;, LV_CHAR TYPE CHAR10 VALUE &#x27;0001234567&#x27;.*----------------------------Logic-------------------------------------* &quot;左移5位 SHIFT LV_STRING BY 5 PLACES. SHIFT LV_CHAR BY 5 PLACES. WRITE: / LV_STRING, / LV_CHAR. &quot;运行结果： &quot;00200030004000 &quot;34567 ② 右移5位123456789101112131415161718*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;0001000200030004000&#x27;, LV_CHAR TYPE CHAR10 VALUE &#x27;0001234567&#x27;.*----------------------------Logic-------------------------------------* WRITE: / LV_STRING, / LV_CHAR. &quot;右移5位 SHIFT LV_STRING BY 5 PLACES RIGHT. SHIFT LV_CHAR BY 5 PLACES RIGHT. WRITE: / LV_STRING, / LV_CHAR. &quot;运行结果： &quot;0001000200030004000 &quot;0001234567 &quot; 0001000200030004000 &quot; 00012 （3）循环移动 CIRCULAR循环移动其实就是把字符串首尾相接，左移的字符拼接到字符串的右侧，右移的字符拼接到字符串的左侧。 123456789101112131415161718192021*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;0001000200030004000&#x27;, LV_CHAR TYPE CHAR10 VALUE &#x27;0001234567&#x27;.*----------------------------Logic-------------------------------------* &quot;左循环移动 SHIFT LV_STRING BY 5 PLACES CIRCULAR. SHIFT LV_CHAR BY 5 PLACES CIRCULAR. WRITE: / LV_STRING, / LV_CHAR. &quot;右循环移动 SHIFT LV_STRING BY 5 PLACES RIGHT CIRCULAR. SHIFT LV_CHAR BY 5 PLACES RIGHT CIRCULAR. WRITE: / LV_STRING, / LV_CHAR. &quot;运行结果：先左移5位再右移5位，最终的结果值不变 &quot;0020003000400000010 &quot;3456700012 &quot;0001000200030004000 &quot;0001234567 （4）去掉重复字符串（前导零）该语句在去除前导零时经常使用。 ① 左移去除重复字符串1234567891011121314151617181920*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;0001000200030004000&#x27;, LV_CHAR TYPE CHAR10 VALUE &#x27;0001234000&#x27;.*----------------------------Logic-------------------------------------* &quot;左移去除重复字符串 SHIFT LV_CHAR LEFT DELETING LEADING &#x27;0&#x27;. SHIFT LV_STRING LEFT DELETING LEADING &#x27;0&#x27;. WRITE: / LV_STRING, / LV_CHAR. &quot;运行结果： &quot;1000200030004000 &quot;1234000 &quot;去除前导零也可以使用下面的Function CALL FUNCTION &#x27;CONVERSION_EXIT_ALPHA_OUTPUT&#x27; EXPORTING INPUT = LV_CHAR IMPORTING OUTPUT = LV_CHAR. ② 右移去除重复字符串123456789101112131415161718*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;0001000200030004000&#x27;, LV_CHAR TYPE CHAR10 VALUE &#x27;0001234000&#x27;.*----------------------------Logic-------------------------------------* WRITE: / LV_STRING, / LV_CHAR. &quot;右移去除重复字符串 SHIFT LV_CHAR RIGHT DELETING TRAILING &#x27;0&#x27;. SHIFT LV_STRING RIGHT DELETING TRAILING &#x27;0&#x27;. WRITE: / LV_STRING, / LV_CHAR. &quot;运行结果： &quot;0001000200030004000 &quot;0001234000 &quot; 0001000200030004 &quot; 0001234 五、增加前导零 UNPACK1.介绍这是由Shift变量的去除前导零引申出来的一个知识点。他会根据定长变量的长度与实际值添加前导零，直至实际内容长度与定长变量的长度一致。 2.语法结构1UNPACK source TO destination. 3.语法解释与应用1234567891011121314151617181920*--------------------------Variables-----------------------------------* DATA: LV_CHAR TYPE CHAR10 VALUE &#x27;113&#x27;.*----------------------------Logic-------------------------------------* UNPACK LV_CHAR TO LV_CHAR. WRITE: LV_CHAR. UNPACK &#x27;1&#x27; TO LV_CHAR. WRITE: LV_CHAR. &quot;使用Function添加前导零 CALL FUNCTION &#x27;CONVERSION_EXIT_ALPHA_INPUT&#x27; EXPORTING INPUT = &#x27;12&#x27; IMPORTING OUTPUT = LV_CHAR. WRITE: LV_CHAR. &quot;运行结果： &quot;0000000113 0000000001 0000000012 六、字符串大小写 TRANSLATE1.介绍该关键字不仅可以对字符串进行大小写的切换，还可以使用USING语法对其中的字符进行切换，但是这种切换是会识别字符的大小写的。 2.语法结构12TRANSLATE text &#123;TO &#123;UPPER|LOWER&#125; CASE&#125; | &#123;USING mask&#125;. 3.语法解释与应用（1）切换大写 UPPER123456789101112131415161718*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWErty&#x27;, LV_STRUPPER TYPE STRING VALUE &#x27;QWERTY&#x27;, LV_STRLOWER TYPE STRING VALUE &#x27;qwerty&#x27;.*----------------------------Logic-------------------------------------* &quot;大写切换 TRANSLATE LV_STRING TO UPPER CASE. TRANSLATE LV_STRUPPER TO UPPER CASE. TRANSLATE LV_STRLOWER TO UPPER CASE. WRITE: / LV_STRING, / LV_STRUPPER, / LV_STRLOWER. &quot;运行结果： &quot;QWERTY &quot;QWERTY &quot;QWERTY （2）切换小写 LOWER123456789101112131415161718*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWErty&#x27;, LV_STRUPPER TYPE STRING VALUE &#x27;QWERTY&#x27;, LV_STRLOWER TYPE STRING VALUE &#x27;qwerty&#x27;.*----------------------------Logic-------------------------------------* &quot;小写切换 TRANSLATE LV_STRING TO LOWER CASE. TRANSLATE LV_STRUPPER TO LOWER CASE. TRANSLATE LV_STRLOWER TO LOWER CASE. WRITE: / LV_STRING, / LV_STRUPPER, / LV_STRLOWER. &quot;运行结果： &quot;qwerty &quot;qwerty &quot;qwerty （3）字符替换 USING关键词USING后面跟的是字符对，即QA、qa等，这样的是字符对。还是以前面的举例为例，在进行匹配时，会将字符对的第一个字符作为被替换的字符，后一个为替换值进行替换。即在字符串中搜索Q字符，这个匹配是严格匹配的，即区分大小写。若找到了Q字符，则将其替换为A字符。同理对于qa字符对，若字符串中存在q字符，则将其替换为a。 1234567891011121314151617181920*--------------------------Variables-----------------------------------* DATA: LV_STRING TYPE STRING VALUE &#x27;QWErty&#x27;, LV_STRUPPER TYPE STRING VALUE &#x27;QWERTY&#x27;, LV_STRLOWER TYPE STRING VALUE &#x27;qwerty&#x27;.*----------------------------Logic-------------------------------------* &quot;字符切换 &quot;将大写的Q转换为A，将小写的r转换为b &quot;将小写的q转换为a，将大写的R转换为B TRANSLATE LV_STRING USING &#x27;QAqaRBrb&#x27;. TRANSLATE LV_STRUPPER USING &#x27;QAqaRBrb&#x27;. TRANSLATE LV_STRLOWER USING &#x27;QAqaRBrb&#x27;. WRITE: / LV_STRING, / LV_STRUPPER, / LV_STRLOWER. &quot;运行结果： &quot;AWEbty &quot;AWEBTY &quot;awebty 七、字符串去空格 CONDENSE1.介绍使用CONDENSE关键字去除字符串的空格，当不添加NO-GAPS关键词时只去除字符串首尾两端的空格。当添加NO-GAPS关键词时，则去除字符串中所有的空格，即便是字符串中间的空格也会被去掉。 2.语法结构1CONDENSE text [NO-GAPS]. 3.语法解释与应用（1）去除首位两端的空格 CONDENSE1234567891011121314151617181920212223242526272829303132333435363738*--------------------------Variables-----------------------------------* DATA: BEGIN OF LS_STRUCTURE, TEXT1 TYPE C LENGTH 20 VALUE &#x27;Hello&#x27;, TEXT2 TYPE C LENGTH 20 VALUE &#x27;World.&#x27;, TEXT3 TYPE C LENGTH 20 VALUE &#x27;l am an&#x27;, TEXT4 TYPE C LENGTH 20 VALUE &#x27;ABAP&#x27;, TEXT5 TYPE C LENGTH 20 VALUE &#x27;programmer.&#x27;, END OF LS_STRUCTURE. DATA: LV_TEXT TYPE STRING, LV_STRING TYPE STRING VALUE ` QWE `, LV_STRNUL TYPE STRING VALUE ` Q W E `.*----------------------------Logic-------------------------------------* LV_TEXT = LS_STRUCTURE. WRITE: / &#x27;转换前：&#x27;, / LV_TEXT, / LV_STRING, / LV_STRNUL. CONDENSE LV_TEXT. CONDENSE LV_STRING. CONDENSE LV_STRNUL. WRITE: / &#x27;转换后：&#x27;, / LV_TEXT, / LV_STRING, / LV_STRNUL. &quot;下图中的中括号中间的值为实际值，前后两端都是带有空格的 &quot;转换前： &quot;Hello World. l am an ABAP programmer. &quot;[ QWE ] &quot;[ Q W E ] &quot;转换后： &quot;Hello World. l am an ABAP programmer. &quot;QWE &quot;Q W E （2）去除全部空格 NO-GAPS1234567891011121314151617181920212223242526272829303132333435363738*--------------------------Variables-----------------------------------* DATA: BEGIN OF LS_STRUCTURE, TEXT1 TYPE C LENGTH 20 VALUE &#x27;Hello&#x27;, TEXT2 TYPE C LENGTH 20 VALUE &#x27;World.&#x27;, TEXT3 TYPE C LENGTH 20 VALUE &#x27;l am an&#x27;, TEXT4 TYPE C LENGTH 20 VALUE &#x27;ABAP&#x27;, TEXT5 TYPE C LENGTH 20 VALUE &#x27;programmer.&#x27;, END OF LS_STRUCTURE. DATA: LV_TEXT TYPE STRING, LV_STRING TYPE STRING VALUE ` QWE `, LV_STRNUL TYPE STRING VALUE ` Q W E `.*----------------------------Logic-------------------------------------* LV_TEXT = LS_STRUCTURE. WRITE: / &#x27;转换前：&#x27;, / LV_TEXT, / LV_STRING, / LV_STRNUL. CONDENSE LV_TEXT NO-GAPS. CONDENSE LV_STRING NO-GAPS. CONDENSE LV_STRNUL NO-GAPS. WRITE: / &#x27;转换后：&#x27;, / LV_TEXT, / LV_STRING, / LV_STRNUL. &quot;下图中的中括号中间的值为实际值，前后两端都是带有空格的 &quot;转换前： &quot;Hello World. l am an ABAP programmer. &quot;[ QWE ] &quot;[ Q W E ] &quot;转换后： &quot;HelloWorld.lamanABAPprogrammer. &quot;QWE &quot;QWE 八、字符串拼接1.介绍字符串拼接有两种方式。 使用关键词CONCATENATE 使用拼接符 **&amp;&amp;**（ECC6.0等旧版本中不支持该语句） 在拼接字符串的时候，为了简便的写法可以使用第二种**&amp;&amp;的形式进行拼接。但是如果需要拼接内表或结构体等内容时，则还是需要使用关键词CONCATENATE**进行拼接。 2.语法结构12345CONCATENATE &#123;dobj1 dobj2 ...&#125;|&#123;LINES OF itab&#125; INTO result [IN &#123;CHARACTER|BYTE&#125; MODE] [SEPARATED BY sep] [RESPECTING BLANKS]. 3.语法解释与应用（1）拼接语句 CONCATENATE12345678910111213141516*--------------------------Variables-----------------------------------* DATA: LV_STR1 TYPE STRING VALUE &#x27;Hello&#x27;, LV_STR2 TYPE STRING VALUE &#x27;World.&#x27;, LV_STRING TYPE STRING.*----------------------------Logic-------------------------------------* &quot;拼接字符串，两种语句效果相同 LV_STRING = LV_STR1 &amp;&amp; LV_STR2. WRITE: / LV_STRING. CONCATENATE LV_STR1 LV_STR2 INTO LV_STRING. WRITE: / LV_STRING. &quot;运行结果： &quot;HelloWorld. &quot;HelloWorld. （2）添加拼接符 SEPARATED BY&amp;&amp;的形式拼接的字符串无法像CONCATENATE关键词一样使用SPACE关键词。**&amp;&amp;使用SPACE关键词进行拼接时，SPACE会失效。如果想要使用&amp;&amp;在字符串中间拼接空格则可以考虑使用制表符号&#96;**所包含的空格。 123456789101112131415161718192021222324*--------------------------Variables-----------------------------------* DATA: LV_STR1 TYPE STRING VALUE &#x27;Hello&#x27;, LV_STR2 TYPE STRING VALUE &#x27;World.&#x27;, LV_STRING TYPE STRING, LV_TEST TYPE C VALUE ` `.*----------------------------Logic-------------------------------------* &quot;添加拼接符 &quot;上下两句效果相同，即便使用变量中间添加制表符空格也无法生效 LV_STRING = LV_STR1 &amp;&amp; LV_TEST &amp;&amp; LV_STR2. WRITE: / LV_STRING. LV_STRING = LV_STR1 &amp;&amp; SPACE &amp;&amp; LV_STR2. WRITE: / LV_STRING. LV_STRING = LV_STR1 &amp;&amp; ` ` &amp;&amp; LV_STR2. WRITE: / LV_STRING. CONCATENATE LV_STR1 LV_STR2 INTO LV_STRING SEPARATED BY SPACE. WRITE: / LV_STRING. &quot;运行结果： &quot;HelloWorld. &quot;HelloWorld. &quot;Hello World. &quot;Hello World. （3）合并内表 LINES OF合并内表的关键词是LINES OF。但是该关键词只能用于单字段内表，且类型为字符类型或STRING类型的字段使用。单字段内表的意思就是只有一个字段的内表，且类型只能为C、N、D、T或STRING。 12345678910111213141516171819*--------------------------Variables-----------------------------------* DATA: LT_TABLE TYPE TABLE OF CHAR20, LV_STRING TYPE STRING.*----------------------------Logic-------------------------------------* &quot;合并内表 APPEND &#x27;Hello&#x27; TO LT_TABLE. APPEND &#x27;World.&#x27; TO LT_TABLE. APPEND &#x27;l am an&#x27; TO LT_TABLE. APPEND &#x27;ABAP&#x27; TO LT_TABLE. APPEND &#x27;programmer.&#x27; TO LT_TABLE. CONCATENATE LINES OF LT_TABLE INTO LV_STRING. WRITE: / LV_STRING. &quot;HelloWorld.l am anABAPprogrammer. CONCATENATE LINES OF LT_TABLE INTO LV_STRING SEPARATED BY SPACE. WRITE: / LV_STRING. &quot;Hello World. l am an ABAP programmer. （4）保留尾部空格 RESPECTING BLANKS该语句意思其实是指填充变量后续的空格。例如一个C类型长度为10的变量初始值为123，另一个相同类型的变量初始值为1。使用该语句进行拼接之后结果为123[ ]1（[]中间为7个空格）。因为第一个变量实际内容只占用了3个长度，所以使用该语句进行拼接时会将后续的7个长度按照空格的形式进行补齐。但是合并后的最后字符串并不会将空格补齐。 123456789101112131415161718*--------------------------Variables-----------------------------------* DATA: LT_TABLE TYPE TABLE OF CHAR10.*----------------------------Logic-------------------------------------* APPEND &#x27;Hello&#x27; TO LT_TABLE. APPEND &#x27;World.&#x27; TO LT_TABLE. APPEND &#x27;l am an&#x27; TO LT_TABLE. APPEND &#x27;ABAP&#x27; TO LT_TABLE. APPEND &#x27;programmer.&#x27; TO LT_TABLE. CONCATENATE LINES OF LT_TABLE INTO LV_STRING SEPARATED BY SPACE. WRITE: / LV_STRING. &quot;Hello World. l am an ABAP programmer &quot;保留尾部空格 CONCATENATE LINES OF LT_TABLE INTO LV_STRING RESPECTING BLANKS. WRITE: / LV_STRING. &quot;Hello World. l am an ABAP programmer 九、字符串分割 SPLIT1.介绍如果想要根据某一字段或内容对字符串进行分割，则可以使用关键词SPLIT进行分割。如果想要按照位置开始截取字符串则可以考虑使用较为简便的 **字符串+截取开始位置(截取长度)**方式进行截取。 2.语法结构123SPLIT dobj AT sep INTO &#123; &#123;result1 result2 [...]&#125; | &#123;TABLE result_tab&#125; &#125; [IN &#123;CHARACTER|BYTE&#125; MODE]. 3.语法解释与应用（1）截取字符串到变量 INTO123456789101112131415161718*--------------------------Variables-----------------------------------* CONSTANTS: LC_SPLIT TYPE C LENGTH 1 VALUE &#x27;|&#x27;. DATA: LV_SPLIT TYPE STRING VALUE &#x27;QWE|RTY|UIO&#x27;, LV_STR1 TYPE STRING, LV_STR2 TYPE STRING, LV_STR3 TYPE STRING.*----------------------------Logic-------------------------------------* &quot;截取字符串到变量 SPLIT LV_SPLIT AT LC_SPLIT INTO LV_STR1 LV_STR2 LV_STR3. WRITE: / LV_STR1, / LV_STR2, / LV_STR3. &quot;运行结果： &quot;QWE &quot;RTY &quot;UIO （2）截取字符串到内表 TABLE1234567891011121314151617*--------------------------Variables-----------------------------------* CONSTANTS: LC_SPLIT TYPE C LENGTH 1 VALUE &#x27;|&#x27;. DATA: LV_SPLIT TYPE STRING VALUE &#x27;QWE|RTY|UIO&#x27;, LT_TABSTR TYPE TABLE OF STRING.*----------------------------Logic-------------------------------------* &quot;截取字符串到内表 SPLIT LV_SPLIT AT LC_SPLIT INTO TABLE LT_TABSTR. LOOP AT LT_TABSTR INTO LV_SPLIT. WRITE: / LV_SPLIT. CLEAR: LV_SPLIT. ENDLOOP. &quot;运行结果： &quot;QWE &quot;RTY &quot;UIO 十、字符串匹配模式1.介绍字符串的匹配模式主要包含以下四种： CO &#x2F; CN：contains only or not（是否仅包含） CA &#x2F; NA：contains any or not any（包含或不包含任何） CS &#x2F; NS：contain string or not（是否包含字符串） CP &#x2F; NP：contains pattern or not（是否包含图案） 注：在比较两个字符串时，字符串前的空格会计入进行比较，但是字符串末尾的空格不会计入进行比较。 2.包含于 &#x2F; 不包含 字符比较 CO &#x2F; CN（1）说明&lt;str1&gt; CO &lt;str2&gt;：str1包含于或等于str2，返回true。str1中字符均可以在str2中找到。区分大小写，顺序无要求。 &lt;str1&gt; CN &lt;str2&gt;：str1不仅包含于或等于str2，str1中存在str2中不存在的字符，返回true。区分大小写，顺序无要求。 （2）注意事项使用这两者对数据进行对比时，等号左右两侧的数据类型对结果会有影响。所以建议将数据全部转化为String类型进行比较。 推测造成这样的原因是因为定长的数据类型会自动填充空格在其中进行比较，所以会对结果进行影响。 12345678910111213141516171819202122*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE C LENGTH 3 VALUE &#x27;qaz&#x27;, LV_STRING2 TYPE C LENGTH 9 VALUE &#x27;qweasdzxc&#x27;, LV_STR1 TYPE C LENGTH 5 VALUE &#x27;qaz&#x27;, LV_STR2 TYPE C LENGTH 9 VALUE &#x27;qweasdzxc&#x27;.*----------------------------Logic-------------------------------------* IF LV_STRING1 CO LV_STRING2. WRITE: / &#x27;CO True&#x27;. ELSE. WRITE: / &#x27;CO False&#x27;. ENDIF. &quot;运行结果： &quot;CO True IF LV_STR1 CO LV_STR2. WRITE: / &#x27;CO True&#x27;. ELSE. WRITE: / &#x27;CO False&#x27;. ENDIF. &quot;运行结果： &quot;CO False （3）代码实例① CO 包含于关系12345678910111213141516171819202122*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;qaz&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;qweasdzxc&#x27;.*----------------------------Logic-------------------------------------* &quot;STRING1的内容包含于/等于STRING2的内容，不会比较空格 &quot;反过来可以说STRING2包含STRING1 IF LV_STRING1 CO LV_STRING2. WRITE: / &#x27;CO True&#x27;. ELSE. WRITE: / &#x27;CO False&#x27;. ENDIF. &quot;运行结果： &quot;CO True IF LV_STRING2 CO LV_STRING1. WRITE: / &#x27;CO True&#x27;. ELSE. WRITE: / &#x27;CO False&#x27;. ENDIF. &quot;运行结果： &quot;CO False ② CN 两字符串是否有非交集字符1234567891011121314151617181920212223*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;1qaz&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;qweasdzxc&#x27;.*----------------------------Logic-------------------------------------* &quot;STRING1的部分内容与STRING2重合，但还拥有自己的内容 &quot;也就是查看两个字符串的字符是否拥有非交集的部分 IF LV_STRING1 CN LV_STRING2. WRITE: / &#x27;CN True&#x27;. ELSE. WRITE: / &#x27;CN False&#x27;. ENDIF. &quot;运行结果： &quot;CN True LV_STRING1 = &#x27;qaz&#x27;. IF LV_STRING2 CN LV_STRING1. WRITE: / &#x27;CN True&#x27;. ELSE. WRITE: / &#x27;CN False&#x27;. ENDIF. &quot;运行结果： &quot;CN False （4）常使用场景这两个比较关系经常被用于两字符串中字符的校验。例如我需要比较一个变量中的所有字符是否全是数字时，可以使用这两个比较关系。 123456789101112131415161718192021222324*--------------------------Variables-----------------------------------* CONSTANTS: LC_NUMBER TYPE STRING VALUE &#x27;.0123456789&#x27;. DATA: LV_STRING1 TYPE STRING VALUE &#x27;123.45&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;123.45P&#x27;.*----------------------------Logic-------------------------------------* &quot;判断字符串中是否全是数字 IF LV_STRING1 CO LC_NUMBER. WRITE: / &#x27;字符串中全是数值&#x27;. ELSE. WRITE: / &#x27;字符串中包含非数值字符&#x27;. ENDIF. &quot;运行结果： &quot;字符串中全是数值 &quot;判断字符串中是否存在非数字部分 IF LV_STRING2 CN LC_NUMBER. WRITE: / &#x27;字符串中包含非数值字符&#x27;. ELSE. WRITE: / &#x27;字符串中全是数值&#x27;. ENDIF. &quot;运行结果： &quot;字符串中包含非数值字符 3.存在交集 &#x2F; 不存在交集 字符比较 CA &#x2F; NA（1）说明&lt;str1&gt; CA &lt;str2&gt;：str1包含于str2的任何内容，返回true。区分大小写，顺序无要求。 &lt;str1&gt; NA &lt;str2&gt;：str1不包含于str2的任何内容，返回true。区分大小写，顺序无要求。 （2）代码示例① CA 两者字符存在交集1234567891011121314151617181920*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;qaz&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;qweasdzxc&#x27;.*----------------------------Logic-------------------------------------* IF LV_STRING1 CA LV_STRING2. WRITE: / &#x27;CA True&#x27;. ELSE. WRITE: / &#x27;CA False&#x27;. ENDIF. &quot;运行结果： &quot;CA True IF LV_STRING2 CA LV_STRING1. WRITE: / &#x27;CA True&#x27;. ELSE. WRITE: / &#x27;CA False&#x27;. ENDIF. &quot;运行结果： &quot;CA True ② NA 两者字符不存在交集12345678910111213141516171819202122*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;QAZ&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;qweasdzxc&#x27;.*----------------------------Logic-------------------------------------* IF LV_STRING1 NA LV_STRING2. WRITE: / &#x27;NA True&#x27;. ELSE. WRITE: / &#x27;NA False&#x27;. ENDIF. &quot;运行结果： &quot;NA True LV_STRING1 = &#x27;QaZ&#x27;. LV_STRING2 = &#x27;qweasdzxc&#x27;. IF LV_STRING1 NA LV_STRING2. WRITE: / &#x27;NA True&#x27;. ELSE. WRITE: / &#x27;NA False&#x27;. ENDIF. &quot;运行结果： 两字符之间存在交集字符a &quot;NA False 4.包含 &#x2F; 不包含 字符串比较 CS &#x2F; NS（1）说明&lt;str1&gt; CS &lt;str2&gt;：str1包含str2的字符串，返回true。此时比较的是字符串而不再是字符。不区分大小写，顺序有要求。 &lt;str1&gt; NS &lt;str2&gt;：str1不包含str2的字符串，返回true。此时比较的是字符串而不再是字符。不区分大小写，顺序有要求。 （2）代码示例① CS 包含关系12345678910111213141516171819202122*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;qweasdzxc&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;QW&#x27;.*----------------------------Logic-------------------------------------* IF LV_STRING1 CS LV_STRING2. WRITE: / &#x27;CS True&#x27;. ELSE. WRITE: / &#x27;CS False&#x27;. ENDIF. &quot;运行结果： &quot;CS True LV_STRING1 = &#x27;qweasdzxc&#x27;. LV_STRING2 = &#x27;qe&#x27;. IF LV_STRING1 CS LV_STRING2. WRITE: / &#x27;CS True&#x27;. ELSE. WRITE: / &#x27;CS False&#x27;. ENDIF. &quot;运行结果： &quot;CS False ② NS 不包含关系12345678910111213141516171819202122*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;qweasdzxc&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;Qe&#x27;.*----------------------------Logic-------------------------------------* IF LV_STRING1 NS LV_STRING2. WRITE: / &#x27;NS True&#x27;. ELSE. WRITE: / &#x27;NS False&#x27;. ENDIF. &quot;运行结果： &quot;NS True LV_STRING1 = &#x27;qweasdzxc&#x27;. LV_STRING2 = &#x27;QW&#x27;. IF LV_STRING1 NS LV_STRING2. WRITE: / &#x27;NS True&#x27;. ELSE. WRITE: / &#x27;NS False&#x27;. ENDIF. &quot;运行结果： &quot;NS False 5.模糊匹配 CP &#x2F; NP（1）说明这两种比较关键词是模式匹配，默认不区分大小写，对顺序有要求。但是在语句中， # 表示区分大小写 * 代表任意字符。 &lt;str1&gt; CP &lt;str2&gt;：str1包含str2的字符串，返回true。 &lt;str1&gt; NP &lt;str2&gt;：str1不包含str2的字符串，返回true。 （2）代码示例① 模糊匹配 包含 CP123456789101112131415161718192021*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;qweasdzxc&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;#q*&#x27;, LV_STRING3 TYPE STRING VALUE &#x27;#Q*&#x27;.*----------------------------Logic-------------------------------------* IF LV_STRING1 CP LV_STRING2. WRITE: / &#x27;CP True&#x27;. ELSE. WRITE: / &#x27;CP False&#x27;. ENDIF. &quot;运行结果： &quot;CP True IF LV_STRING1 CP LV_STRING3. WRITE: / &#x27;CP True&#x27;. ELSE. WRITE: / &#x27;CP False&#x27;. ENDIF. &quot;运行结果： &quot;CP False ② 模糊匹配 不包含 NP123456789101112131415161718192021*--------------------------Variables-----------------------------------* DATA: LV_STRING1 TYPE STRING VALUE &#x27;qweasdzxc&#x27;, LV_STRING2 TYPE STRING VALUE &#x27;#q*&#x27;, LV_STRING3 TYPE STRING VALUE &#x27;#Q*&#x27;.*----------------------------Logic-------------------------------------* IF LV_STRING1 NP LV_STRING3. WRITE: / &#x27;NP True&#x27;. ELSE. WRITE: / &#x27;NP False&#x27;. ENDIF. &quot;运行结果： &quot;NP True IF LV_STRING1 NP LV_STRING2. WRITE: / &#x27;NP True&#x27;. ELSE. WRITE: / &#x27;NP False&#x27;. ENDIF. &quot;运行结果： &quot;NP False 十一、参考资料ABAP学习 sap ABAP 字符串常用操作 SAP ABAP常用字符串处理","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"ABAP基础","slug":"ABAP基础","permalink":"https://www.yemaojun.top/categories/ABAP%E5%9F%BA%E7%A1%80/"},{"name":"ABAP 字符串","slug":"ABAP-字符串","permalink":"https://www.yemaojun.top/categories/ABAP-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"调用外部HTTP Rest接口","slug":"ABAP/Rest Interface/调用外部HTTP Rest接口/调用外部HTTP-Rest接口","date":"2023-07-06T03:20:57.000Z","updated":"2023-07-10T02:19:42.720Z","comments":true,"path":"2023/07/06/ABAP/Rest Interface/调用外部HTTP Rest接口/调用外部HTTP-Rest接口/","link":"","permalink":"https://www.yemaojun.top/2023/07/06/ABAP/Rest%20Interface/%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8HTTP%20Rest%E6%8E%A5%E5%8F%A3/%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8HTTP-Rest%E6%8E%A5%E5%8F%A3/","excerpt":"之前介绍了如何使用SAP发布供外部调用的HTTP Rest接口，本篇记录一下当别的系统发布了访问的HTTP链接，SAP系统如何调用和进行参数设置。","text":"之前介绍了如何使用SAP发布供外部调用的HTTP Rest接口，本篇记录一下当别的系统发布了访问的HTTP链接，SAP系统如何调用和进行参数设置。 调用外部HTTP Rest接口 一、调用前准备在调用别的系统的HTTP接口时，需要了解外围系统的URL与用户名和密码等信息。当然，如果没有设置校验的用户名与密码，则在调用时也不需要考虑这些内容。 本次内容使用网上公开的接口： http://www.webxml.com.cn/zh_cn/index.aspx http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx/getMobileCodeInfo 本篇笔记主要参考SAP之调用外部接口实例这篇笔记编写的代码。所以本篇笔记主要记录一下调用的流程与代码，然后会在最后把全代码和运行画面展示出来。 二、源码编写1.选择屏幕输入URL（1）界面展示 （2）源码选择画面源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&quot;Select Run Type 选择运行类型SELECTION-SCREEN BEGIN OF BLOCK K01 WITH FRAME TITLE TEXT-T01.SELECTION-SCREEN BEGIN OF LINE.&quot;Select Run Type:PARAMETERS P_TXT NO-DISPLAY.SELECTION-SCREEN COMMENT 1(26) TEXT-002 FOR FIELD P_TXT.&quot;Test ModeSELECTION-SCREEN POSITION 32.PARAMETERS: P_TEST RADIOBUTTON GROUP GR01 USER-COMMAND UC1 DEFAULT &#x27;X&#x27;. &quot;测试用URLSELECTION-SCREEN COMMENT 34(27) TEXT-R01 FOR FIELD P_TEST.&quot;CustomizeSELECTION-SCREEN POSITION 62.PARAMETERS: P_CUST RADIOBUTTON GROUP GR01. &quot;自定义URLSELECTION-SCREEN COMMENT 63(32) TEXT-R02 FOR FIELD P_CUST.SELECTION-SCREEN END OF LINE.SELECTION-SCREEN END OF BLOCK K01.&quot;Input peripheral interface information 输入外围接口信息SELECTION-SCREEN BEGIN OF BLOCK K02 WITH FRAME TITLE TEXT-T02.PARAMETERS: P_URL TYPE STRING, P_TYPE TYPE CHAR10 AS LISTBOX VISIBLE LENGTH 10 MODIF ID LIS.SELECTION-SCREEN END OF BLOCK K02.&quot;Inquiry Type 查询类型SELECTION-SCREEN BEGIN OF BLOCK K03 WITH FRAME TITLE TEXT-T03.&quot;Search for national regionsPARAMETERS: P_AREA RADIOBUTTON GROUP GR02 USER-COMMAND UC2 DEFAULT &#x27;X&#x27; MODIF ID TES.&quot;Search for mobile phone locationPARAMETERS: P_LOCAT RADIOBUTTON GROUP GR02 MODIF ID TES.PARAMETERS: P_PHONE TYPE C LENGTH 11 MODIF ID PHO.SELECTION-SCREEN END OF BLOCK K03.&quot;Enter account and passwordSELECTION-SCREEN BEGIN OF BLOCK K04 WITH FRAME TITLE TEXT-T04.PARAMETERS: P_USER TYPE STRING MODIF ID USP, P_PASS TYPE STRING MODIF ID USP. &quot;和输入框样式一致的类型XUNCODESELECTION-SCREEN END OF BLOCK K04. 接口操作类型，选择屏幕下拉框代码。此段逻辑在选择屏幕的AT SELECTION-SCREEN OUTPUT.事件下添加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748FORM SET_LIST_VALUE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GET TYPE STRING VALUE &#x27;GET&#x27;, LC_PUT TYPE STRING VALUE &#x27;PUT&#x27;, LC_POST TYPE STRING VALUE &#x27;POST&#x27;, LC_PATCH TYPE STRING VALUE &#x27;PATCH&#x27;, LC_DELETE TYPE STRING VALUE &#x27;DELETE&#x27;. DATA: LV_VID TYPE VRM_ID VALUE &#x27;P_TYPE&#x27;, LS_LIST TYPE VRM_VALUE, LT_LIST TYPE VRM_VALUES.*----------------------------Logic-------------------------------------* &quot;Set List Value &quot;Get LS_LIST-KEY = LC_GET. LS_LIST-TEXT = &#x27;Get&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Put LS_LIST-KEY = LC_PUT. LS_LIST-TEXT = &#x27;Put&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Post LS_LIST-KEY = LC_POST. LS_LIST-TEXT = &#x27;Post&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Patch LS_LIST-KEY = LC_PATCH. LS_LIST-TEXT = &#x27;Patch&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Delete LS_LIST-KEY = LC_DELETE. LS_LIST-TEXT = &#x27;Delete&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. CALL FUNCTION &#x27;VRM_SET_VALUES&#x27; EXPORTING ID = LV_VID VALUES = LT_LIST EXCEPTIONS ID_ILLEGAL_NAME = 1 OTHERS = 2.ENDFORM. 2.设置不同模式的URL（1）界面展示 （2）源码1234567891011121314151617FORM SET_URL_VALUE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GET TYPE STRING VALUE &#x27;GET&#x27;, LC_POST TYPE STRING VALUE &#x27;POST&#x27;.*----------------------------Logic-------------------------------------* CHECK P_TXT IS INITIAL. IF P_LOCAT IS NOT INITIAL.&quot;http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx/getMobileCodeInfo P_URL = TEXT-U02. P_TYPE = LC_POST. ELSE.&quot;http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx/getDatabaseInfo P_URL = TEXT-U01. P_TYPE = LC_GET. ENDIF.ENDFORM. 3.创建客户端请求（1）全局变量12345*----------------------------------------------------------------------** Object*----------------------------------------------------------------------*DATA: GO_HTTPCLIENT TYPE REF TO IF_HTTP_CLIENT. （2）源码12345678910111213141516&quot;创建客户端请求 CALL METHOD CL_HTTP_CLIENT=&gt;CREATE_BY_URL EXPORTING URL = P_URL IMPORTING CLIENT = GO_HTTPCLIENT EXCEPTIONS ARGUMENT_NOT_FOUND = 1 PLUGIN_NOT_ACTIVE = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC NE 0. &quot;URL link failed MESSAGE S000 WITH TEXT-E01 DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. 4.设置用户名与密码（1）源码123456789101112&quot;判断是否需要登陆IF P_USER IS INITIAL AND P_PASS IS INITIAL. &quot;抑制登陆框 GO_HTTPCLIENT-&gt;PROPERTYTYPE_LOGON_POPUP = GO_HTTPCLIENT-&gt;CO_DISABLED.ELSE. &quot;验证用户名与密码 CALL METHOD GO_HTTPCLIENT-&gt;AUTHENTICATE EXPORTING USERNAME = P_USER PASSWORD = P_PASS.ENDIF. 5.设置访问方式与发送函数12345678910111213141516171819202122232425262728*--------------------------Variables-----------------------------------* CONSTANTS: LC_GET TYPE STRING VALUE &#x27;GET&#x27;, LC_PUT TYPE STRING VALUE &#x27;PUT&#x27;, LC_POST TYPE STRING VALUE &#x27;POST&#x27;, LC_PATCH TYPE STRING VALUE &#x27;PATCH&#x27;, LC_DELETE TYPE STRING VALUE &#x27;DELETE&#x27;.*----------------------------Logic-------------------------------------* CASE P_TYPE. WHEN LC_GET. &quot;设置请求方式 GET GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_GET ). WHEN LC_PUT. WHEN LC_POST. &quot;设置传输格式 GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CONTENT_TYPE( CONTENT_TYPE = &#x27;application/x-www-form-urlencoded&#x27; ). &quot;( content_type = &#x27;application/json; charset=utf-8&#x27; ) &quot;设置请求方式 POST GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_POST ). &quot;设置JSON内容格式 GV_OUTPUTJSON = &#x27;mobileCode=&#x27; &amp;&amp; P_PHONE &amp;&amp; &#x27;&amp;userID=&#x27;. WHEN LC_PATCH. WHEN LC_DELETE. WHEN OTHERS. ENDCASE. 6.发送请求123456789101112131415161718192021222324252627&quot;抑制登陆框GO_HTTPCLIENT-&gt;PROPERTYTYPE_LOGON_POPUP = GO_HTTPCLIENT-&gt;CO_DISABLED.&quot;设置版本GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_VERSION( IF_HTTP_ENTITY=&gt;CO_PROTOCOL_VERSION_1_1 ).&quot;设置传输内容GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CDATA( DATA = GV_OUTPUTJSON LENGTH = STRLEN( GV_OUTPUTJSON ) ).&quot;发送请求GO_HTTPCLIENT-&gt;SEND( EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 ).IF SY-SUBRC NE 0. &quot;获取失败原因 GO_HTTPCLIENT-&gt;GET_LAST_ERROR( IMPORTING MESSAGE = DATA(LV_MESSAGE) ). &quot;Call Interface Fail MESSAGE S000 WITH LV_MESSAGE DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING.ENDIF. 7.获取发送请求的返回值（1）接收返回值123456789101112131415161718192021222324252627282930313233343536373839*--------------------------Variables-----------------------------------* DATA: LV_STATUSCODE TYPE I.*----------------------------Logic-------------------------------------* &quot;读取远程服务返回的处理过结果 GO_HTTPCLIENT-&gt;RECEIVE( EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3 ). IF SY-SUBRC NE 0. &quot;Return Data Error MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. &quot;读取返回的内容 CLEAR: GV_RETURNJSON. GV_RETURNJSON = GO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_CDATA( ). &quot;将返回参数的回车转换，否则回车会在SAP变成&#x27;#&#x27; REPLACE ALL OCCURRENCES OF REGEX &#x27;\\n&#x27; IN GV_RETURNJSON WITH GC_NULL. &quot;获取运行状态码 GO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_STATUS( IMPORTING CODE = LV_STATUSCODE ). IF LV_STATUSCODE EQ 200. CASE GC_X. WHEN P_AREA. PERFORM GET_NATIONAL_REGIONAL. WHEN P_LOCAT. PERFORM GET_SELECT_PHONE_RESULT. WHEN OTHERS. ENDCASE. ENDIF. &quot;关闭HTTP请求 CALL METHOD GO_HTTPCLIENT-&gt;CLOSE. （2）展示全国地区1234567891011121314151617181920212223*--------------------------Variables-----------------------------------* CONSTANTS: LC_STRING TYPE STRING VALUE &#x27;&lt;string&gt;&#x27;, LC_STRING1 TYPE STRING VALUE &#x27;&lt;/string&gt;&#x27;.*----------------------------Logic-------------------------------------* SPLIT GV_RETURNJSON AT LC_STRING INTO TABLE DATA(LT_RESPON). DELETE LT_RESPON INDEX 1. LOOP AT LT_RESPON INTO DATA(LS_RESPON). REPLACE LC_STRING1 WITH &#x27;&#x27; INTO LS_RESPON. CONDENSE LS_RESPON NO-GAPS. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;HORIZONTAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;CR_LF WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;VERTICAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;NEWLINE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;FORM_FEED WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;BACKSPACE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE ALL OCCURRENCES OF REGEX &#x27;[^[:print:]]+$&#x27; IN LS_RESPON WITH &#x27;&#x27; IGNORING CASE. WRITE: / LS_RESPON. CLEAR: LS_RESPON. ENDLOOP. （3）展示手机归属地12345678910111213141516171819202122232425*--------------------------Variables-----------------------------------* CONSTANTS: LC_SPLITWHERE TYPE STRING VALUE &#x27;&lt;string xmlns=&quot;http://WebXml.com.cn/&quot;&gt;&#x27;, LC_STRING TYPE STRING VALUE &#x27;&lt;/string&gt;&#x27;.*----------------------------Logic-------------------------------------* &quot;截取&lt;string xmlns=&quot;http://WebXml.com.cn/&quot;&gt;右边的值放到内表中 SPLIT GV_RETURNJSON AT LC_SPLITWHERE INTO TABLE DATA(LT_RESPON). DELETE LT_RESPON INDEX 1. LOOP AT LT_RESPON INTO DATA(LS_RESPON). REPLACE LC_STRING WITH &#x27;&#x27; INTO LS_RESPON. CONDENSE LS_RESPON NO-GAPS. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;HORIZONTAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;CR_LF WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;VERTICAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;NEWLINE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;FORM_FEED WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;BACKSPACE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE ALL OCCURRENCES OF REGEX &#x27;[^[:print:]]+$&#x27; IN LS_RESPON WITH &#x27;&#x27; IGNORING CASE. WRITE: / LS_RESPON. CLEAR: LS_RESPON. ENDLOOP. 三、结果展示1.全国地区查询（1）选择画面 （2）结果画面 2.手机号归属地（1）选择画面 （2）结果画面 四、全部代码1.主代码1234567891011121314151617181920212223242526272829303132333435363738REPORT YCALLRESTHTTP MESSAGE-ID ZMESCLA_CYH.*----------------------------------------------------------------------** Include*----------------------------------------------------------------------*INCLUDE YCALLRESTHTTP_TOP.INCLUDE YCALLRESTHTTP_SCR.INCLUDE YCALLRESTHTTP_F01.*----------------------------------------------------------------------** INITIALIZATION*----------------------------------------------------------------------*INITIALIZATION. PERFORM SET_INITIAL_VALUE.*----------------------------------------------------------------------** AT SELECTION-SCREEN OUTPUT*----------------------------------------------------------------------*AT SELECTION-SCREEN OUTPUT. &quot;Set Dropdown Box Values PERFORM SET_LIST_VALUE. &quot;Set Screen Variable Status PERFORM SET_SCREEN_VARIABLE. &quot;Set Test Stauts URL And Type PERFORM SET_URL_VALUE.*----------------------------------------------------------------------** START-OF-SELECTION*----------------------------------------------------------------------*START-OF-SELECTION. &quot;Call URL PERFORM CALL_URL. &quot;Set response logic for call types PERFORM SET_INTERFACE_TYPE_LOGIC. &quot;Send Request PERFORM SEND_REQUEST. &quot;Obtain peripheral system return value PERFORM GET_RETURN_DATA. 2.Include TOP12345678910111213141516171819202122*----------------------------------------------------------------------** Constants*----------------------------------------------------------------------*CONSTANTS: GC_X TYPE C LENGTH 1 VALUE &#x27;X&#x27;, GC_S TYPE C LENGTH 1 VALUE &#x27;S&#x27;, GC_E TYPE C LENGTH 1 VALUE &#x27;E&#x27;, GC_NULL TYPE C LENGTH 1 VALUE &#x27;&#x27;.*----------------------------------------------------------------------** Variables*----------------------------------------------------------------------*DATA: GV_RETURNJSON TYPE STRING, GV_OUTPUTJSON TYPE STRING, GV_MESSAGE TYPE C.*----------------------------------------------------------------------** Object*----------------------------------------------------------------------*DATA: GO_HTTPCLIENT TYPE REF TO IF_HTTP_CLIENT. 3.Include SCR1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&quot;Select Run Type 选择运行类型SELECTION-SCREEN BEGIN OF BLOCK K01 WITH FRAME TITLE TEXT-T01.SELECTION-SCREEN BEGIN OF LINE.&quot;Select Run Type:PARAMETERS P_TXT NO-DISPLAY.SELECTION-SCREEN COMMENT 1(26) TEXT-002 FOR FIELD P_TXT.&quot;Test ModeSELECTION-SCREEN POSITION 32.PARAMETERS: P_TEST RADIOBUTTON GROUP GR01 USER-COMMAND UC1 DEFAULT &#x27;X&#x27;. &quot;测试用URLSELECTION-SCREEN COMMENT 34(27) TEXT-R01 FOR FIELD P_TEST.&quot;CustomizeSELECTION-SCREEN POSITION 62.PARAMETERS: P_CUST RADIOBUTTON GROUP GR01. &quot;自定义URLSELECTION-SCREEN COMMENT 63(32) TEXT-R02 FOR FIELD P_CUST.SELECTION-SCREEN END OF LINE.SELECTION-SCREEN END OF BLOCK K01.&quot;Input peripheral interface information 输入外围接口信息SELECTION-SCREEN BEGIN OF BLOCK K02 WITH FRAME TITLE TEXT-T02.PARAMETERS: P_URL TYPE STRING, P_TYPE TYPE CHAR10 AS LISTBOX VISIBLE LENGTH 10 MODIF ID LIS.SELECTION-SCREEN END OF BLOCK K02.&quot;Inquiry Type 查询类型SELECTION-SCREEN BEGIN OF BLOCK K03 WITH FRAME TITLE TEXT-T03.&quot;Search for national regionsPARAMETERS: P_AREA RADIOBUTTON GROUP GR02 USER-COMMAND UC2 DEFAULT &#x27;X&#x27; MODIF ID TES.&quot;Search for mobile phone locationPARAMETERS: P_LOCAT RADIOBUTTON GROUP GR02 MODIF ID TES.PARAMETERS: P_PHONE TYPE C LENGTH 11 MODIF ID PHO.SELECTION-SCREEN END OF BLOCK K03.&quot;Enter account and passwordSELECTION-SCREEN BEGIN OF BLOCK K04 WITH FRAME TITLE TEXT-T04.PARAMETERS: P_USER TYPE STRING MODIF ID USP, P_PASS TYPE STRING MODIF ID USP. &quot;和输入框样式一致的类型XUNCODESELECTION-SCREEN END OF BLOCK K04. 4.Include F01123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384*&amp;---------------------------------------------------------------------**&amp; Include YCALLRESTHTTP_F01*&amp;---------------------------------------------------------------------**&amp;---------------------------------------------------------------------**&amp; Form SET_LIST_VALUE*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SET_LIST_VALUE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GET TYPE STRING VALUE &#x27;GET&#x27;, LC_PUT TYPE STRING VALUE &#x27;PUT&#x27;, LC_POST TYPE STRING VALUE &#x27;POST&#x27;, LC_PATCH TYPE STRING VALUE &#x27;PATCH&#x27;, LC_DELETE TYPE STRING VALUE &#x27;DELETE&#x27;. DATA: LV_VID TYPE VRM_ID VALUE &#x27;P_TYPE&#x27;, LS_LIST TYPE VRM_VALUE, LT_LIST TYPE VRM_VALUES.*----------------------------Logic-------------------------------------* &quot;Set List Value &quot;Get LS_LIST-KEY = LC_GET. LS_LIST-TEXT = &#x27;Get&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Put LS_LIST-KEY = LC_PUT. LS_LIST-TEXT = &#x27;Put&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Post LS_LIST-KEY = LC_POST. LS_LIST-TEXT = &#x27;Post&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Patch LS_LIST-KEY = LC_PATCH. LS_LIST-TEXT = &#x27;Patch&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. &quot;Delete LS_LIST-KEY = LC_DELETE. LS_LIST-TEXT = &#x27;Delete&#x27;. INSERT LS_LIST INTO TABLE LT_LIST. CALL FUNCTION &#x27;VRM_SET_VALUES&#x27; EXPORTING ID = LV_VID VALUES = LT_LIST EXCEPTIONS ID_ILLEGAL_NAME = 1 OTHERS = 2.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SET_INITIAL_VALUE*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SET_INITIAL_VALUE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GET TYPE STRING VALUE &#x27;GET&#x27;.*----------------------------Logic-------------------------------------* &quot;Set Initial Url Value &quot;http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx/getDatabaseInfo P_URL = TEXT-U01. &quot;Set Call Interface Type Value P_TYPE = LC_GET.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SET_SCREEN_VARIABLE*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SET_SCREEN_VARIABLE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_URL TYPE STRING VALUE &#x27;P_URL&#x27;, LC_LIST TYPE STRING VALUE &#x27;LIS&#x27;, LC_USER TYPE STRING VALUE &#x27;P_USER&#x27;, LC_PASS TYPE STRING VALUE &#x27;P_PASS&#x27;.*----------------------------Logic-------------------------------------* &quot;Set Input URL Not Edit Status LOOP AT SCREEN. IF P_TEST EQ GC_X. IF SCREEN-NAME EQ LC_URL. SCREEN-INPUT = &#x27;0&#x27;. ENDIF. IF SCREEN-GROUP1 EQ LC_LIST. SCREEN-ACTIVE = &#x27;0&#x27;. ENDIF. IF SCREEN-GROUP1 EQ &#x27;USP&#x27;. SCREEN-ACTIVE = &#x27;0&#x27;. ENDIF. IF P_AREA IS NOT INITIAL AND SCREEN-GROUP1 EQ &#x27;PHO&#x27;. SCREEN-ACTIVE = &#x27;0&#x27;. ELSEIF P_AREA IS INITIAL AND SCREEN-GROUP1 EQ &#x27;PHO&#x27;. SCREEN-ACTIVE = &#x27;1&#x27;. ENDIF. ELSE. IF SCREEN-GROUP1 EQ &#x27;TES&#x27; OR SCREEN-GROUP1 EQ &#x27;PHO&#x27;. SCREEN-ACTIVE = &#x27;0&#x27;. ENDIF. ENDIF. IF SCREEN-NAME EQ LC_PASS. SCREEN-INVISIBLE = &#x27;1&#x27;. ENDIF. MODIFY SCREEN. CLEAR: SCREEN. ENDLOOP.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form CALL_URL*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM CALL_URL . &quot;创建客户端请求 CALL METHOD CL_HTTP_CLIENT=&gt;CREATE_BY_URL EXPORTING URL = P_URL IMPORTING CLIENT = GO_HTTPCLIENT EXCEPTIONS ARGUMENT_NOT_FOUND = 1 PLUGIN_NOT_ACTIVE = 2 INTERNAL_ERROR = 3 OTHERS = 4. IF SY-SUBRC NE 0. &quot;URL link failed MESSAGE S000 WITH TEXT-E01 DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. &quot;判断是否需要登陆 IF P_USER IS INITIAL AND P_PASS IS INITIAL. &quot;抑制登陆框 GO_HTTPCLIENT-&gt;PROPERTYTYPE_LOGON_POPUP = GO_HTTPCLIENT-&gt;CO_DISABLED. ELSE. &quot;验证用户名与密码 CALL METHOD GO_HTTPCLIENT-&gt;AUTHENTICATE EXPORTING USERNAME = P_USER PASSWORD = P_PASS. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SET_INTERFACE_TYPE_LOGIC*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SET_INTERFACE_TYPE_LOGIC .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GET TYPE STRING VALUE &#x27;GET&#x27;, LC_PUT TYPE STRING VALUE &#x27;PUT&#x27;, LC_POST TYPE STRING VALUE &#x27;POST&#x27;, LC_PATCH TYPE STRING VALUE &#x27;PATCH&#x27;, LC_DELETE TYPE STRING VALUE &#x27;DELETE&#x27;.*----------------------------Logic-------------------------------------* CASE P_TYPE. WHEN LC_GET. GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_GET ). WHEN LC_PUT. WHEN LC_POST. GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CONTENT_TYPE( CONTENT_TYPE = &#x27;application/x-www-form-urlencoded&#x27; ). &quot;( content_type = &#x27;application/json; charset=utf-8&#x27; ) GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_METHOD( IF_HTTP_REQUEST=&gt;CO_REQUEST_METHOD_POST ). GV_OUTPUTJSON = &#x27;mobileCode=&#x27; &amp;&amp; P_PHONE &amp;&amp; &#x27;&amp;userID=&#x27;. WHEN LC_PATCH. WHEN LC_DELETE. WHEN OTHERS. ENDCASE.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SEND_REQUEST*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SEND_REQUEST . &quot;抑制登陆框 GO_HTTPCLIENT-&gt;PROPERTYTYPE_LOGON_POPUP = GO_HTTPCLIENT-&gt;CO_DISABLED. &quot;设置版本 GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_VERSION( IF_HTTP_ENTITY=&gt;CO_PROTOCOL_VERSION_1_1 ). &quot;设置传输内容 GO_HTTPCLIENT-&gt;REQUEST-&gt;SET_CDATA( DATA = GV_OUTPUTJSON LENGTH = STRLEN( GV_OUTPUTJSON ) ). &quot;发送请求 GO_HTTPCLIENT-&gt;SEND( EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 ). IF SY-SUBRC NE 0. &quot;获取失败原因 GO_HTTPCLIENT-&gt;GET_LAST_ERROR( IMPORTING MESSAGE = DATA(LV_MESSAGE) ). &quot;Call Interface Fail MESSAGE S000 WITH LV_MESSAGE DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form GET_RETURN_DATA*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM GET_RETURN_DATA .*--------------------------Variables-----------------------------------* DATA: LV_STATUSCODE TYPE I.*----------------------------Logic-------------------------------------* &quot;读取远程服务返回的处理过结果 GO_HTTPCLIENT-&gt;RECEIVE( EXCEPTIONS HTTP_COMMUNICATION_FAILURE = 1 HTTP_INVALID_STATE = 2 HTTP_PROCESSING_FAILED = 3 ). IF SY-SUBRC NE 0. &quot;Return Data Error MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E. LEAVE LIST-PROCESSING. ENDIF. &quot;读取返回的内容 CLEAR: GV_RETURNJSON. GV_RETURNJSON = GO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_CDATA( ). &quot;将返回参数的回车转换，否则回车会在SAP变成&#x27;#&#x27; REPLACE ALL OCCURRENCES OF REGEX &#x27;\\n&#x27; IN GV_RETURNJSON WITH GC_NULL. &quot;获取运行状态码 GO_HTTPCLIENT-&gt;RESPONSE-&gt;GET_STATUS( IMPORTING CODE = LV_STATUSCODE ). IF LV_STATUSCODE EQ 200. CASE GC_X. WHEN P_AREA. PERFORM GET_NATIONAL_REGIONAL. WHEN P_LOCAT. PERFORM GET_SELECT_PHONE_RESULT. WHEN OTHERS. ENDCASE. ENDIF. &quot;关闭HTTP请求 CALL METHOD GO_HTTPCLIENT-&gt;CLOSE.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form GET_NATIONAL_REGIONAL*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM GET_NATIONAL_REGIONAL .*--------------------------Variables-----------------------------------* CONSTANTS: LC_STRING TYPE STRING VALUE &#x27;&lt;string&gt;&#x27;, LC_STRING1 TYPE STRING VALUE &#x27;&lt;/string&gt;&#x27;.*----------------------------Logic-------------------------------------* SPLIT GV_RETURNJSON AT LC_STRING INTO TABLE DATA(LT_RESPON). DELETE LT_RESPON INDEX 1. LOOP AT LT_RESPON INTO DATA(LS_RESPON). REPLACE LC_STRING1 WITH &#x27;&#x27; INTO LS_RESPON. CONDENSE LS_RESPON NO-GAPS. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;HORIZONTAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;CR_LF WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;VERTICAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;NEWLINE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;FORM_FEED WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;BACKSPACE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE ALL OCCURRENCES OF REGEX &#x27;[^[:print:]]+$&#x27; IN LS_RESPON WITH &#x27;&#x27; IGNORING CASE. WRITE: / LS_RESPON. CLEAR: LS_RESPON. ENDLOOP.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form GET_SELECT_PHONE_RESULT*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM GET_SELECT_PHONE_RESULT .*--------------------------Variables-----------------------------------* CONSTANTS: LC_SPLITWHERE TYPE STRING VALUE &#x27;&lt;string xmlns=&quot;http://WebXml.com.cn/&quot;&gt;&#x27;, LC_STRING TYPE STRING VALUE &#x27;&lt;/string&gt;&#x27;.*----------------------------Logic-------------------------------------* &quot;截取&lt;string xmlns=&quot;http://WebXml.com.cn/&quot;&gt;右边的值放到内表中 SPLIT GV_RETURNJSON AT LC_SPLITWHERE INTO TABLE DATA(LT_RESPON). DELETE LT_RESPON INDEX 1. LOOP AT LT_RESPON INTO DATA(LS_RESPON). REPLACE LC_STRING WITH &#x27;&#x27; INTO LS_RESPON. CONDENSE LS_RESPON NO-GAPS. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;HORIZONTAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;CR_LF WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;VERTICAL_TAB WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;NEWLINE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;FORM_FEED WITH &#x27;&#x27; INTO LS_RESPON. REPLACE CL_ABAP_CHAR_UTILITIES=&gt;BACKSPACE WITH &#x27;&#x27; INTO LS_RESPON. REPLACE ALL OCCURRENCES OF REGEX &#x27;[^[:print:]]+$&#x27; IN LS_RESPON WITH &#x27;&#x27; IGNORING CASE. WRITE: / LS_RESPON. CLEAR: LS_RESPON. ENDLOOP.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SET_URL_VALUE*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM SET_URL_VALUE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_GET TYPE STRING VALUE &#x27;GET&#x27;, LC_POST TYPE STRING VALUE &#x27;POST&#x27;.*----------------------------Logic-------------------------------------* CHECK P_TXT IS INITIAL. IF P_LOCAT IS NOT INITIAL.&quot;http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx/getMobileCodeInfo P_URL = TEXT-U02. P_TYPE = LC_POST. ELSE.&quot;http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx/getDatabaseInfo P_URL = TEXT-U01. P_TYPE = LC_GET. ENDIF.ENDFORM. 五、参考资料SAP之调用外部接口实例 SAP HTTP调用其他系统接口 ABAP HTTP POST RESTFUL 调用外部接口URL地址 SAP调用外部http url发送接收json格式数据","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Rest接口","slug":"ABAP/Rest接口","permalink":"https://www.yemaojun.top/categories/ABAP/Rest%E6%8E%A5%E5%8F%A3/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP HTTP Rest接口","slug":"ABAP/Rest Interface/SAP HTTP Rest接口/SAP-HTTP-Rest接口","date":"2023-07-04T01:42:58.000Z","updated":"2023-11-02T00:33:09.908Z","comments":true,"path":"2023/07/04/ABAP/Rest Interface/SAP HTTP Rest接口/SAP-HTTP-Rest接口/","link":"","permalink":"https://www.yemaojun.top/2023/07/04/ABAP/Rest%20Interface/SAP%20HTTP%20Rest%E6%8E%A5%E5%8F%A3/SAP-HTTP-Rest%E6%8E%A5%E5%8F%A3/","excerpt":"本篇主要介绍一下项目中如何发布Rest接口。其使用方式和ODATA类似，REST就是选择通过使用http协议和uri，利用client&#x2F;server model对资源进行CRUD(Create&#x2F;Read&#x2F;Update&#x2F;Delete)增删改查操作。","text":"本篇主要介绍一下项目中如何发布Rest接口。其使用方式和ODATA类似，REST就是选择通过使用http协议和uri，利用client&#x2F;server model对资源进行CRUD(Create&#x2F;Read&#x2F;Update&#x2F;Delete)增删改查操作。 SAP HTTP Rest接口 一、Rest接口概念1.介绍REST是以Web为平台的。Web是分布式信息系统为超文本文件和其他对象（资源）提供访问入口。 资源是Web架构的关键点,需要3个操作:识别(identify)，表示(represent)，交互(interact with) 通过这三个操作，又引出三个概念: uri（统一资源标识符包括url和urn）识别资源； representation （例如html，图片，视频等等）表示资源； 通过协议（包括http，ftp等等）与资源进行交互。 所以REST就是选择通过使用http协议和uri，利用client&#x2F;server model对资源进行CRUD(Create&#x2F;Read&#x2F;Update&#x2F;Delete)增删改查操作。 2.请求类型REST不是”rest”这个单词，而是Resource Representational State Transfer的缩写：通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分开来讲： Resource：资源，即数据（网络的核心）； Representational：某种表现形式，比如用JSON，XML，JPEG等； State Transfer：状态变化。通过HTTP动词实现。 REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）。Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。用HTTP协议里的动词来实现资源的添加，修改。 Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。 Web端不再用之前典型的PHP或JSP架构，而是改为前段渲染和附带处理简单的商务逻辑。Web端和Server只使用上述定义的API来传递数据和改变数据状态。格式一般是JSON。 对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）： GET（SELECT）：从服务器获取资源(一项或多项) POST（CREATE）：在服务器新建一个资源 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源） PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性） DELETE（DELETE）：从服务器删除资源。 以上内容摘自：什么是REST？作者：IT修真院。 3.SAP 如何提供 Http Service如果要将 SAP 应用程序服务器 （application server）作为 http 服务提供者，需要定义一个类，这个类必须实现IF_HTTP_EXTENSION 接口。IF_HTTP_EXTENSION 接口只有一个方法 HANDLE_REQUEST。自定义的这个类必须实现 HANDLE_REQUEST 方法。HANDLE_REQUEST 方法的 SERVER 参数是一个 http server 对象 （类型为 ICF 框架的 IF_HTTP_SERVER 接口）。http server 对象具有的属性和方法对请求和响应进行处理。 然后使用 SICF 事务码创建服务，并且将处理器（handler）设定为自定义类。客户端就可以访问这个服务。 以上内容摘自：【ABAP】REST&#x2F;HTTP技术（一）作者：BearGeorge 二、接口的创建1.TCODE SE24&#x2F;SE80 新建接口类使用TCODE SE24 &#x2F; SE80 新建Rest的接口类。 选择类保存的Package。 2.添加接口 IF_HTTP_EXTENSION在新建的Class中选择Interfaces页签，添加接口标准接口IF_HTTP_EXTENSION。输入接口名称之后回车绑定接口。 3.实现接口方法点击Methods页签可以看到上一步绑定接口时，接口需要实现的Method。 双击进入Method，在其中实现Rest接口根据不同请求方式所对应的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164METHOD IF_HTTP_EXTENSION~HANDLE_REQUEST.*--------------------------Variables-----------------------------------* CONSTANTS: LC_I TYPE C LENGTH 1 VALUE &#x27;I&#x27;, LC_EQ TYPE C LENGTH 2 VALUE &#x27;EQ&#x27;, LC_GET TYPE STRING VALUE &#x27;GET&#x27;, LC_PUT TYPE STRING VALUE &#x27;PUT&#x27;, LC_POST TYPE STRING VALUE &#x27;POST&#x27;, LC_PATCH TYPE STRING VALUE &#x27;PATCH&#x27;, LC_DELETE TYPE STRING VALUE &#x27;DELETE&#x27;, LC_METHOD TYPE STRING VALUE &#x27;~request_method&#x27;, LC_RETUTYPE TYPE STRING VALUE &#x27;application/json&#x27;. &quot;应用数据结构与内表 DATA: BEGIN OF LS_DATA, CARRID TYPE SFLIGHT-CARRID, CONNID TYPE SFLIGHT-CONNID, FLDATE TYPE SFLIGHT-FLDATE, PRICE TYPE SFLIGHT-PRICE, CURRENCY TYPE SFLIGHT-CURRENCY, END OF LS_DATA, LT_DATA LIKE TABLE OF LS_DATA, LR_CARRID TYPE RANGE OF SFLIGHT-CARRID, LR_CONNID TYPE RANGE OF SFLIGHT-CONNID, LR_FLDATE TYPE RANGE OF SFLIGHT-FLDATE, LS_CARRID LIKE LINE OF LR_CARRID, LS_CONNID LIKE LINE OF LR_CONNID, LS_FLDATE LIKE LINE OF LR_FLDATE. &quot;JSON抬头结构 DATA: LT_FIELDS TYPE TIHTTPNVP. &quot;接口属性 DATA: LV_MESGTEXT TYPE STRING, LV_RETUCODE TYPE STRING, LV_METHOD TYPE STRING, &quot;获取GET/POST等请求方式 LV_RETU_JSON TYPE STRING, &quot;返回参数的JSON LV_GET_JSONS TYPE STRING, &quot;获取单条的JSON LV_GET_JSONT TYPE STRING. &quot;获取多条的JSON*----------------------------Logic-------------------------------------* &quot;获取JSON抬头数据 SERVER-&gt;REQUEST-&gt;GET_HEADER_FIELDS( CHANGING FIELDS = LT_FIELDS ). &quot;获取请求方式 LV_METHOD = SERVER-&gt;REQUEST-&gt;GET_HEADER_FIELD( NAME = LC_METHOD ). &quot;设置返回数据格式 CALL METHOD SERVER-&gt;RESPONSE-&gt;IF_HTTP_ENTITY~SET_CONTENT_TYPE EXPORTING CONTENT_TYPE = LC_RETUTYPE. &quot;获取JSON行数据 LV_GET_JSONS = SERVER-&gt;REQUEST-&gt;IF_HTTP_ENTITY~GET_CDATA( ). &quot;可选，主要是为了JSON了可读性 REPLACE ALL OCCURRENCES OF REGEX &#x27;\\s(?=([^&quot;]*&quot;[^&quot;]*&quot;)*[^&quot;]*$)&#x27; IN LV_GET_JSONS WITH &#x27;&#x27;. &quot; 正则压缩json字符串空格 &quot;将JSON转换为内表 IF LV_GET_JSONS IS NOT INITIAL. /UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_GET_JSONS CHANGING DATA = LS_DATA ). ELSE. &quot;获取多条数据的JSON LOOP AT LT_FIELDS INTO DATA(LS_FIELDS). TRANSLATE LS_FIELDS-NAME TO UPPER CASE. IF LS_FIELDS-NAME EQ &#x27;LT_DATA&#x27;. LV_GET_JSONT = LS_FIELDS-VALUE. ENDIF. CLEAR: LS_FIELDS. ENDLOOP. /UI2/CL_JSON=&gt;DESERIALIZE( EXPORTING JSON = LV_GET_JSONT CHANGING DATA = LT_DATA ). ENDIF. &quot;判断请求方式 CASE LV_METHOD. WHEN LC_GET OR LC_POST. &quot;获取筛选条件 LS_CARRID-SIGN = LC_I. LS_CARRID-OPTION = LC_EQ. MOVE-CORRESPONDING LS_CARRID TO LS_CONNID. MOVE-CORRESPONDING LS_CARRID TO LS_FLDATE. IF LS_DATA IS NOT INITIAL. APPEND LS_DATA TO LT_DATA. ENDIF. IF LT_DATA IS NOT INITIAL. LOOP AT LT_DATA INTO LS_DATA. IF LS_DATA-CARRID IS NOT INITIAL. LS_CARRID-LOW = LS_DATA-CARRID. APPEND LS_CARRID TO LR_CARRID. ENDIF. IF LS_DATA-CONNID IS NOT INITIAL. LS_CONNID-LOW = LS_DATA-CONNID. APPEND LS_CONNID TO LR_CONNID. ENDIF. IF LS_DATA-FLDATE IS NOT INITIAL. LS_FLDATE-LOW = LS_DATA-FLDATE. APPEND LS_FLDATE TO LR_FLDATE. ENDIF. CLEAR: LS_DATA. ENDLOOP. ENDIF. SELECT CARRID CONNID FLDATE PRICE CURRENCY FROM YSFLIGHT_CYH INTO CORRESPONDING FIELDS OF TABLE LT_DATA WHERE CARRID IN LR_CARRID AND CONNID IN LR_CONNID AND FLDATE IN LR_FLDATE. IF SY-SUBRC NE 0. LV_RETUCODE = &#x27;E&#x27;. LV_MESGTEXT = &#x27;数据未找到&#x27;. ELSE. LV_RETUCODE = &#x27;S&#x27;. LV_MESGTEXT = &#x27;数据查询成功&#x27;. ENDIF. WHEN LC_PUT. WHEN LC_PATCH. WHEN LC_DELETE. WHEN OTHERS. ENDCASE. &quot;返回数据到调用端 IF LV_RETUCODE EQ &#x27;S&#x27;. &quot;将内表转换为JSON CALL METHOD /UI2/CL_JSON=&gt;SERIALIZE EXPORTING DATA = LT_DATA RECEIVING R_JSON = LV_RETU_JSON. &quot;将行数据JSON返回给调用端 SERVER-&gt;RESPONSE-&gt;SET_CDATA( EXPORTING DATA = LV_RETU_JSON ). &quot;设置状态码 SERVER-&gt;RESPONSE-&gt;SET_STATUS( CODE = 200 REASON = &#x27;OK&#x27; ). ELSE. &quot;设置返回的Message信息 SERVER-&gt;RESPONSE-&gt;SET_CDATA( EXPORTING DATA = LV_MESGTEXT ). ENDIF.ENDMETHOD. 三、创建Rest服务1.使用TCODE SICF进入服务选择画面 2.创建服务子节点 3.填入服务元素名称此处是服务的名称，并不一定要与类名一致。 4.设置服务属性参数设置完服务节点的参数属性后，点击最上面的保存按钮。将服务保存到对应的Package‘中。 5.激活服务子节点在刚刚新建子节点的SAP目录下找到自己新建的服务子节点，然后右键激活服务。 如此，一个REST 接口就创建完成了。 四、接口测试1.获取Rest测试链接 直接进行测试时是默认使用GET的请求方式。下图是我使用的别人的图片，因为我的SAP系统并不是这样的，所以此处作为参考借用一下。 上面为其中一种测试的内容，下面这种是直接从网页打开的测试内容。 2.创建SOAP UI的测试项目测试软件的下载可以参考之前的接口文档：SAP Web Service的发布。或点击右边的地址下载SOAP UI。 之后输入刚刚获取到的Rest URL。 会在左边的工具栏中生成本次测试的Rest接口项目。在右侧显示测试接口的内容等信息。 3.添加权限对象直接测试可能会报401没有权限的Error，如下图所示。 只需要按照下图所示的步骤，将自己的SAP账号或SAP顾问提供给你的账号填入下面的输入框中即可。 4.全局测试Rest接口在红框处选择请求类型，然后查看详细的请求过程。 另外在SOAP UI调用接口的时候，可以在类中添加外部端点。查看调用过程中参数的详细掉用过程。 5.添加请求参数上面测试的是查询全部的内容，接下来测试添加筛选参数的测试。因为SOAP UI想要向BODY中添加请求参数必须使用POST或PUT的请求类型，所以在上面代码的编写过程中，我将GET和POST两种请求方式的逻辑合并了。下面是参数请求过程的截图。 五、参考资料SAP发布Rest接口实例（详细步骤） 【ABAP】REST&#x2F;HTTP技术（一） SAP之Http Rest接口发布 什么是REST？","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Rest接口","slug":"ABAP/Rest接口","permalink":"https://www.yemaojun.top/categories/ABAP/Rest%E6%8E%A5%E5%8F%A3/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"Web Service 调用外部接口","slug":"ABAP/SAP Web Services/Web Service 调用外部接口/Web-Service-调用外部接口","date":"2023-06-25T00:49:05.000Z","updated":"2023-07-04T01:47:26.474Z","comments":true,"path":"2023/06/25/ABAP/SAP Web Services/Web Service 调用外部接口/Web-Service-调用外部接口/","link":"","permalink":"https://www.yemaojun.top/2023/06/25/ABAP/SAP%20Web%20Services/Web%20Service%20%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3/Web-Service-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3/","excerpt":"之前记录了如何发布外部系统调用的Web Services，本篇再记录一下如何调用别人提供的WSDL URL接口。","text":"之前记录了如何发布外部系统调用的Web Services，本篇再记录一下如何调用别人提供的WSDL URL接口。 Web Service 调用外部接口 一、创建Web Service1.创建Web Service 2.选择Services 类型 上面选择项的翻译如下： Data Type：数据类型 Message Type：Message 类型 Datatype Enhancement：数据类型增强 Fault Message：故障信息 Service Consumer：服务使用者 RFC Consumer：RFC使用者 Service Provider：服务提供者 Event Provider：事件提供者 Service Variant：服务变式 Consumer Mapping：使用者映射 Operation Mapping：业务映射 Processing Type Domain：处理类型域 **Integration Scenario Def.**：集成场景描述 Semantic Contract： Contract：合同 Contract Implementation：合同执行 Consumer Factory：使用者工厂 Service Group：服务组 3.服务提供类型 选项意思如下： Backend：后端 Enterprise Service Repository：企业服务存储库 **Existing ABAP Object(Inside Out)**：现有ABAP对象（由内而外） External WSDL&#x2F;Schema：外部WSDL&#x2F;架构 4.WSDL&#x2F;架构源 各选项意思： Local File：本地文件 URL：URL链接 HTTP Destination：HTTP 目的地 Service Registry：服务注册中心 5.填写URL 此处填写的URL有个注意事项，如果填写的是内部的Web Service。则不可以直接将如下页签的链接放入。需要放入的是在SOAP中生成&#x2F;发布的WSDL URL。 SOAP中生成的WSDL URL。 若填写的是外部的WSDL URL则需要在URL末尾添加 ?WSDL。如下图所示： 上图图片信息来源：SAP调用外部webservice配置 6.填写用户名与密码 将SAP GUI的账号填入即可。 7.选择Package与设置前缀 8.完成创建与激活 创建完成，接下来激活Web Service。 生成的接口类如下： 二、SOAMANAGER配置1.查询Web Service使用TCODE：SOAMANAGER进入下面的界面后点击Web 服务配置。 在对象名称栏搜索接口生成的Class名称（ABAP Name）ZFMI_CO_YFM_SERVICE_TEST。查找到Web Service。 2.创建WSDL配置 3.设置接口名称与描述 此处最好设置成与接口名称一致，方便后面进行查询和使用。 4.配置WSDL 信息 5.选择绑定 6.接口安全配置 7.HTTP配置 此处需要变更XML。 8.SOAP 协议设置 9.可识别业务信息 10.完成配置 三、程序代码测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364*&amp;---------------------------------------------------------------------**&amp; Report YCALL_WEBSERVICE_CYH*&amp;---------------------------------------------------------------------**&amp; Module / Submodule: ABAP / New Train*&amp;---------------------------------------------------------------------**T_CODE : N/A **CREATER : KF543 **CREATE ON : 2023.06.25 **TYPE : Report **Description : Edit Alv ************************************************************************** Change History ** -------- ---------- ------------- -----------------------------------** Version Date Change By Description ** -------- ---------- ------------- -----------------------------------** N 2023.06.25 KF543 Creater *************************************************************************REPORT YCALL_WEBSERVICE_CYH.*----------------------------------------------------------------------** START-OF-SELECTION*----------------------------------------------------------------------*START-OF-SELECTION. DATA: &quot;创建好的接口的ABAP NAME GO_CLIENTPROXY TYPE REF TO ZFMI_CO_YFM_SERVICE_TEST, GO_SYSEXCEPTION TYPE REF TO CX_AI_SYSTEM_FAULT, GO_APPEXCEPTION TYPE REF TO CX_AI_APPLICATION_FAULT, GV_INDEX TYPE C, &quot;ZFMI_CO_YFM_SERVICE_TEST的输入参数 GS_INPUT TYPE ZFMI_YFM_SERVICE_TEST, &quot;ZFMI_CO_YFM_SERVICE_TEST的输出参数 GS_OUTPUT TYPE ZFMI_YFM_SERVICE_TESTRESPONSE.*----------------------------------------------------------------------** END-OF-SELECTION*----------------------------------------------------------------------*END-OF-SELECTION. TRY . &quot;Create Proxy Object CREATE OBJECT GO_CLIENTPROXY EXPORTING &quot;TCODE:SOAMANAGER中创建的逻辑端口名 LOGICAL_PORT_NAME = &#x27;ZFMI_CO_YFM_SERVICE_TEST&#x27;. &quot;Set Interface Value CLEAr:GS_INPUT. GS_INPUT-I_INPUTDATE = &#x27;20230625&#x27;. GS_INPUT-I_MESGTXT = &#x27;Text&#x27;. CALL METHOD GO_CLIENTPROXY-&gt;YFM_SERVICE_TEST EXPORTING INPUT = GS_INPUT IMPORTING OUTPUT = GS_OUTPUT. IF SY-SUBRC EQ 0. WRITE: / GS_OUTPUT-E_OUTPUTDATE, / GS_OUTPUT-E_MESGTXT. ENDIF. CATCH CX_AI_SYSTEM_FAULT. MESSAGE &#x27;出现异常！！！&#x27; TYPE &#x27;E&#x27;. GV_INDEX = &#x27;1&#x27;. ENDTRY. 在编写完成之后，运行程序其实是遇到了一个问题导致Error了。现将问题记录在下面，以供后续参考。 在运行程序时报错：SSSLERR_PEER_CERT_EXPIRED (-101) 解决方案如下，后续有时间和条件的话单独出一篇讲讲这个Error。 abap 调http请求报SSSLERR_PEER_CERT_UNTRUSTED (-102) SSL handshake failed SSSLERR_PEER_CERT_EXPIRED - Connect from ECC to CPI trial account 四、外围系统接口调整如果外围系统的接口发生了变化，例如对参数的结构进行了新增和删除，则此使需要我们重新对接口进行生成。 1.重新生成和激活 2.重新设置接口属性重新生成的接口会跳转到下图所示的步骤，重新按照上面的步骤进行创建即可。 五、参考资料SAP之WebService调用外部URLWSDL地址 SAP 调用外部系统webservice接口（SOAP-XML） SOAMANAGER","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Web Service","slug":"ABAP/Web-Service","permalink":"https://www.yemaojun.top/categories/ABAP/Web-Service/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP Web Services 发布","slug":"ABAP/SAP Web Services/SAP Web Service的发布/SAP-Web-Services","date":"2023-06-19T07:18:33.000Z","updated":"2023-07-04T01:47:17.840Z","comments":true,"path":"2023/06/19/ABAP/SAP Web Services/SAP Web Service的发布/SAP-Web-Services/","link":"","permalink":"https://www.yemaojun.top/2023/06/19/ABAP/SAP%20Web%20Services/SAP%20Web%20Service%E7%9A%84%E5%8F%91%E5%B8%83/SAP-Web-Services/","excerpt":"最近要做一个以SAP为数据中心的项目，涉及到大量的外部系统交互。所以在这里记录一下SAP Web Services 相关的技术点。方便后续回顾和使用。","text":"最近要做一个以SAP为数据中心的项目，涉及到大量的外部系统交互。所以在这里记录一下SAP Web Services 相关的技术点。方便后续回顾和使用。 SAP Web Services 发布 一、Web Service介绍Web Service就是一个应用程序，它向外界暴露出一个能够通过Web调用的API。Web Service是一种基于Web的中间件技术。用户通过把应用程序的一部分包装成Web服务的形式，将自己的应用程序功能提供给别人，实现应用程序之间的接口。webservice可用于多个系统和SAP系统之间的传输，比较灵活。 根据外部系统提供的webservice的wsdl地址，在SAP系统创建webservice consumer时候输入该URL。使用SOAMANAGER创建逻辑端口，封装函数，在函数里指定端口，并调用类的方法，反之，创建webservice provider，生成wsdl供外部调用。 以上内容摘自ABAP接口创建。 二、创建外部调用的RFC1.创建Function Group如果你有可以使用的Function Group则可以跳过。 （1）使用TCODE SE80 （2）填写Function Group的属性 填写完上面的属性设置后，点击下方的按钮就创建好了一个Function Group。但是此时需要打开该Function Group的Include文件夹进行激活。因为创建好的Function Group的TOP Include是未激活状态。 激活之后就可以继续下面的操作了。 2.使用TCODE SE37 创建RFC 3.设置参数并编写Source Code（1）输入参数切记要勾选Pass By Value按钮，远程调用的RFC均需要勾选这个属性。 （2）输出参数需要勾选Pass By Value按钮。 （3）Source Code1234567891011121314FUNCTION YFM_SERVICE_TEST.*&quot;----------------------------------------------------------------------*&quot;*&quot;Local Interface:*&quot; IMPORTING*&quot; VALUE(I_MESGTXT) TYPE STRING OPTIONAL*&quot; EXPORTING*&quot; VALUE(E_MESGTXT) TYPE STRING*&quot;---------------------------------------------------------------------- IF I_MESGTXT IS INITIAL. E_MESGTXT = &#x27;I_MESGTXT Is Null!&#x27;. ELSE. E_MESGTXT = `Message Value is ` &amp;&amp; I_MESGTXT. ENDIF.ENDFUNCTION. 4.设置远程RFC属性 三、创建Web Service1.使用创建好的RFC创建此处简略介绍一下这种方式，这种方式很快也很便捷。但是这次为了能 详细记录，所以主要介绍下面的通过Package的方式创建Web Service。 使用RFC直接创建。Web Service的路径如下：Utilities-&gt;More Utilities-&gt;Create Web Service-&gt;From the Function Module。 通过这种方式可以直接跳转到下面通过Package创建的第四项填写服务名称与描述。 2.通过Package创建（1）通过TCODE SE80 打开Package （2）选择Service Type 上面选择项的翻译如下： Data Type：数据类型 Message Type：Message 类型 Datatype Enhancement：数据类型增强 Fault Message：故障信息 Service Consumer：服务使用者 RFC Consumer：RFC使用者 Service Provider：服务提供者 Event Provider：事件提供者 Service Variant：服务变式 Consumer Mapping：使用者映射 Operation Mapping：业务映射 Processing Type Domain：处理类型域 **Integration Scenario Def.**：集成场景描述 Semantic Contract： Contract：合同 Contract Implementation：合同执行 Consumer Factory：使用者工厂 Service Group：服务组 （3）服务提供类型 选项意思如下： Backend：后端 Enterprise Service Repository：企业服务存储库 **Existing ABAP Object(Inside Out)**：现有ABAP对象（由内而外） External WSDL&#x2F;Schema：外部WSDL&#x2F;架构 （4）填写服务名称与描述 本次填写的服务名称与Function名称一致。 （5）选择端点类型 因为这一次是对远程RFC的Web Service，所以选择第二项Function Module。 （6）填写Function Module名称 （7）配置服务 功能描述： No Authentication and No Transport Guarantee：无身份验证，无传输保证 Authentication with Certificates and Transport Guarantee：证书认证和运输保证 Authentication with User and Password,No Transport Guarantee：使用用户和密码进行身份验证，无传输保证 Authentication with User and Password and Transport Guarantee：用户和密码身份验证及传输保证 此处选择不同的功能在发布时需要填写不同的校验方式，因为是本地的练习内容，所以选择图示内容即可。 （8）选择Package 此处选择存放Web Service的Package，如果选择的不是本地对象则还需要填写请求号。 （9）完成创建 （10）激活Web Service 进行完上面的操作之后，Function Module的Web Service就创建完成了。之后就是Web Service的发布。 四、发布Web Service1.事务码 SOAMANAGER发布Web Service的事务码是SOAMANAGER。进入后的界面如下： 选择图中选中的Web Service configuration。 2.查找Web Service 在Object Name搜索栏搜索Web Service的名称，可以使用模糊查询的方式。查询到的结果会展示在下方，在下方选择需要发布的Web Service然后单击进入创建发布界面。 3.发布管理界面 如果后续还涉及变更等操作时，也同样是在这个界面进行操作。 4.创建Service（1）服务与绑定名称 输入完服务与绑定名称之后点击上方的next按钮进行下一步。 （2）设置访问安全性 根据上所选择的方式进行设置，本次勾选的下方User ID&#x2F;Password是通过用户账号密码的形式访问的。如果在上面创建Web Service的配置服务时选择不同的内容，此处部分内容或许会变成不可编辑状态。 设置完成后点击Next按钮进入下一步。 （3）完成发布内容 点击上方的Finish按钮完成Web Service的发布工作。 5.完成发布 在上图点击图示按钮查看Service的属性。 6.WSDL URL 记录好下方的WSDL URL将其提供给外部调用SAP系统的开发人员或系统。外部系统就可以通过WSDL URL对SAP系统进行访问。 五、Web Service的测试1.测试软件的安装本次测试Web Service主要使用的是SoapUI。下载链接：https://www.soapui.org/downloads/soapui/ 2.打开测试软件填入WSDL URL新建SOAP 项目。 填入项目名称与上面发布的WSDL URL。 创建时需要填入你的SAP GUI账号与密码。 3.测试项目创建完成界面 创建完成之后在左侧的列表会将创建好的项目展示出来。按照红框标记的内容在左侧的项目栏中双击Request 1打开XML形式的数据格式。如右侧所示，在左边的空白文本框中可以填写传递的参数。但是因为我们在发布Web Service时选择了通过用户名与密码的验证方式，所以需要在面设置访问用的账号密码。但是密码基本也和你的SAP GUI账号一致。 4.设置访问账号与密码 选择权限类型 设置权限账号 5.测试空值与有值两种情况（1）空值测试 返回内容与Function的设置值一致。 （3）有值测试 运行状态信息如下 测试结果正确，Web Service创建与发布成功 六、接口一致性检查当已经发布的接口修改或者增加栏位和结构时，需要重新进行一致性检查，否则WSDL URL地址不会更新。 1.Function 新增两个参数新增一个输入参数和一个输出参数，在Source Code中添加相应的代码逻辑。然后激活Function。 2.打开依照该Function Module创建的Web Service使用TCODE SE80，找到Web Service。在Web Service处右键—&gt;一致性检查（Consistency Check）—&gt;激活。 激活成功后的状态 3.重新发布Web Service和正常发布Web Service的步骤类似，也是先使用TCODE SOAMANAGER。然后一直进入到下面的发布管理界面。 这样就发布成功了，然后对重新发布前后的WSDL URL进行比较。重新发布一般不会变更WSDL URL，但是还是对照下的好。本次我的参数变更并没有修改WSDL URL。 重新使用SOAP UI进行测试，发现修改成功。 七、参考资料 SAP之发布WebService ABAP接口创建 最详细的 SAP ABAP Web Service 创建和消费步骤讲解 SAP Web Service简介与配置方法","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Web Service","slug":"ABAP/Web-Service","permalink":"https://www.yemaojun.top/categories/ABAP/Web-Service/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP 弹框Function汇总","slug":"ABAP/SAP 弹框Function汇总/SAP-弹框Function汇总","date":"2023-06-12T05:55:07.000Z","updated":"2023-09-18T08:56:06.491Z","comments":true,"path":"2023/06/12/ABAP/SAP 弹框Function汇总/SAP-弹框Function汇总/","link":"","permalink":"https://www.yemaojun.top/2023/06/12/ABAP/SAP%20%E5%BC%B9%E6%A1%86Function%E6%B1%87%E6%80%BB/SAP-%E5%BC%B9%E6%A1%86Function%E6%B1%87%E6%80%BB/","excerpt":"在日常开发中经常会使用很多的弹框Function，而这些Function在某些时候可以显著提高编程的效率，所以这篇文章对这些Function进行记录，日后需要参考可以从此处快速查找和使用。","text":"在日常开发中经常会使用很多的弹框Function，而这些Function在某些时候可以显著提高编程的效率，所以这篇文章对这些Function进行记录，日后需要参考可以从此处快速查找和使用。 SAP 弹框Function汇总 一、报表弹框Function1.ALV 报表Function（1）方法名G_DISPLAY_SELECTION_DYNPRO （2）介绍该Function可以将你传入的内表数据通过ALV报表的形式展示出来，而且还可以返回你在报表中光标最后放置的位置的数据索引或双击选中的数据索引。然后根据该索引查找到选择的数据。效果和搜索帮助类似。 在设置报表名称时相对于搜索帮助的字段目录和属性设置要简洁的多。但是有一个注意事项是报表的标题结构和输出内表的结构大体类似，即输出内表中有几个字段，则LS_Header中存在几个用于设置列名的字段结构体。详细的内容可参照下面的源码部分。 （3）图示 （4）源码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061*全局变量结构DATA: BEGIN OF GS_SFLIGHT_S, CARRID LIKE SFLIGHT-CARRID, CONNID LIKE SFLIGHT-CONNID, FLDATE LIKE SFLIGHT-FLDATE, END OF GS_SFLIGHT_S, GT_SFLIGHT_S LIKE TABLE OF GS_SFLIGHT_S.*--------------------------Variables-----------------------------------* CONSTANTS: BEGIN OF LS_HEADER, CARTEXT TYPE CHAR12 VALUE &#x27;Airline Code&#x27;, CONTEXT TYPE CHAR17 VALUE &#x27;Connection Number&#x27;, FLDTEXT TYPE CHAR11 VALUE &#x27;Flight date&#x27;, END OF LS_HEADER. DATA: LV_TABIX TYPE SY-TABIX, LV_HEADER TYPE RGSEL-SEL_TITLE1, LV_TITLE TYPE RGSEL-DYNP_TITLE VALUE &#x27;ALV Report Popup&#x27;.*----------------------------Logic-------------------------------------* CHECK GT_SFLIGHT IS NOT INITIAL. MOVE-CORRESPONDING GT_SFLIGHT TO GT_SFLIGHT_S. SORT GT_SFLIGHT BY CARRID. CALL FUNCTION &#x27;G_DISPLAY_SELECTION_DYNPRO&#x27; EXPORTING ALLOW_PRINT = &#x27; &#x27; &quot;X : 是否允许打印 DYNP_TITLE = LV_TITLE &quot;弹框标题* EXTENDED_DISPLAY = &#x27; &#x27; &quot;X : 是否显示详细信息* FIRST_INDEX = 1 &quot;是否显示行索引* KEY_COLUMNS = 1 &quot;主键字段列 NUMBER_OF_ROWS = 30 &quot;弹出框中展示的行数* SEL_DEFAULT = 0 &quot;索引行 SEL_TITLE1 = LS_HEADER &quot;列表的第一个标题* SEL_TITLE2 = &#x27; &#x27; &quot;列表的第二个标题 SHOW_ALSO_1 = &#x27;X&#x27; &quot;同时显示带有1个条目的列表 START_COLUMN = 1 &quot;开始的列* START_ROW = 3 &quot;开始的行 WIDTH_OF_TITLES = &#x27;X&#x27; &quot;输出宽度考虑标题长度* WITHOUT_SELECTION = &#x27; &#x27; &quot;无选择选项（X=无）* MULTIPLE_SELECTION = &#x27; &#x27; &quot;* ALLOW_SORT = &#x27;X&#x27; &quot; IMPORTING* FIRST_INDEX = &quot;最上面显示的行的索引 SEL_INDEX = SY-TABIX &quot;光标最后所在的行索引* EXT_DISPLAY_SELECTED = &quot;=“X”，如果要求显示详细信息 TABLES SEL_TABLE = GT_SFLIGHT_S &quot;输出表* SEL_LINES = &quot;内部表中的当前条目编号 EXCEPTIONS NO_LINES = 1 NO_LINE_PICKED = 2 OTHERS = 3. IF SY-SUBRC EQ 0. READ TABLE GT_SFLIGHT_S INTO GS_SFLIGHT_S INDEX SY-TABIX. CHECK SY-SUBRC EQ 0. WRITE: / &#x27;CARRID:&#x27;, GS_SFLIGHT_S-CARRID, / &#x27;CONNID:&#x27;, GS_SFLIGHT_S-CONNID, / &#x27;FLDATE:&#x27;, GS_SFLIGHT_S-FLDATE. ENDIF. 选择上面第一条数据，无论是双击或者点击一下点击下方的对勾按钮效果是一样的。 2.报表复选框（1）方法名REUSE_ALV_POPUP_TO_SELECT （2）介绍该Function和上面的ALV报表Function界面类似，但是该Function的弹框中多了一个复选框的字段，使得其可以选择多条数据。使用的形式类似于搜索帮助的多选形式。此外该Function还可以传入Form名称用以添加按钮的响应逻辑。但是该Function设置字段目录的操作较为麻烦，但是可以考虑使用Function REUSE_ALV_FIELDCATALOG_MERGE来快速获取字段目录，但是该Function不允许代码中存在超过72列的代码存在，一旦出现会导致程序Dump。 （3）图示 （4）源码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108*--------------------------Variables-----------------------------------* CONSTANTS: LC_C TYPE C LENGTH 1 VALUE &#x27;C&#x27;, LC_SEL TYPE C LENGTH 3 VALUE &#x27;SEL&#x27;, LC_TABNAME TYPE DD02L-TABNAME VALUE &#x27;SFLIGHT&#x27;. DATA: BEGIN OF LS_SFLIGHT, SEL TYPE C, CARRID TYPE SFLIGHT-CARRID, CONNID TYPE SFLIGHT-CONNID, FLDATE TYPE SFLIGHT-FLDATE, END OF LS_SFLIGHT, LT_SFLIGHT LIKE TABLE OF LS_SFLIGHT. DATA: LT_FIELDCAT TYPE SLIS_T_FIELDCAT_ALV, LS_FIELDCAT LIKE LINE OF LT_FIELDCAT.*----------------------------Logic-------------------------------------* CHECK GT_SFLIGHT IS NOT INITIAL. &quot;Get Selected Data MOVE-CORRESPONDING GT_SFLIGHT TO LT_SFLIGHT. SORT LT_SFLIGHT BY CARRID. &quot;Set Fieldcatalog CALL FUNCTION &#x27;REUSE_ALV_FIELDCATALOG_MERGE&#x27; EXPORTING I_PROGRAM_NAME = SY-REPID I_STRUCTURE_NAME = LC_TABNAME I_INCLNAME = SY-REPID I_BYPASSING_BUFFER = GC_X CHANGING CT_FIELDCAT = LT_FIELDCAT EXCEPTIONS INCONSISTENT_INTERFACE = 1 PROGRAM_ERROR = 2 OTHERS = 3. IF SY-SUBRC &lt;&gt; 0.* Gets The field directory exception MESSAGE TEXT-E02 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF. DELETE LT_FIELDCAT WHERE FIELDNAME NE &#x27;CARRID&#x27; AND FIELDNAME NE &#x27;CONNID&#x27; AND FIELDNAME NE &#x27;FLDATE&#x27;. LOOP AT LT_FIELDCAT INTO LS_FIELDCAT. LS_FIELDCAT-KEY = GC_NULL. LS_FIELDCAT-OUTPUTLEN = 15. CASE LS_FIELDCAT-FIELDNAME. WHEN &#x27;CARRID&#x27;. LS_FIELDCAT-JUST = LC_C. LS_FIELDCAT-SELTEXT_L = &#x27;Airline Code&#x27;. WHEN &#x27;CONNID&#x27;. LS_FIELDCAT-JUST = LC_C. LS_FIELDCAT-SELTEXT_L = &#x27;Connection Number&#x27;. WHEN &#x27;FLDATE&#x27;. LS_FIELDCAT-JUST = LC_C. LS_FIELDCAT-SELTEXT_L = &#x27;Flight date&#x27;. WHEN OTHERS. ENDCASE. MODIFY LT_FIELDCAT FROM LS_FIELDCAT TRANSPORTING KEY SELTEXT_L JUST OUTPUTLEN. CLEAR: LS_FIELDCAT. ENDLOOP. &quot;Call Check Box Function CALL FUNCTION &#x27;REUSE_ALV_POPUP_TO_SELECT&#x27; EXPORTING I_TITLE = &#x27;ALV Repory Check Box&#x27;* I_SELECTION = &#x27;X&#x27; &quot;X:允许选择 SPACE:不允许选择* I_ALLOW_NO_SELECTION = &quot;允许在未选择任何内容的情况下进行复制 I_ZEBRA = &#x27;X&#x27; &quot;斑马线* I_SCREEN_START_COLUMN = 0 &quot;展示开始列* I_SCREEN_START_LINE = 0 &quot;展示开始行* I_SCREEN_END_COLUMN = 0 &quot;展示结束列* I_SCREEN_END_LINE = 0 &quot;展示结束行 I_CHECKBOX_FIELDNAME = LC_SEL &quot;在结构中作为复选框的字段名* I_LINEMARK_FIELDNAME = &quot;行选择颜色信息字段名称* I_SCROLL_TO_SEL_LINE = &#x27;X&#x27; &quot; I_TABNAME = &#x27;LT_SFLIGHT&#x27; &quot;输出内表名称* I_STRUCTURE_NAME = &quot;滚动至默认选择 IT_FIELDCAT = LT_FIELDCAT &quot;输出内表字段目录* IT_EXCLUDING = &quot;Function Code表* I_CALLBACK_PROGRAM = &quot;调用程序的名称* I_CALLBACK_USER_COMMAND = &quot;响应Function Code逻辑Form名称* IS_PRIVATE =* IMPORTING* ES_SELFIELD = &quot;选择的数据信息* E_EXIT = &quot;X：用户关闭弹框标记 TABLES T_OUTTAB = LT_SFLIGHT &quot;输出内表 EXCEPTIONS PROGRAM_ERROR = 1 OTHERS = 2. IF SY-SUBRC EQ 0. SORT LT_SFLIGHT BY SEL DESCENDING. LOOP AT LT_SFLIGHT INTO LS_SFLIGHT GROUP BY ( INDEX = GROUP INDEX SIZE = GROUP SIZE SEL = LS_SFLIGHT-SEL ) ASSIGNING FIELD-SYMBOL(&lt;FT_GROUP&gt;). IF &lt;FT_GROUP&gt;-SEL EQ GC_X. WRITE: / &#x27;总共选中了&#x27;,&lt;FT_GROUP&gt;-SIZE,&#x27;条数据。&#x27;. ENDIF. ENDLOOP. ENDIF. 选择五条数据执行后效果如下： 二、普通弹框Function1.长文本弹框（1）方法名POPUP_WITH_TABLE_DISPLAY_OK （2）介绍该Function只用于将内表中的内容展示出来，但是无法设置其样式而且会自动去除掉内表中用于换行的空行数据，使数据杂糅在一起。但是该Function在使用时十分简洁而且还自带有打印的功能，参数也很简单，若只是展示数据且不考虑样式等信息可以考虑使用该Function。 实际的长文本内容如下： （3）图示 （4）源码参考12345678910111213141516171819202122232425262728*全局变量结构 DATA: BEGIN OF GS_TEXT, TDLINE TYPE CHAR255, END OF GS_TEXT, GT_TEXT LIKE TABLE OF GS_TEXT.*----------------------------Logic-------------------------------------* CHECK GT_TEXT IS NOT INITIAL. &quot;Call Display Text Value Function CALL FUNCTION &#x27;POPUP_WITH_TABLE_DISPLAY_OK&#x27; EXPORTING ENDPOS_COL = 72 &quot;结束列 ENDPOS_ROW = 20 &quot;结束行 STARTPOS_COL = 1 &quot;开始列 STARTPOS_ROW = 1 &quot;开始行 TITLETEXT = &#x27;Display Text Value&#x27; &quot;弹框标题* IMPORTING* CHOISE = &quot;表条目数 TABLES VALUETAB = GT_TEXT &quot;展示内容的内表 EXCEPTIONS BREAK_OFF = 1 OTHERS = 2. IF SY-SUBRC &lt;&gt; 0. &quot;Text Value Function Error MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 2.Form设置的弹框内容（1）方法名BKK_POPUP_DISPLAY_LIST （2）介绍该Function的使用和Function ALV的Function类似，是通过传入Form，然后通过Form中的输出逻辑在弹框中展示文本内容。此外该Function还可以传入自定义按钮，然后通过点击按钮返回按钮的Function Code来进行其他的逻辑处理。 但是该弹框无法输出空行和换行，具体的样式和上面的Function样式类似。 （3）图示 （4）源码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152*&amp;---------------------------------------------------------------------**&amp; Form FORM_SET_TEXT_VALUE*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM FORM_SET_TEXT_VALUE .*--------------------------Variables-----------------------------------* CONSTANTS: LC_TITLE TYPE SYTITLE VALUE &#x27;Text Edit Dialog&#x27;, LC_FORMNAME TYPE SLIS_FORMNAME VALUE &#x27;WRITE_TEXT_VALUE&#x27;.*----------------------------Logic-------------------------------------* CALL FUNCTION &#x27;BKK_POPUP_DISPLAY_LIST&#x27; EXPORTING I_CALLBACK_PROGRAM = SY-REPID &quot;程序名称 I_CALLBACK_WRITE_FORM = LC_FORMNAME &quot;输出Form名称 I_TITLE = LC_TITLE &quot;弹框标题 I_START_COLUMN = 1 &quot;开始列 I_START_ROW = 1 &quot;开始行 I_END_COLUMN = 72 &quot;结束列 I_END_ROW = 15 &quot;结束行* I_DISPLAY_OK_BUTTON = &#x27;X&#x27; &quot;显示OK按钮的开关* I_DISPLAY_CANCEL_BUTTON = &#x27;X&#x27; &quot;显示取消按钮的开关* IMPORTING* ANSWER = &quot;Ok Code* TABLES* USER_BUTTONS = &quot;按钮表 . &quot;按钮内表类型：SMP_DYNTXT IF SY-SUBRC NE 0. &quot;Text Value Function Error MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form WRITE_TEXT_VALUE*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM WRITE_TEXT_VALUE . CHECK GT_TEXT IS NOT INITIAL. LOOP AT GT_TEXT INTO GS_TEXT. WRITE:/ GS_TEXT-TDLINE. CLEAR: GS_TEXT. ENDLOOP.ENDFORM. 3.两段5行文本弹框（1）方法名POPUP_TO_CONFIRM_WITH_MESSAGE （2）介绍该Function只是用来展示部分短文本或提问信息使用的，并没有其他的功能可以自定义添加。但是该Function可以隐藏关闭按钮。然后弹框只能展示五行文本，上面三行下面两行，中间换了一行。所以可以理解为该Function是5行两段的弹框。 点击三个按钮的ANSWER返回值如下： YES：1（字符型） NO：2（字符型） Cancel：A （3）图示 （4）源码参考12345678910111213141516171819202122232425262728*--------------------------Variables-----------------------------------* CONSTANTS: LC_TEXT1 TYPE STRING VALUE &#x27;Msg One&#x27;, LC_TEXT2 TYPE STRING VALUE &#x27;Msg Two&#x27;, LC_TEXT3 TYPE STRING VALUE &#x27;Msg Thr&#x27;, LC_LINE1 TYPE STRING VALUE &#x27;Text One&#x27;, LC_LINE2 TYPE STRING VALUE &#x27;Text Two&#x27;, LC_TITLE TYPE SYTITLE VALUE &#x27;Text Edit Dialog&#x27;.*----------------------------Logic-------------------------------------* CALL FUNCTION &#x27;POPUP_TO_CONFIRM_WITH_MESSAGE&#x27; EXPORTING DEFAULTOPTION = &#x27;Y&#x27; &quot;回答“是”或“否”时的光标位置 DIAGNOSETEXT1 = LC_TEXT1 &quot;第一段第一行文本 DIAGNOSETEXT2 = LC_TEXT2 &quot;第一段第二行文本 DIAGNOSETEXT3 = LC_TEXT3 &quot;第一段第三行文本 TEXTLINE1 = LC_LINE1 &quot;第二段第一行文本 TEXTLINE2 = LC_LINE2 &quot;第二段第二行文本 TITEL = LC_TITLE &quot;弹框标题 START_COLUMN = 25 &quot;开始列 START_ROW = 6 &quot;开始行 CANCEL_DISPLAY = &#x27;X&#x27; &quot;显示关闭按钮* IMPORTING* ANSWER = &quot;用户选择的按钮 . IF SY-SUBRC NE 0. &quot;Text Value Function Error MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 4.无需确认的弹框（1）方法名POPUP_TO_DISPLAY_TEXT （2）介绍该Function只适用于提示信息使用的Function，无其余的功能属性，只能展示文本使用且只有一个按钮。 （3）图示 （4）源码参考123456789101112131415161718*--------------------------Variables-----------------------------------* CONSTANTS: LC_TITLE TYPE STRING VALUE &#x27;Dialog Popup&#x27;, LC_TEXT1 TYPE STRING VALUE &#x27;Text One&#x27;, LC_TEXT2 TYPE STRING VALUE &#x27;Text Two&#x27;.*----------------------------Logic-------------------------------------* CALL FUNCTION &#x27;POPUP_TO_DISPLAY_TEXT&#x27; EXPORTING TITEL = LC_TITLE TEXTLINE1 = LC_TEXT1 TEXTLINE2 = LC_TEXT2* START_COLUMN = 25* START_ROW = 6 . IF SY-SUBRC NE 0. &quot;Text Value Function Error MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 5.横板确认弹框（1）方法名POPUP_TO_CONFIRM （2）介绍该弹框自带一个绿色的问号图标，且只能展示一段文本。但是弹框中存在三个按钮，可以自定义其中两个按钮的文本和图标内容。以及隐藏关闭按钮。可以用作询问交互使用，例如询问是否要退出程序或删除数据等。 点击三个按钮的ANSWER返回值如下： YES：1（字符型） NO：2（字符型） Cancel：A （3）图示 （4）源码参考12345678910111213141516171819202122232425262728293031323334*--------------------------Variables-----------------------------------* CONSTANTS: LC_TEXT1 TYPE STRING VALUE &#x27;Text Content&#x27;, LC_TITLE TYPE STRING VALUE &#x27;Dialog Popup&#x27;.*----------------------------Logic-------------------------------------* CALL FUNCTION &#x27;POPUP_TO_CONFIRM&#x27; EXPORTING TITLEBAR = LC_TITLE &quot;文本标题* DIAGNOSE_OBJECT = &#x27; &#x27; &quot;maintain via SE61 TEXT_QUESTION = LC_TEXT1 &quot;文本内容 TEXT_BUTTON_1 = &#x27;YES&#x27; &quot;第一个按钮文本 ICON_BUTTON_1 = &#x27;ICON_CHECKED&#x27; &quot;第一个按钮图标 TEXT_BUTTON_2 = &#x27;NO&#x27; &quot;第二个按钮文本 ICON_BUTTON_2 = &#x27;ICON_INCOMPLETE&#x27;&quot;第二个按钮图标* DEFAULT_BUTTON = &#x27;1&#x27; &quot;光标位置* DISPLAY_CANCEL_BUTTON = &#x27;X&#x27; &quot;Cancel按钮的隐藏与显示* USERDEFINED_F1_HELP = &#x27; &#x27; &quot;用户定义的F1帮助* START_COLUMN = 25 &quot;开始列* START_ROW = 6 &quot;开始行* POPUP_TYPE = &quot;图标类型* IV_QUICKINFO_BUTTON_1 = &#x27; &#x27; &quot;第一个按钮的提示信息* IV_QUICKINFO_BUTTON_2 = &#x27; &#x27; &quot;第二个按钮的提示信息* IMPORTING* ANSWER = &quot;点击按钮返回的Function Code* TABLES* PARAMETER = &quot;文本参数表(SPAR) EXCEPTIONS TEXT_NOT_FOUND = 1 OTHERS = 2 . IF SY-SUBRC &lt;&gt; 0. &quot;Text Value Function Error MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 6.竖版确认弹框（1）方法POPUP_TO_DECIDE （2）介绍竖版按钮交互弹框，和上面提到的弹框类似，只不过样式不同是竖版的。此外该弹框可以传入三行文本，外加可以设置两个按钮的样式和文本内容。 点击三个按钮的ANSWER返回值如下： Button One：1（字符型） Button Two：2（字符型） Cancel：A （3）图示 （4）参考源码123456789101112131415161718192021222324252627282930*--------------------------Variables-----------------------------------* CONSTANTS: LC_BUT01 TYPE STRING VALUE &#x27;Button One&#x27;, LC_BUT02 TYPE STRING VALUE &#x27;Button Two&#x27;, LC_TEXT1 TYPE STRING VALUE &#x27;Text Content&#x27;, LC_TEXT2 TYPE STRING VALUE &#x27;Text Content One&#x27;, LC_TEXT3 TYPE STRING VALUE &#x27;Text Content Two&#x27;, LC_TITLE TYPE STRING VALUE &#x27;Dialog Popup&#x27;.*----------------------------Logic-------------------------------------* CALL FUNCTION &#x27;POPUP_TO_DECIDE&#x27; EXPORTING* DEFAULTOPTION = &#x27;1&#x27; &quot;光标在文本的位置 TEXTLINE1 = LC_TEXT1 &quot;第一行文本内容 TEXTLINE2 = LC_TEXT2 &quot;第二行文本内容 TEXTLINE3 = LC_TEXT3 &quot;第三行文本内容 TEXT_OPTION1 = LC_BUT01 &quot;第一个按钮文本 TEXT_OPTION2 = LC_BUT02 &quot;第二个文本按钮* ICON_TEXT_OPTION1 = &#x27; &#x27; &quot;第一个按钮图标* ICON_TEXT_OPTION2 = &#x27; &#x27; &quot;第二个按钮图标 TITEL = LC_TITLE &quot;弹框标题 START_COLUMN = 25 &quot;开始列 START_ROW = 5 &quot;开始行* CANCEL_DISPLAY = &#x27;X&#x27; &quot;显示或隐藏Cancel按钮* IMPORTING* ANSWER = &quot;点击按钮返回的Function Code . IF SY-SUBRC &lt;&gt; 0. &quot;Text Value Function Error MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 三、可输入弹框Function1.自定义输入框（1）方法名POPUP_GET_VALUES POPUP_GET_VALUES_USER_HELP （2）介绍两个方法基本一致，用户可以自定义输入框的描述，输入类型与搜索帮助等信息的弹框，在获取用户输入值方面十分方便。此外还可以通过FIELDS参数设置输入框字段的样式等信息。 点击各个按钮返回的RETURNCODE值如下： 关闭按钮：A 对勾确认按钮：空 （3）图示 （4）源码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445*--------------------------Variables-----------------------------------* CONSTANTS: LC_TITLE TYPE STRING VALUE &#x27;Dialog Popup&#x27;. DATA: LV_RETURN TYPE C, LS_FIELDS TYPE SVAL, LT_FIELDS TYPE TABLE OF SVAL.*----------------------------Logic-------------------------------------* CLEAR: LT_FIELDS. &quot;Set Input Value Field LS_FIELDS-TABNAME = &#x27;SFLIGHT&#x27;. LS_FIELDS-FIELDNAME = &#x27;CARRID&#x27;. LS_FIELDS-FIELDTEXT = &#x27;Airline Code&#x27;. APPEND LS_FIELDS TO LT_FIELDS. LS_FIELDS-TABNAME = &#x27;SFLIGHT&#x27;. LS_FIELDS-FIELDNAME = &#x27;CONNID&#x27;. LS_FIELDS-FIELDTEXT = &#x27;Connection Number&#x27;. APPEND LS_FIELDS TO LT_FIELDS. LS_FIELDS-TABNAME = &#x27;SFLIGHT&#x27;. LS_FIELDS-FIELDNAME = &#x27;FLDATE&#x27;. LS_FIELDS-FIELDTEXT = &#x27;Flight Date&#x27;. LS_FIELDS-VALUE = SY-DATUM. APPEND LS_FIELDS TO LT_FIELDS. CALL FUNCTION &#x27;POPUP_GET_VALUES&#x27; EXPORTING* NO_VALUE_CHECK = &#x27; &#x27; &quot;执行或不执行数据类型的检测 POPUP_TITLE = LC_TITLE &quot;弹框标题* START_COLUMN = &#x27;5&#x27; &quot;开始列* START_ROW = &#x27;5&#x27; &quot;开始行 IMPORTING RETURNCODE = LV_RETURN &quot;用户返回值 TABLES FIELDS = LT_FIELDS &quot;文本输入框属性与获取到的值 EXCEPTIONS ERROR_IN_FIELDS = 1 OTHERS = 2 . IF SY-SUBRC &lt;&gt; 0. &quot;Text Value Function Error MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. （5）SVAL结构解析 字段名 含义 TABNAME 输入框参照数据库表名（SE11中定义的数据库表） FIELDNAME 输入框参照对应的字段名 VALUE 用户输入的字段值，也可以在调用前传值视为默认值 FIELD_ATTR 字段的外观设置具体属性见下图 FIELD_OBL 需要的字段标志 COMP_CODE 关系运算符 FIELDTEXT 输入框的文本 COMP_TAB COMP_FIELD NOVALUEHLP 不显示搜索帮助按钮 字段外观设置参考 2.年月日 日期输入框（1）方法 F4_DATE POPUP_TO_SELECT_MONTH F4_DATE_CONTROL ISU_EDM_DATE_CONTROL_POPUP （2）介绍①F4_DATE只弹出一个小calendar，只显示一个月的日期，但是可以变更年和月。但是似乎是我的主题的原因导致显示有点问题，和默认的日期输入框是一样的。 ②POPUP_TO_SELECT_MONTH该弹框只输入年份和月份两个内容，和上面的普通输入框类似，但是两个输入框均为下拉框的形式。 ③F4_DATE_CONTROL这种输入框和传统的搜索帮助自带的日期输入形式一致。 ④ISU_EDM_DATE_CONTROL_POPUP和上面的输入方式类似，但是这种形式的输入框会将周六和周日使用红色字体标注出来。 （3）图示①F4_DATE ②POPUP_TO_SELECT_MONTH ③F4_DATE_CONTROL ④ISU_EDM_DATE_CONTROL_POPUP （4）源码参考①F4_DATE12345678910111213141516171819202122232425262728 CLEAR: GV_DATE. CALL FUNCTION &#x27;F4_DATE&#x27;* EXPORTING* DATE_FOR_FIRST_MONTH = SY-DATUM &quot;用于确定要显示的第一个月* DISPLAY = &#x27; &#x27; &quot;X = 不允许变更* FACTORY_CALENDAR_ID = &#x27; &#x27; &quot;时区（数据来源 TFACD）* GREGORIAN_CALENDAR_FLAG = &#x27; &#x27; &quot;显示公历* HOLIDAY_CALENDAR_ID = &#x27; &#x27; &quot;公共假日日历(数据来源 THOCI)* PROGNAME_FOR_FIRST_MONTH = &#x27; &#x27; &quot;程序名称* DATE_POSITION = &#x27; &#x27; &quot;所选日期的位置 IMPORTING &quot;（空格=中心，T=顶部，B=底部） SELECT_DATE = GV_DATE &quot;返回选中的日期* SELECT_WEEK = &quot;* SELECT_WEEK_BEGIN = &quot;* SELECT_WEEK_END = &quot; EXCEPTIONS CALENDAR_BUFFER_NOT_LOADABLE = 1 DATE_AFTER_RANGE = 2 DATE_BEFORE_RANGE = 3 DATE_INVALID = 4 FACTORY_CALENDAR_NOT_FOUND = 5 HOLIDAY_CALENDAR_NOT_FOUND = 6 PARAMETER_CONFLICT = 7 OTHERS = 8. IF SY-SUBRC &lt;&gt; 0. &quot;Date pop-up abnormality MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. ②POPUP_TO_SELECT_MONTH1234567891011121314151617181920212223242526272829*--------------------------Variables-----------------------------------* DATA: LV_RESULT TYPE SY-SUBRC, LV_MONTH TYPE ISELLIST-MONTH.*----------------------------Logic-------------------------------------* LV_MONTH = SY-DATUM+0(6). CALL FUNCTION &#x27;POPUP_TO_SELECT_MONTH&#x27; EXPORTING ACTUAL_MONTH = LV_MONTH &quot;初始日期* FACTORY_CALENDAR = &#x27; &#x27; &quot;时区（数据来源 TFACD）* HOLIDAY_CALENDAR = &#x27; &#x27; &quot;公共假日日历(数据来源 THOCI)* LANGUAGE = SY-LANGU &quot;系统语言* START_COLUMN = 8 &quot;开始列* START_ROW = 5 &quot;开始行 IMPORTING SELECTED_MONTH = LV_MONTH &quot;返回年月 RETURN_CODE = LV_RESULT&quot;返回值 EXCEPTIONS FACTORY_CALENDAR_NOT_FOUND = 1 HOLIDAY_CALENDAR_NOT_FOUND = 2 MONTH_NOT_FOUND = 3 OTHERS = 4. IF SY-SUBRC &lt;&gt; 0. &quot;Date pop-up abnormality MESSAGE TEXT-E02 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. CHECK LV_RESULT EQ &#x27;0&#x27;. PV_VALUE = LV_MONTH. ③F4_DATE_CONTROL123456789101112131415161718192021222324252627282930313233 CLEAR: GV_DATE. CALL FUNCTION &#x27;F4_DATE_CONTROL&#x27;* EXPORTING* DATE_FOR_FIRST_MONTH = SY-DATUM &quot;用于确定要显示的第一个月* DISPLAY = &#x27; &#x27; &quot;X = 不允许变更* FACTORY_CALENDAR_ID = &#x27; &#x27; &quot;时区（数据来源 TFACD）* GREGORIAN_CALENDAR_FLAG = &#x27; &#x27; &quot;显示公历* HOLIDAY_CALENDAR_ID = &#x27; &#x27; &quot;公共假日日历(数据来源 THOCI)* HOLIDAY_STYLE = &#x27;6&#x27; &quot;公共假日样式* PROGNAME_FOR_FIRST_MONTH = &#x27; &#x27; &quot;程序名称* WEEK_BEGIN_DAY = 1* SELECT_OPTION_WEEK = &#x27; &#x27;* SELECT_OPTION_MONTH = &#x27; &#x27;* DATE_POSITION = &#x27; &#x27; &quot;所选日期的位置 IMPORTING &quot;（空格=中心，T=顶部，B=底部） SELECT_DATE = GV_DATE* SELECT_WEEK =* SELECT_BEGIN =* SELECT_END =* SELECT_MONTH = EXCEPTIONS CALENDAR_BUFFER_NOT_LOADABLE = 1 DATE_AFTER_RANGE = 2 DATE_BEFORE_RANGE = 3 DATE_INVALID = 4 FACTORY_CALENDAR_NOT_FOUND = 5 HOLIDAY_CALENDAR_NOT_FOUND = 6 PARAMETER_CONFLICT = 7 OTHERS = 8. IF SY-SUBRC &lt;&gt; 0. &quot;Date pop-up abnormality MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. ④ISU_EDM_DATE_CONTROL_POPUP123456789101112131415161718192021222324 CLEAR: GV_DATE. CALL FUNCTION &#x27;ISU_EDM_DATE_CONTROL_POPUP&#x27;* EXPORTING* X_DATE = SY-DATUM &quot;起使日期* XT_DAY_INFO = &quot;表包含颜色和工具提示信息* X_DISPLAY = &#x27; &#x27; &quot;是否允许输入* X_YEAR_BEGIN = &quot;初始年份* X_YEAR_END = &quot;最终年份* X_WEEK_BEGIN_DAY = &#x27;1&#x27; &quot;一周开始的日期* X_SELECT_WEEK = &#x27; &#x27; &quot;是否可以选择一周* X_SELECT_MONTH = &#x27; &#x27; &quot;是否可以选择月份* X_WEEKEND_DAYS = &#x27;67&#x27; &quot;定义为周末的日子* X_DISP_HOR_VERT = &#x27;V&#x27; &quot;&#x27;H&#x27;水平或&#x27;V&#x27;水平 IMPORTING Y_DATE_SELECTED = GV_DATE &quot;返回选中的日期* Y_WEEK_SELECTED =* Y_MONTH_SELECTED =* Y_SELECTION_BEGIN =* Y_SELECTION_END = . IF SY-SUBRC &lt;&gt; 0. &quot;Date pop-up abnormality MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 四、文本框Function1.文本框展示内容（1）方法名ADA_POPUP_WITH_TABLE （2）介绍该Function是使用文本框来查看文本内容的，可以对展示的文本内容进行打印和下载成Excel等操作。在展示文本框方面十分的简洁。 （3）图示 （4）源码参考123456789101112131415161718192021222324*全局变量结构 DATA: BEGIN OF GS_TEXT, TDLINE TYPE CHAR255, END OF GS_TEXT, GT_TEXT LIKE TABLE OF GS_TEXT.*--------------------------Variables-----------------------------------* DATA: LV_TITLE TYPE STRING VALUE &#x27;Text Box&#x27;.*----------------------------Logic-------------------------------------* CHECK GT_TEXT IS NOT INITIAL. CALL FUNCTION &#x27;ADA_POPUP_WITH_TABLE&#x27; EXPORTING STARTPOS_COL = 1 STARTPOS_ROW = 1* TITLETEXT = LV_TITLE* WORDWRAP_POSITION = TABLES VALUETAB = GT_TEXT. IF SY-SUBRC NE 0. &quot;Text pop-up function exception MESSAGE TEXT-E04 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 2.文本框编辑内容（1）方法名TERM_CONTROL_EDIT （2）介绍文本框弹框可以用于编辑，而且也接受通过Excel上传数据，完成之后也可以将页面内容下载成Excel。 （3）图示 （4）源码参考123456789101112131415161718192021222324*全局变量结构 DATA: BEGIN OF GS_TEXT, TDLINE TYPE CHAR255, END OF GS_TEXT, GT_TEXT LIKE TABLE OF GS_TEXT.*--------------------------Variables-----------------------------------* DATA: LV_TITLE TYPE STRING VALUE &#x27;Text Box&#x27;.*----------------------------Logic-------------------------------------* CHECK GT_TEXT IS NOT INITIAL. CALL FUNCTION &#x27;TERM_CONTROL_EDIT&#x27; EXPORTING TITEL = LV_TITLE LANGU = SY-LANGU TABLES TEXTLINES = GT_TEXT EXCEPTIONS USER_CANCELLED = 1 OTHERS = 2. IF SY-SUBRC &lt;&gt; 0 AND SY-SUBRC &lt;&gt; 1. &quot;Text pop-up function exception MESSAGE TEXT-E04 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 五、Message 内表1.公有结构与赋值后续代码操作中的全局变量与初始值的设置。 12345678910111213141516171819202122232425262728293031323334&quot;全局内表结构DATA: BEGIN OF GS_MESSAGE, MSGID TYPE BAL_S_MSG-MSGID, MSGNO TYPE BAL_S_MSG-MSGNO, MSGTY TYPE BAL_S_MSG-MSGTY, MSGV1 TYPE BAL_S_MSG-MSGV1, MSGV2 TYPE BAL_S_MSG-MSGV2, END OF GS_MESSAGE, GT_MESSAGE LIKE TABLE OF GS_MESSAGE. &quot;初始值设置 REFRESH: GT_MESSAGE. GS_MESSAGE-MSGID = GC_MESSAGEID. GS_MESSAGE-MSGNO = GC_MESSAGENUMBER. GS_MESSAGE-MSGTY = GC_S. GS_MESSAGE-MSGV1 = &#x27;Message&#x27;. GS_MESSAGE-MSGV2 = &#x27;Success&#x27;. INSERT GS_MESSAGE INTO TABLE GT_MESSAGE. GS_MESSAGE-MSGID = GC_MESSAGEID. GS_MESSAGE-MSGNO = GC_MESSAGENUMBER. GS_MESSAGE-MSGTY = GC_W. GS_MESSAGE-MSGV1 = &#x27;Message&#x27;. GS_MESSAGE-MSGV2 = &#x27;Warning&#x27;. INSERT GS_MESSAGE INTO TABLE GT_MESSAGE. GS_MESSAGE-MSGID = GC_MESSAGEID. GS_MESSAGE-MSGNO = GC_MESSAGENUMBER. GS_MESSAGE-MSGTY = GC_E. GS_MESSAGE-MSGV1 = &#x27;Message&#x27;. GS_MESSAGE-MSGV2 = &#x27;Error&#x27;. INSERT GS_MESSAGE INTO TABLE GT_MESSAGE. 2.可交互的Message List（1）介绍后续开发中如果涉及到需要显示多条Message信息则推荐使用该Function。该Function在显示Message List信息的同时，还可以返回用户点击的按钮信息。如果涉及到后续按钮的点击相关的响应逻辑，则该Function最为推荐。 （2）方法名RSDC_SHOW_MESSAGES_POPUP （3）图示 （4）源码参考12345678910111213141516171819202122*--------------------------Variables-----------------------------------* DATA: LS_COMMAND TYPE BAL_S_EXCM, LT_MESSAGE TYPE RS_T_MSG.*----------------------------Logic-------------------------------------* &quot;Get Message Value MOVE-CORRESPONDING GT_MESSAGE TO LT_MESSAGE. &quot;Call Message List Popup CALL FUNCTION &#x27;RSDC_SHOW_MESSAGES_POPUP&#x27; EXPORTING I_T_MSG = LT_MESSAGE &quot;Message 列表 I_TXT = &#x27;Message List&#x27; &quot;弹框标题* I_WITH_S_ON_EMPTY = RS_C_TRUE &quot;S消息，如果列表为空* I_ONE_MSG_DIRECT = RS_C_TRUE &quot;如果只有一条消息，则直接输出* I_ONE_MSG_TYPE_S = RS_C_TRUE &quot;将消息输出为“S”消息 IMPORTING E_S_EXIT_COMMAND = LS_COMMAND. &quot;弹框点击按钮的返回值 IF SY-SUBRC NE 0. &quot;Message pop-up exception MESSAGE TEXT-E06 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 3.只用于展示Message List（1）介绍该Function的所有参数都是为了展示Message List而设置的。而且在该Function上存在上存在很多的可使用按钮，但是没有可以接收点击按钮的参数，所以该Function无法相互交互。如果后续只是展示数据内容而不涉及点击屏幕按钮后的逻辑则推荐使用这个Function。 其自带的功能按钮十分全面，且可以查看到Message的数据条数。此外，该Function还可以只输出一条数据，使用它的导入参数即可。 （2）方法名C14Z_MESSAGES_SHOW_AS_POPUP （3）图示 （4）源码参考1234567891011121314151617181920212223242526272829*--------------------------Variables-----------------------------------* DATA: LS_MESSAGE TYPE ESP1_MESSAGE_WA_TYPE, LT_MESSAGE TYPE ESP1_MESSAGE_TAB_TYPE.*----------------------------Logic-------------------------------------* &quot;Get Message Value LOOP AT GT_MESSAGE INTO GS_MESSAGE. LS_MESSAGE-LINENO = SY-TABIX. MOVE-CORRESPONDING GS_MESSAGE TO LS_MESSAGE. INSERT LS_MESSAGE INTO TABLE LT_MESSAGE. CLEAR: GS_MESSAGE,LS_MESSAGE. ENDLOOP. CALL FUNCTION &#x27;C14Z_MESSAGES_SHOW_AS_POPUP&#x27;* EXPORTING* I_MSGID =* I_MSGTY =* I_MSGNO =* I_MSGV1 =* I_MSGV2 =* I_MSGV3 =* I_MSGV4 =* I_LINENO = TABLES I_MESSAGE_TAB = LT_MESSAGE. IF SY-SUBRC NE 0. &quot;Message pop-up exception MESSAGE TEXT-E06 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 4.较为复杂的Message List（1）介绍该Function的最终效果与上面第一个Message List一致，但是存在一个问题那便是实现过程较为复杂。需要使用到 MESSAGES_INITIALIZE初始化Message 列表，然后使用MESSAGE_STORE一条一条的添加Message 信息，再调用MESSAGES_STOP刷新Message列表信息，最后再调用MESSAGES_SHOW方法显示Message列表。 （2）方法名 MESSAGES_INITIALIZE：初始化Message List MESSAGE_STORE：传入Message信息 MESSAGES_STOP：刷新Message List MESSAGES_SHOW：调用Message List （3）图示 （4）源码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576*--------------------------Variables-----------------------------------* DATA: LS_WANTED TYPE SMESG, LS_COMMAND TYPE BAL_S_EXCM.*----------------------------Logic-------------------------------------* &quot;Initial Message List CALL FUNCTION &#x27;MESSAGES_INITIALIZE&#x27;. &quot;Set Message List Value LOOP AT GT_MESSAGE INTO GS_MESSAGE. CALL FUNCTION &#x27;MESSAGE_STORE&#x27; EXPORTING ARBGB = GS_MESSAGE-MSGID* EXCEPTION_IF_NOT_ACTIVE = &#x27;X&#x27; MSGTY = GS_MESSAGE-MSGTY MSGV1 = GS_MESSAGE-MSGV1 MSGV2 = GS_MESSAGE-MSGV2* MSGV3 = &#x27; &#x27;* MSGV4 = &#x27; &#x27; TXTNR = GS_MESSAGE-MSGNO* ZEILE = &#x27; &#x27;* IMPORTING* ACT_SEVERITY = &quot;当前消息的级别* MAX_SEVERITY = &quot;最高严重程度 EXCEPTIONS MESSAGE_TYPE_NOT_VALID = 1 NOT_ACTIVE = 2 OTHERS = 3. CLEAR: GS_MESSAGE. ENDLOOP. CALL FUNCTION &#x27;MESSAGES_STOP&#x27;* EXPORTING* I_RESET_IDENTIFICATION = &quot;标志：重置标识* I_IDENTIFICATION = &quot;重置消息的标识* I_RESET_MESSAGES = &quot;标志：重置收集的消息（MESSAGES_INITIALIZE） EXCEPTIONS A_MESSAGE = 1 E_MESSAGE = 2 W_MESSAGE = 3 I_MESSAGE = 4 S_MESSAGE = 5 DEACTIVATED_BY_MD = 6 OTHERS = 7. &quot;Call Message List CALL FUNCTION &#x27;MESSAGES_SHOW&#x27; EXPORTING* CORRECTIONS_OPTION = &#x27; &#x27; &quot;如果出现警告：可能进行更正* CORRECTIONS_FUNC_TEXT = &#x27; &#x27; &quot;功能键“corrections_wanted”的文本* MSG_SELECT_FUNC = &#x27; &#x27; &quot;可能返回消息* MSG_SELECT_FUNC_TEXT = &#x27; &#x27; &quot;功能键“msg_selection_option”的文本* LINE_FROM = &#x27; &#x27; &quot;仅显示具有较长参考线的消息* LINE_TO = &#x27; &#x27; &quot;仅显示具有较短参考线的消息 OBJECT = &#x27;Message List&#x27; &quot;弹框标题* SEND_IF_ONE = &#x27; &#x27; &quot;如果数量=1，则直接发送消息* BATCH_LIST_TYPE = &#x27;J&#x27; &quot;J=作业日志 L=假脱机列表中 B=两者 SHOW_LINNO = ABAP_FALSE &quot;同时显示行号* SHOW_LINNO_TEXT = &#x27; &#x27; &quot;行的列标题* SHOW_LINNO_TEXT_LEN = &#x27;3&#x27; &quot;显示中行的列宽 I_USE_GRID = ABAP_TRUE &quot;使用ALV网格进行显示；否则为经典ALV* I_AMODAL_WINDOW = &#x27; &#x27; &quot;Amodal显示（X=ja） IMPORTING* CORRECTIONS_WANTED = &quot;如果出现警告：需要更正 &quot;Message Collector Type: SMESG MSG_SELECTED = LS_WANTED E_EXIT_COMMAND = LS_COMMAND &quot;点击的按钮 EXCEPTIONS INCONSISTENT_RANGE = 1 NO_MESSAGES = 2 OTHERS = 3. IF SY-SUBRC NE 0. &quot;Message pop-up exception MESSAGE TEXT-E06 TYPE GC_S DISPLAY LIKE GC_E. ENDIF. 六、参考资料SAP 中POPUP函数的弹出框汇总 弹出选择框函数汇总 可输入弹出窗口-[POPUP_GET_VALUES_USER_HELP] 选择画面中日期F4输入帮助函数汇总 SAP-ABAP-ALV弹出窗口供用户输入，获取输入数据 弹出显示多条的message对话框 ABAP 多行消息分别显示弹窗 ABAP在弹窗中输出多条MESSAGE","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Popup Function","slug":"Popup-Function","permalink":"https://www.yemaojun.top/categories/Popup-Function/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"F4搜索帮助自定义列名","slug":"ABAP/F4搜索帮助自定义列名/F4搜索帮助自定义列名","date":"2023-05-31T00:26:14.000Z","updated":"2023-06-15T01:54:35.798Z","comments":true,"path":"2023/05/31/ABAP/F4搜索帮助自定义列名/F4搜索帮助自定义列名/","link":"","permalink":"https://www.yemaojun.top/2023/05/31/ABAP/F4%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E5%90%8D/F4%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E5%90%8D/","excerpt":"之前在进行正是开发时，碰到客户需求想要自定义搜索帮助显示的字段名称。现将设置方法记录如下。","text":"之前在进行正是开发时，碰到客户需求想要自定义搜索帮助显示的字段名称。现将设置方法记录如下。 搜索帮助自定义列名 一、介绍在正式开发过程中有时会有客户要求修改搜索帮助列名的需求，现在将具体的实现步骤记录如下。 二、实现步骤1.获取搜索帮助的字段目录使用Function DDIF_FIELDINFO_GET获取搜索帮助字段目录内表的值，需要注意的是搜索帮助字段目录的内表属性和参数需要设置全，即最好使用这个Function获取字段目录属性，不然可能会发生Dump。 1234567891011121314151617181920DATA: LS_FIELD TYPE DFIES.CALL FUNCTION &#x27;DDIF_FIELDINFO_GET&#x27; EXPORTING TABNAME = &quot;数据库表名称 FIELDNAME = &quot;数据库表中字段的名称 LFIELDNAME = &quot;数据库表中字段的名称 IMPORTING DFIES_WA = LS_FIELD EXCEPTIONS NOT_FOUND = 1 INTERNAL_ERRPR = 2 OTHERS = 3. LS_FIELD-POSITION = 0.LS_FIELD-REPTEXT = &quot;字段名称LS_FIELD-SCRTEXT_S = &quot;字段名称LS_FIELD-SCRTEXT_M = &quot;字段名称LS_FIELD-SCRTEXT_L = &quot;字段名称APPEND LS_FIELD TO LT_FIELD. 2.设置搜索帮助展示的值设置该值时，和传统使用的搜索帮助参数传递不一样，对于需要显示在搜索帮助界面的数据不再是以往的那样一个随意结构的内表即可，而是需要将内表的值按照行列顺序放到一个单字段内表中。例如接下来演示的搜索帮助需要展示两个字段的值和字段名，则用于存值的内表LT_TABLE与LT_DATA之间的赋值如下： 123456789101112131415161718DATA: BEGIN OF LS_DATA, DATA TYPE C LENGTH 255, END OF LS_DATA, LT_DATA LIKE TABLE OF LS_DATA. SELECT CARRID, CONNID FROM SFLIGHT INTO TABLE @DATA(LT_TABLE).LOOP AT LT_TABLE INTO LS_TABLE. LS_DATA-DATA = LS_TABLE-CARRID. APPEND LS_DATA TO LT_DATA. LS_DATA-DATA = LS_TABLE-CONNID. APPEND LS_DATA TO LT_DATA. CLEAR: LS_TABLE.ENDLOOP. 3.调用F4搜索帮助Function1234567891011121314151617181920CALL FUNCTION &#x27;F4IF_INT_TABLE_VALUE_REQUEST&#x27; EXPORTING RETFIELD = &#x27;CARRID&#x27; &quot;字段名称 DYNPPROG = SY-REPID DYNPNR = SY-DYNNR VALUE_ORG = &#x27;C&#x27; TABLES FIELD_TAB = LT_FIELD VALUE_TAB = LT_DATA RETURN_TAB = DATA(LT_RETURN) EXCEPTIONS PARAMETER_ERROR = 1 NO_VALUE_FOUND = 2 OTHERS = 3.CHECK LT_RETURN IS NOT INITIAL.READ TABLE LT_RETURN INTO DATA(LS_RETURN) INDEX 1.CHECK SY-SUBRC EQ 0....","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"搜索帮助","slug":"搜索帮助","permalink":"https://www.yemaojun.top/categories/%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"Excel 上传","slug":"ABAP/Excel-上传/Excel-上传","date":"2023-05-20T12:52:39.000Z","updated":"2024-07-08T09:17:08.016Z","comments":true,"path":"2023/05/20/ABAP/Excel-上传/Excel-上传/","link":"","permalink":"https://www.yemaojun.top/2023/05/20/ABAP/Excel-%E4%B8%8A%E4%BC%A0/Excel-%E4%B8%8A%E4%BC%A0/","excerpt":"之前写了Excel 下载相关的内容，这次把Excel 上传相关的方式以及源代码等做一个笔记收录起来。","text":"之前写了Excel 下载相关的内容，这次把Excel 上传相关的方式以及源代码等做一个笔记收录起来。 Excel 上传 一、Excel上传方式概览1.GUI通过函数GUI_UPLOAD或者CL_GUI_FRONTEND_SERVICES下的GUI_DOWNLOAD方法下载。 该方法需要设置codepage来适应语言，容易出现乱码，更适合TXT，CSV等其他文件的上传。 2.DOI通过函数TEXT_CONVERT_XLS_TO_SAP上传数据。该函数内部是通过DOI的方式获取数据的。获取数据可以直接存到最终需要表，但是不建议直接存，防止非法数据导致的DUMP，例如日期类型数据会有自带的格式。 3.OLE通过函数ALSM_EXCEL_TO_INTERNAL_TABLE上传数据。该函数内部是通过OLE的方式获取数据的。获取数据结果为行列值的形式，需要自行转换到内表中，且值限制为50位。 二、共同代码部分1.弹出文件选择窗口获取文件路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354FORM GET_FILE_PATH CHANGING VALUE(PV_PATH) TYPE RLGRAP-FILENAME. DATA: LV_DEF_PATH TYPE STRING, LT_FILE_TABLE TYPE FILETABLE, LV_RC TYPE I, LV_ACTION TYPE I. CL_GUI_FRONTEND_SERVICES=&gt;DIRECTORY_GET_CURRENT( CHANGING CURRENT_DIRECTORY = LV_DEF_PATH ). CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;FILE_OPEN_DIALOG EXPORTING WINDOW_TITLE = &#x27;Upload File&#x27; DEFAULT_EXTENSION = &#x27;xls&#x27; DEFAULT_FILENAME = &#x27;Export&#x27; FILE_FILTER = CL_GUI_FRONTEND_SERVICES=&gt;FILETYPE_EXCEL INITIAL_DIRECTORY = LV_DEF_PATH CHANGING FILE_TABLE = LT_FILE_TABLE RC = LV_RC USER_ACTION = LV_ACTION EXCEPTIONS FILE_OPEN_DIALOG_FAILED = 1 CNTL_ERROR = 2 ERROR_NO_GUI = 3 NOT_SUPPORTED_BY_GUI = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot;Error when uploading the document MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. GV_MESSAGE = GC_X. EXIT. ENDIF. &quot;用户取消上传操作 IF LV_ACTION = CL_GUI_FRONTEND_SERVICES=&gt;ACTION_CANCEL. GV_MESSAGE = GC_X. EXIT. ENDIF. CHECK LT_FILE_TABLE IS NOT INITIAL. READ TABLE LT_FILE_TABLE INTO DATA(LS_FILE) INDEX 1. CHECK SY-SUBRC EQ 0. IF STRLEN( LS_FILE ) GE 128. &quot;The lengtn of file path should be less than 128. &quot;文件路径长度不可大于128 MESSAGE TEXT-E02 TYPE GC_S DISPLAY LIKE GC_E. ELSE. PV_PATH = LS_FILE. TRANSLATE PV_PATH TO UPPER CASE. ENDIF. FREE: LT_FILE_TABLE.ENDFORM. 2.选择屏幕上传文件路径搜索帮助123456PARAMETERS P_FILE LIKE RLGRAP-FILENAME DEFAULT &#x27;C:\\&#x27;.AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_FILE. CALL FUNCTION &#x27;F4_FILENAME&#x27; IMPORTING FILE_NAME = P_FILE. 三、GUI_UPLOAD上传TXT文档通过GUI_UPLOAD上传TXT文档，输出表字段类型应为字符型。 123456789101112131415161718192021222324252627282930313233DATA: LO_TABLE TYPE REF TO CL_ABAP_TABLEDESCR, LO_STRUC TYPE REF TO CL_ABAP_STRUCTDESCR, LT_DATA TYPE REF TO DATA, LV_LENGTH TYPE I.FIELD-SYMBOLS: &lt;FT_TAB&gt; TYPE STANDARD TABLE.LO_TABLE ?= CL_ABAP_TABLEDESCR=&gt;DESCRIBE_BY_DATA( GT_MAIN[] ).LO_STRUC ?= LO_TABLE-&gt;GET_TABLE_LINE_TYPE( ).DATA(LT_COMPONENTS) = LO_STRUC-&gt;COMPONENTS.DATA(LT_FIELDCAT) = VALUE LVC_T_FCAT( FOR LS_COMPONENTS IN LT_COMPONENTS ( FIELDNAME = LS_COMPONENTS-NAME INTTYPE = &#x27;C&#x27; INTLEN = &#x27;1024&#x27; ) ).CL_ALV_TABLE_CREATE=&gt;CREATE_DYNAMIC_TABLE( EXPORTING IT_FIELDCATALOG = LT_FIELDCAT IMPORTING EP_TABLE = LT_DATA ).ASSIGN LT_DATA-&gt;* TO &lt;FT_TAB&gt;.CL_GUI_FRONTEND_SERVICES=&gt;GUI_UPLOAD( EXPORTING FILENAME = CONV #(PV_PATH) FILETYPE = &#x27;ASC&#x27; HAS_FIELD_SEPARATOR = &#x27;X&#x27; CODEPAGE = &#x27;8500&#x27; IMPORTING FILELENGTH = LV_LENGTH CHANGING DATA_TAB = &lt;FT_TAB&gt; ). 四、TEXT_CONVERT_XLS_TO_SAP上传Excel文档注意如果直接获取日期和时间字段，日期格式需满足’YYYYMMDD’。时间格式需要满足’HHMMSS’。输出到数值字段，不能有负数和千分符。不然数据格式会有异常。 123456789101112131415DATA: LT_DATA LIKE TABLE OF GT_TABLE, LT_RAW_DATA TYPE TRUXS_T_TEXT_DATA.CALL FUNCTION &#x27;TEXT_CONVERT_XLS_TO_SAP&#x27; EXPORTING* I_FIELD_SEPERATOR = 分隔符，下载TEXT可以使用，默认Tab I_LINE_HEADER = &#x27;X&#x27; I_TAB_RAW_DATA = LT_RAW_DATA I_FILENAME = PV_PATH TABLES I_TAB_CONVERTED_DATA = LT_DATA EXCEPTIONS CONVERSION_FAILED = 1 OTHER = 2. 五、ALSM_EXCEL_TO_INTERNAL_TABLE上传Excel文档需要指定开始和结束行和列，值限制50位。 12345678910111213141516DATA: LT_DATA LIKE TABLE OF ALSMEX_TABLINE.CALL FUNCTION &#x27;ALSM_EXCEL_TO_INTERNAL_TABLE&#x27; EXPORTING FILENAME = PV_PATH &quot;上传文件的路径 I_BEGIN_COL = &#x27;1&#x27; &quot;上传Excel获取数据开始列 I_BEGIN_ROW = &#x27;2&#x27; &quot;上传Excel获取数据开始行 I_END_COL = &#x27;9&#x27; &quot;上传Excel获取数据结束列 I_END_ROW = &#x27;5000&#x27; &quot;上传Excel获取数据结束行 TABLES INTERN = LT_DATA EXCEPTIONS INCONSISTENT_PARAMETERS = 1 UPLOAD_OLE = 2 OTHER = 3. 优化Function，将上传用的值长度优化到200位。 内表结构ZSOLETABLE 123ROW TYPES KCD_EX_ROW_NCOL TYPES KCD_EX_COL_NVALUE TYPE CHAR200 Text Field Length 200 Function Global Data 12345678910111213TYPES: &quot;Value of excel-cell TY_D_ITABVALUE TYPE ZSOLETABLE-VALUE, &quot;internal table containing the excel data TY_T_ITAB TYPE ZSOLETABLE OCCURS 0, &quot;line type of sender table BEGIN OF TY_S_SENDERLINE, LINE TYPE C LENGTH 4096, END OF TY_S_SENDERLINE, &quot;sender table TY_T_SENDER TYPE TY_S_SENDERLINE OCCURS 0.CONSTANTS: GC_ESC VALUE `&quot;`. Function 主逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244&quot;Function parameterIMPORTING VALUE(FILENAME) LIKE RLGRAP-FILENAME VALUE(I_BEGIN_COL) TYPE I VALUE(I_BEGIN_ROW) TYPE I VALUE(I_END_COL) TYPE I VALUE(I_END_ROW) TYPE I VALUE(I_SHEET) TYPE I DEFAULT &#x27;1&#x27;TABLES INTERN STRUCTURE ZSOLETABLEEXCEPTIONS INCONSISTENT_PARAMETERS &quot;Function LogicDATA: EXCEL_TAB TYPE TY_T_SENDER, LD_SEPARATOR TYPE C, LD_RC TYPE I, APPLICATION TYPE OLE2_OBJECT, WORKBOOK TYPE OLE2_OBJECT, RANGE TYPE OLE2_OBJECT, WORKSHEET TYPE OLE2_OBJECT, H_CELL TYPE OLE2_OBJECT, H_CELL1 TYPE OLE2_OBJECT.&quot;Function ErrorDEFINE CHECK_ERROR. CASE SY-SUBRC. WHEN 0. WHEN 1. MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4. WHEN OTHERS. RAISE UPLOAD_OLE. ENDCASE.END-OF-DEFINITION.&quot;Check parametersIF I_END_ROW &lt; I_BEGIN_ROW OR I_END_COL &lt; I_BEGIN_COL. RAISE INCONSISTENT_PARAMETERS.ENDIF.&quot;Get TAB-Sign for separation of fieldsCLASS CL_ABAP_CHAR_UTILITIES DEFINITION LOAD.LD_SEPARATOR = CL_ABAP_CHAR_UTILITIES=&gt;HORIZONTAL_TAB.&quot;Open file in ExcelIF APPLICATION-HEADLE = SAPCE OR APPLICATION-HEADLE = -1. CREATE OBJECT APPLICATION &#x27;Excel.Application&#x27;. CHECK_ERROR.ENDIF.CALL METHOD OF APPLICATION &#x27;Workbooks&#x27; = WORKBOOK.CHECK_ERROR.CALL METHOD WORKBOOK &#x27;Open&#x27; EXPORTING #1 = FILENAME.CHECK_ERROR.&quot;Set Property Of Application &#x27;Visible&#x27; = 1.&quot;CHECK_ERROR.&quot;Sheet Select (Ex: 1,2,3,4...)CALL METHOD OF APPLICATION &#x27;Worksheets&#x27; = WORKBOOK EXPORTING #1 = I_SHEET.CHECK_ERROR.&quot;Sheet ActiveCALL METHOD OF WORKSHEET &#x27;Activate&#x27;.&quot;Mark whole spread sheetCALL METHOD OF WORKSHEET &#x27;Cells&#x27; = H_CELL EXPORTING #1 = I_BEGIN_ROW #2 = I_BEGIN_COL.CHECK_ERROR.CALL METHOD OF WORKSHEET &#x27;Cells&#x27; = H_CELL1 EXPORTING #1 = I_END_ROW #2 = I_END_COL.CHECK_ERROR.CALL METHOD OF WORKSHEET &#x27;RANGE&#x27; = RANGE EXPORTING #1 = H_CELL #2 = H_CELL1.CHECK_ERROR.CALL METHOD OF RANGE &#x27;SELECT&#x27;.CHECK_ERROR.&quot;Copy Marked area (whole spread sheet) into ClippboardCALL METHOD OF RANGE TEXT-001. &quot;&#x27;COPY&#x27;CHECK_ERROR.&quot;Read Clipboard into ABAPCALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;CLIPBOARD_IMPORT IMPORTING DATA = EXCEL_TAB EXCEPTIONS CNTL_ERROR = 1 ERROR_NO_GUI = 2 NOT_SUPPORTED_BY_GUI = 3 OTHERS = 4.IF SY-SUBRC &lt;&gt; 0. &quot;Abnormal reading of Copy data. MESSAGE TEXT-E01 TYPE &#x27;A&#x27;.ENDIF.PERFORM SEPARATED_TO_INTERN_CONVERT TABLES EXCEL_TAB INTERN USING LD_SEPARATOR.&quot;Clear ClipboardREFRESH EXCEL_TAB.CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;CLIPBOARD_EXPORT IMPORTING DATA = EXCEL_TAB CHANGING RC = LD_RC EXCEPTIONS CNTL_ERROR = 1 ERROR_NO_GUI = 2 NOT_SUPPORTED_BY_GUI = 3 OTHERS = 4.&quot;Quit Excel and Free ABAP Object - Unfortunately, this does not kill&quot;the Excel ProcessCALL METHOD OF APPLICATION &#x27;QUIT&#x27;.CHECK_ERROR.&quot;to kill the Excel process it&#x27;s necessary to free all used objectsFREE OBJECT : H_CELL,H_CELL1,RANGE,WORKSHEET,WORKBOOK,APPLICATION.CHECK_ERROR.FORM SEPARATED_TO_INTERN_CONVERT TABLES I_TAB TYPE TY_T_SENDER I_INTERN TYPE TY_T_ITAB USING I_SEPARATOR TYPE C. DATA: LV_SIC_TABIX TYPE SY-TABIX, LV_SIC_COL TYPE KCD_EX_COL, LV_FDPOS LIKE SY-FDPOS. REFRESH I_INTERN. LOOP AT I_TAB. LV_SIC_TABIX = SY-TABIX. LV_SIC_COL = 0. WHILE I_TAB CA I_SEPARATOR. LV_FDPOS = SY-FDPOS.&quot;显示查找字符串在母字符串中的位置 LV_SIC_COL = LV_SIC_COL + 1. PERFORM LINE_TO_CELL_SEPARAT TABLES I_INTERN USING I_TAB LV_SIC_TABIX I_SEPARATOR LV_FDPOS. ENDWHILE. IF I_TAB &lt;&gt; SPACE. CLEAR: I_INTERN. I_INTERN-ROW = LV_SIC_TABIX. I_INTERN-COL = LV_SIC_COL + 1. I_INTERN-VALUE = I_TAB. APPEND I_INTERN. ENDIF. ENDLOOP.ENDFORM.FORM LINE_TO_CELL_SEPARAT TABLES I_INTERN TYPE TY_T_ITAB USING I_LINE I_ROW LIKE SY-TABIX CH_CELL_COL TYPE KCD_EX_COL I_SEPARATOR TYPE C I_FDPOS LIKE SY-FDPOS. DATA: LV_STRING TYPE TY_S_SENDERLINE, LV_SIC_INT TYPE I. CLEAR: I_INTERN. LV_SIC_INT = I_FDPOS. I_INTERN-ROW = I_ROW. LV_STRING = I_LINE. I_INTERN-COL = CH_CELL_COL. &quot;Csv Dateien mit separator in Zelle --&gt; &quot;abc;cd&quot; IF ( I_SEPARATOR = &#x27;:&#x27; OR I_SEPARATOR = &#x27;,&#x27; ) AND LV_STRING(1) = GC_ESC. PERFORM LINE_TO_CELL_ESC_SEP USING LV_STRING LV_SIC_INT I_SEPARATOR I_INTERN-VALUE. ELSE. IF LV_SIC_INT &gt; 0. I_INTERN-VALUE = I_LINE(LV_SIC_INT). ENDIF. ENDIF. IF LV_SIC_INT &gt; 0. APPEND I_INTERN. ENDIF. LV_SIC_INT = LV_SIC_INT + 1. I_LINE = I_LINE + LV_SIC_INT.ENDFORM.FORM LINE_TO_CELL_ESC_SEP USING I_STRING I_SIC_INT TYPE I I_SEPARATOR TYPE C I_INTERN_VALUE TYPE TY_D_ITABVALUE. DATA: LV_INT TYPE I, LV_CELL_END TYPE C LEBGTH 2. FIELD-SYMBOLS: &lt;FV_CELL&gt;. LV_CELL_END = GC_ESC. LV_CELL_END+1 = I_SEPARATOR. IF I_STRING CS GC_ESC. I_STRING = I_STRING+1. IF I_STRING CS LV_CELL_END. LV_INT = SY-FDPOS. ASSIGN I_STRING(LV_INT) TO &lt;FV_CELL&gt;. I_INTERN_VALUE = &lt;FV_CELL&gt;. LV_INT = LV_INT + 2. I_SIC_INT = LV_INT. I_STRING = I_STRING+LV_INT. ELSEIF I_STRING CS GC_ESC. LV_INT = SY-FDPOS. ASSIGN I_STRING(LV_INT) TO &lt;FV_CELL&gt;. I_INTERN_VALUE = &lt;FV_CELL&gt;. LV_INT = LV_INT + 1. I_SIC_INT = LV_INT. I_STRING = I_STRING+LV_INT. LV_INT = STRLEN( I_STRING ). IF LV_INT &gt; 0. &quot;Was ist mit csv-Format MESSAGE TEXT-E04 TYPE &#x27;X&#x27;. ENDIF. ELSE. &quot;Was ist mit csv-Format MESSAGE TEXT-E04 TYPE &#x27;X&#x27;. ENDIF. ENDIF.ENDFORM. 六、OLE数据有效性校验以OLE上传的方式为例，对数据进行有效性检查和转化。校验方式其实是通过判断列的数据类型进行校验，而通过这样的方式进行校验则需要知道各个列的类型。最便捷的是通过字段目录，但是也可以通过别的方式获取结构类型，这部分内容在后面记录。 1.获取校验数据类型（1）DDIF_FIELDINFO_GET Function此处介绍一种Function，用于获取表字段的详细信息。 1234567891011121314151617DATA: LT_DFIES TYPE TABLE OF DFIES.CALL FUNCTION &#x27;DDIF_FIELDINFO_GET&#x27; EXPORTING TABNAME = PV_TABNAME &quot;数据库表名称 LANGU = SY-LANGU TABLES DFIES_TAB = LT_DFIES EXCEPTIONS NOT_FOUND = 1 INTERNAL_ERROR = 2 OTHERS = 3.IF SY-SUBRC &lt;&gt; 0. &quot;Implement suitable error handling here MESSAGE TEXT-E03 TYPE GC_S DISPLAY LIKE GC_E. EXIT.ENDIF. （2）DD03N Table123456789101112131415161718DATA: BEGIN OF LS_REFNAME, REF_FIELDNAME LIKE DD03P-FIELDNAME, REF_TABNAME LIKE DD03P-TABNAME, END OF LS_REFNAME, LT_REFNAME LIKE TABLE OF LS_REFNAME. MOVE-CORRESPONDING LT_FIELDCAT TO LT_REFNAME.SORT LT_REFNAME BY REF_TABNAME REF_FIELDNAME.DELETE ADJACENT DUPLICATES FROM LT_REFNAME COMPARING REF_TABNAME REF_FIELDNAME.IF LT_REFNAME IS NOT INITIAL. SELECT * FROM DD03N INTO TABLE @DATA(LT_DD03N) FOR ALL ENTRIES IN @LT_REFNAME WHERE REF_TABNAME = @LT_REFNAME-REF_TABNAME AND REF_FIELDNAME = @LT_REFNAME-REF_FIELDNAME.ENDIF. 2.根据字段属性转化位内部格式1234567891011121314151617181920212223242526272829303132333435DATA: LV_FUNCTION TYPE RS381_FNAM.FIELD-SYMBOLS: &lt;FV_FIELD&gt;.SORT: LT_DATA BY ROW COL, GT_FIELDCATALOG BY COL_POS, LT_DD03N BY TABNAME FIELDNAME.LOOP PT_DATA INTO DATA(LS_DATA). ASSIGN COMPONENT LS_DATA-COL OF STRUCTURE GS_TABLE TO &lt;FV_FIELD&gt;. CHECK SY-SUBRC EQ 0. READ TABLE LT_FIELDCAT WITH KEY COL_POS = LS_DATA-COL INTO DATA(LS_FIELDCAT) BINARY SEARCH. CHECK SY-SUBRC EQ 0. &quot;校验日期类型 PERFORM CHECK_DATA_TYPE USING LS_FIELDCAT LS_DATA CHANGING GS_TABLE. READ TABLE LT_DD03N WITH KEY TABNAME = LS_FIELDCAT-REF_TABNAME FIELDNAME = LS_FIELDCAT-REF_FIELDNAME INTO DATA(LS_DD03N) BINARY SEARCH. IF LS_DD03N-CONVEXIT IS NOT INITIAL. CONDENSE LS_DD03N-CONVEXIT. CONCATENATE &#x27;CONVERSION_EXIT_&#x27; LS_DD03N-CONVEXIT &#x27;_INPUT&#x27; INTO LV_FUNCTION. CALL FUNCTION LV_FUNCTION EXPORT INPUT = &lt;FV_FIELD&gt; IMPORTING OUTPUT = &lt;FV_FIELD&gt;. ENDIF. AT END OF ROW. PERFORM CONVERT_CURR_TO_INTERNAL USING LT_FIELDCAT CHANGING GS_TABLE. APPEND GS_TABLE TO GT_TABLE. ENDAT.ENDLOOP. 3.检查数据类型是否适合（CHECK_DATA_TYPE）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465FORM CHECK_DATA_TYPE USING PS_FIELDCAT TYPE SLIS_FIELDCAT_ALV PS_DATA TYPE ALSMEX_TABLINE CHANGING PS_TABLE LIKE GS_TABLE. DATA: LV_YEAR TYPE N LENGTH 4, LV_MONTH TYPE N LENGTH 2, LV_DAY TYPE N LENGTH 2, LV_TIME TYPE N LENGTH 6. FIELD-SYMBOLS: &lt;FV_FIELD&gt;. ASSIGN COMPONENT LS_FIELDCAT-FIELDNAME OF STRUCTURE GS_TABLE TO &lt;FV_FIELD&gt;. CHECK SY-SUBRC EQ 0. CASE LS_FIELDCAT-INTTYPE. WHEN &#x27;D&#x27;. CLEAR: LV_YEAR,LV_MONTH,LV_DAY. SPLIT LS_DATA-VALUE AT &#x27;.&#x27; INTO LV_YEAR LV_MONTH LV_DAY. IF STRLEN( LV_YEAR ) &lt;&gt; 4. &quot;date format must YYYY.MM.DD MESSAGE S000 WITH TEXT-E03 DISPLAY LIKE GC_E. ENDIF. &lt;FV_FIELD&gt; = LV_YEAR &amp;&amp; LV_MONTH &amp;&amp; LV_DAY. CALL FUNCTION &#x27;DATE_CHECK_PLAUSIBILITY&#x27; EXPORTING DATE = &lt;FV_FIELD&gt; EXPORTING PLAUSIBILITY_CHECK_FAILED = 1 OTHER = 2. IF SY-SUBRC NE 0. &quot;Invalid Date MESSAGE TEXT-E04 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF. WHEN &#x27;T&#x27;. REPLACE ALL OCCURRENCES OF &#x27;:&#x27; IN LS_DATA-VALUE WITH &#x27;&#x27;. CONDENSE LS_DATA-VALUE NO-GAPS. LV_TIME = LS_DATA-VALUE. &lt;FV_FIELD&gt; = LV_TIME. CALL FUNCTION &#x27;TIME_CHECK_PLAUSIBILITY&#x27; EXPORTING TIME = &lt;FV_FIELD&gt; EXPORTING PLAUSIBILITY_CHECK_FAILED = 1 OTHER = 2. IF SY-SUBRC NE 0. &quot;Invalid Time MESSAGE TEXT-E05 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF. WHEN &#x27;P&#x27;. REPLACE ALL OCCURRENCES OF &#x27;,&#x27; IN LS_DATA-VALUE WITH &#x27;&#x27;. IF CL_ABAP_MATCHER=&gt;MATCHES( PATTERN = &#x27;^(-?([1-9]\\d*|0)(\\.\\d*)?)$&#x27; TEXT = LS_DATA-VALUE ) = ABAPFALSE. &quot;Invalid Data Type MESSAGE TEXT-E06 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF. &lt;FV_FIELD&gt; = LS_DATA-VALUE. WHEN OTHERS. &lt;FV_FIELD&gt; = LS_DATA-VALUE. ENDCASE.ENDFORM. 4.金额字段校验（CONVERT_CURR_TO_INTERNAL）12345678910111213141516171819202122232425262728293031FORM CONVERT_CURR_TO_INTERNAL USING PT_FIELDCAT TYPE SLIS_T_FIELDCAT_ALV CHANGING GS_TABLE LIKE GS_TABLE. DATA: LV_AMOUNT TYPE BAPICURR-BAPICURR, LV_WEARS TYPE TCURC-WAERS, LV_LENGTH TYPE I. FIELD-SYMBOLS: &lt;FV_AMOUNT&gt; TYPE ANY, &lt;FV_WAERS&gt; TYPE ANY. READ TABLE PT_FIELDCAT WITH KEY DATATYPE = &#x27;CURR&#x27; TRANSPORTING NO FIELDS. CHECK SY-SUBRC EQ 0. LOOP AT PT_FIELDCAT INTO DATA(LS_FIELDCAT) WHERE DATATYPE = &#x27;CURR&#x27;. ASSIGN COMPONENT LS_FIELDCAT-FIELDNAME OF STRUCTURE GS_TABLE TO &lt;FV_AMOUNT&gt;. ASSIGN COMPONENT LS_FIELDCAT-CFIELDNAME OF STRUCTURE GS_TABLE TO &lt;FV_WAERS&gt;. LV_LENGTH = LS_FIELDCAT-INTLEN. IF &lt;FV_WAERS&gt; IS NOT INITIAL AND &lt;FV_AMOUNT&gt; IS NOT INITIAL. LV_AMOUNT = &lt;FV_AMOUNT&gt;. LV_WEARS = &lt;FV_WAERS&gt;. CALL FUNCTION &#x27;BAPI_CURRENCY_CONV_TO_INTERNAL&#x27; EXPORTING CURRENCY = LV_WAERS AMOUNT_EXTERNAL = LV_AMOUNT MAX_NUMBER_OF_DIGITS = LV_LENGTH IMPORTING AMOUNT_INTERNAL = &lt;FV_AMOUNT&gt;. ENDIF. ENDLOOP.ENDFORM. 七、OLE上传代码1.流程代码123456789101112131415161718DATA: LV_FILE TYPE RLGRAP-FILENAME, LV_ERROR TYPE C, LV_ANSWER TYPE C, LT_EXCEL TYPE TABLE OF ALSMEX_TABLINE. &quot;获取上传文件路径PERFORM GET_UPLOAD_FILE CHANGING LV_FILE.&quot;校验文件路径与文件格式是否正确PERFORM CHECK_FILE_PATH USING LV_FILE CHANGING LV_ERROR.CHECK LV_ERROR IS INITIAL.&quot;获取上传文件中的数据PERFORM GET_UPLOAD_DATA TABLES LT_EXCEL USING LV_FILE.&quot;校验上传的数据PERFORM CHECK_UPLOAD_DATA TABLES LT_EXCEL. 2.流程源代码（1）获取上传文件路径（GET_UPLOAD_FILE）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152FORM GET_UPLOAD_FILE CHANGING VALUE(PV_PATH) TYPE RLGRAP-FILENAME. DATA: LV_RC TYPE I, LT_FILE TYPE FILETABLE, LV_FILE TYPE ELGRAP-FILENAME, LV_DEF_PATH TYPE STRING. CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;DIRECTORY_GET_CURRENT CHANGING CURRENT_DIRECTORY = LV_DEF_PATH. CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;FILE_OPEN_DIALOG EXPORTING FILE_FILTER = &#x27;*.xls&#x27; INITIAL_DIRECTORY = LV_DEF_PATH CHANGING FILE_TABLE = LT_FILE RC = LV_RC USER_ACTION = LV_ACTION EXCEPTIONS FILE_OPEN_DIALOG_FAILED = 1 CNTL_ERRO = 2 ERROR_NO_GUI = 3 NOT_SUPPORTED_BY_GUI = 4 OTHERS = 5. IF SY-SUBRC &lt;&gt; 0. &quot;Error when uploading the document MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. GV_MESSAGE = GC_X. EXIT. ENDIF. &quot;用户取消上传操作 IF LV_ACTION = CL_GUI_FRONTEND_SERVICES=&gt;ACTION_CANCEL. GV_MESSAGE = GC_X. EXIT. ENDIF. CHECK LT_FILE IS NOT INITIAL. READ TABLE LT_FILE INTO DATA(LS_FILE) INDEX 1. CHECK SY-SUBRC EQ 0. IF STRLEN( LS_FILE ) GE 128. &quot;The lengtn of file path should be less than 128. &quot;文件路径长度不可大于128 MESSAGE TEXT-E02 TYPE GC_S DISPLAY LIKE GC_E. ELSE. PV_PATH = LS_FILE. TRANSLATE PV_PATH TO UPPER CASE. ENDIF. FREE: LT_FILE_TABLE.ENDFORM. （2）校验文件路径与文件格式是否正确（CHECK_FILE_PATH）123456789101112131415161718192021222324FORM CHECK_FILE_PATH USING VALUE(PV_PATH) TYPE RLGRAP-FILENAME CHANGING VALUE(PV_ERROR). DATA: LV_LEN TYPE I, LV_TMP TYPE C, LV_EXTENDNAME TYPE C LENGTH 4, IF PV_PATH IS INITIAL. &quot;The Excel file was not normally upload. MESSAGE TEXT-E06 TYPE &#x27;I&#x27; DISPLAY LIKE GC_E. PV_ERROR = GC_X. ELSE. LV_LEN = STRLEN( PV_PATH ) - 5. SPLIT PV_PATH+LV_LEN AT &#x27;.&#x27; INTO LV_TMP LV_EXTENDNAME. CONDENSE LV_EXTENDNAME. TRANSLATE LV_EXTENDNAME TO UPPER CASE. IF LV_EXTENDNAME &lt;&gt; &#x27;XLS&#x27; AND LV_EXTENDNAME &lt;&gt; &#x27;XLSX&#x27;. &quot;Please check the excel file type MESSAGE TEXT-E07 TYPE &#x27;I&#x27; DISPLAY LIKE GC_E. PV_ERROR = GC_X. ENDIF. ENDIF.ENDFORM. （3）获取上传文件中的数据（GET_UPLOAD_DATA）1234567891011121314151617181920212223242526FORM GET_UPLOAD_DATA TABLES PT_EXCEL STRUCTURE ALSMEX_TABLINE USING VALUE(PV_PATH) TYPE RLGRAP-FILENAME. DATA: LT_FIELDCATALOG LIKE GT_FIELDCATALOG. MOVE-CORRESPONDING GT_FIELDCATALOG TO LT_FIELDCATALOG. DELETE LT_FIELDCATALOG WHERE TECH = GC_X. CLEAR: GV_COL,PT_EXCEL. GV_COL = LINES( LT_FIELDCATALOG ). CALL FUNCTION &#x27;ALSM_EXCEL_TO_INTERNAL_TABLE&#x27; EXPORTING FILENAME = PV_PATH I_BEGIN_COL = &#x27;1&#x27; I_BEGIN_ROW = &#x27;2&#x27; I_END_COL = GV_COL I_END_ROW = 65536 I_SHEET = &#x27;1&#x27; TABLES INTERN = PT_EXCEL[] EXCEPTIONS INCONSISTENT_PARAMETERS = 1 UPLOAD_OLE = 2 OTHER = 3. FREE: LT_FIELDCATALOG.ENDFORM. （4）校验上传的数据（CHECK_UPLOAD_DATA）123456789101112131415161718192021222324252627282930313233343536373839FORM CHECK_UPLOAD_DATA TABLES PT_EXCEL STRUCTURE ALSMEX_TABLINE. DATA: LV_FUNCTION TYPE RS381_FNAM. FIELD-SYMBOLS: &lt;FV_FIELD&gt;. SORT: LT_DATA BY ROW COL, GT_FIELDCATALOG BY COL_POS, LT_DD03N BY TABNAME FIELDNAME. LOOP PT_DATA INTO DATA(LS_DATA). ASSIGN COMPONENT LS_DATA-COL OF STRUCTURE GS_TABLE TO &lt;FV_FIELD&gt;. CHECK SY-SUBRC EQ 0. READ TABLE LT_FIELDCAT WITH KEY COL_POS = LS_DATA-COL INTO DATA(LS_FIELDCAT) BINARY SEARCH. CHECK SY-SUBRC EQ 0. &quot;校验日期类型 PERFORM CHECK_DATA_TYPE USING LS_FIELDCAT LS_DATA CHANGING GS_TABLE. READ TABLE LT_DD03N WITH KEY TABNAME = LS_FIELDCAT-REF_TABNAME FIELDNAME = LS_FIELDCAT-REF_FIELDNAME INTO DATA(LS_DD03N) BINARY SEARCH. IF LS_DD03N-CONVEXIT IS NOT INITIAL. CONDENSE LS_DD03N-CONVEXIT. CONCATENATE &#x27;CONVERSION_EXIT_&#x27; LS_DD03N-CONVEXIT &#x27;_INPUT&#x27; INTO LV_FUNCTION. CALL FUNCTION LV_FUNCTION EXPORT INPUT = &lt;FV_FIELD&gt; IMPORTING OUTPUT = &lt;FV_FIELD&gt;. ENDIF. AT END OF ROW. PERFORM CONVERT_CURR_TO_INTERNAL USING LT_FIELDCAT CHANGING GS_TABLE. APPEND GS_TABLE TO GT_TABLE. ENDAT. ENDLOOP. &quot;根据主键值进行排序和去重ENDFORM.","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Excel Upload","slug":"ABAP/Excel-Upload","permalink":"https://www.yemaojun.top/categories/ABAP/Excel-Upload/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"Excel 下载","slug":"ABAP/Excel-下载/Excel下载","date":"2023-05-20T12:44:15.000Z","updated":"2024-07-24T07:50:56.191Z","comments":true,"path":"2023/05/20/ABAP/Excel-下载/Excel下载/","link":"","permalink":"https://www.yemaojun.top/2023/05/20/ABAP/Excel-%E4%B8%8B%E8%BD%BD/Excel%E4%B8%8B%E8%BD%BD/","excerpt":"ABAP Excel下载三种方式的代码和技术说明，分别介绍了OLE、DOI和XML和ALV Tree下载的内容。","text":"ABAP Excel下载三种方式的代码和技术说明，分别介绍了OLE、DOI和XML和ALV Tree下载的内容。 Excel 下载 一、Excel下载方式概览1.OLE 早期SAP解决与Office集成的技术。 OLE语法参照VBA，在ABAP中调用方法来操作Excel。 语法的友好性差，另外将数据从ABAP内表写入到Excel速度特别慢。 2.DOI DOI时Desktop Office Integration的缩写，是SAP提供的解决与Office集成的技术方案。 DOI可以看作OLE的替代品，用面向对象的方式实现。 3.XML 使用Open Office技术，实现与ALV自带下载功能一致的下载效果。 使用方法简单适合于下载ALV报表，可以直接使用ALV设置的FIELDCATALOG，LAYOUT，SORT等属性对下载数据设置格式，无需其他数据转换。 二、Excel 代码共通部分1.全局变量的定义1234567891011121314151617181920212223242526272829*Excel File Name VariablesDATA: GV_TITLE TYPE STRING, GV_COL TYPE I, GV_ROW TYPE I.TYPES: BEGIN OF TY_LONG, DATA TYPE C LENGTH 8192, END OF TY_LONG.*Excel related variables OLEDATA: GT_DOW_DATA TYPE TABLE OF TY_LONG.DATA: GO_EXCEL TYPE OLE2_OBJECT, GO_BOOKS TYPE OLE2_OBJECT, GO_SHEET TYPE OLE2_OBJECT, GO_COLUMNS TYPE OLE2_OBJECT, GO_CELLINT TYPE OLE2_OBJECT, GO_RANGE TYPE OLE2_OBJECT, GO_BORDER TYPE OLE2_OBJECT. *Excel related variables DOIDATA: GO_CONTROL TYPE REF TO I_OI_CONTAINER_CONTROL, GO_DOCU_PROXY TYPE REF TO I_OI_DOCUMENT_PROXY, GO_DOISHEET TYPE REF TO I_OI_SPREADSHEET, GO_ERROR TYPE REF TO I_OI_ERROR. 2.获取下载文件的路径（1）获取下载路径与检测文件存在与否模板1234567891011PERFORM GET_FILE_PATH CHANGING LV_FULLPATH.FORM GET_FILE_PATH CHANGING VALUE(PV_FULLPATH) TYPE STRING. CLEAR: GV_MESSAGE. &quot;Get download path PERFORM GET_DOWNLOAD_FILE CHANGING PV_FULLPATH. CHECK GV_MESSAGE IS INITIAL. &quot;Check that download files exist,and if they do,delete PERFORM CHECK_FILE_EXIS USING PV_FULLPATH.ENDFORM. （2）获取下载路径1234567891011121314151617181920212223242526272829303132333435363738394041424344FORM GET_DOWNLOAD_FILE CHANGING VALUE(PV_PATH) TYPE STRING.*---------------------------Variables----------------------------* CONSTANTS: LC__ TYPE C LENGTH 1 VALUE &#x27;_&#x27;. DATA: LV_FNAME TYPE STRING, LV_PATH TYPE STRING, LV_FILENAME TYPE STRING, LV_TYPENAME TYPE STRING VALUE &#x27;xlsx&#x27;, LV_TITLE TYPE STRING VALUE &#x27;Excel Downolad&#x27;.*-----------------------------Logic------------------------------* &quot;Set Download file Name CONCATENATE GV_TITLE SY-DATUM SY-UZEIT INTO LV_FILENAME SEPARATED BY LC__. &quot;Gets the current default path. CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;DIRECTORY_GET_CURRENT CHANGING CURRENT_DIRECTORY = PV_PATH. &quot;Shell selection save path CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;FILE_SAVE_DIALOG EXPORTING WINDOW_TITLE = LV_TITLE DEFAULT_EXTENSION = LV_TYPENAME DEFAULT_FILE_NAME = LV_FILENAME FILE_FILTER = CL_GUI_FRONTEND_SERVICES=&gt;FILETYPE_ALL INITIAL_DIRECTORY = PV_PATH CHANGING FILENAME = LV_FNAME PATH = LV_PATH FULLPATH = PV_PATH EXCEPTIONS CNTL_ERROR = 1 ERROR_NO_GUI = 2 NOT_SUPPORTED_BY_GUI = 3 OTHERS = 5. IF PV_PATH IS INITIAL. GV_MESSAGE = GC_X. &quot;Download File Path Error MESSAGE TEXT-E01 TYPE GC_S DISPLAY LIKE GC_E. EXIT. ENDIF.ENDFORM. （3）检查文件存在与否1234567891011121314151617181920212223242526272829303132333435363738394041424344FORM CHECK_FILE_EXIS USING VALUE(PV_PATH) TYPE STRING.*---------------------------Variables----------------------------* CONSTANTS: LC_I TYPE C LENGTH 1 VALUE &#x27;I&#x27;. DATA: LV_RC TYPE I, LV_RES TYPE C.*-----------------------------Logic------------------------------* &quot;Does the verification file exist? CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;FILE_EXIST EXPORTING FILE = PV_PATH RECEIVING RESULT = LV_RES EXCEPTIONS CNTL_ERROR = 1 ERROR_NO_GUI = 2 WRONG_PARAMETER = 3 NOT_SUPPORTED_BY_GUI = 4 OTHERS = 5. &quot;Test results CHECK LV_RES EQ GC_X. CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;FILE_DELETE EXPORTING FILENAME = PV_PATH CHANGING RC = LV_RC EXCEPTIONS FILE_DELETE_FAILED = 1 CNTL_ERROR = 2 ERROR_NO_GUI = 3 FILE_NOT_FOUND = 4 ACCESS_DENIED = 5 UNKNOWN_ERROR = 6 NOT_SUPPORTED_BY_GUI = 7 WRONG_PARAMETER = 8 OTHERS = 9. IF SY-SUBRC NE 0. GV_MESSAGE = GC_X. &quot;File Opened MESSAGE TEXT-E02 TYPE GC_I DISPLAY LIKE GC_E. ENDIF.ENDFORM. 三、下载SMW0中的模板SMW0上传的模板，直接下载数据到本地。结合上面的获取下载路径，将获取到的下载路径填入变量 PV_PATH中即可。 123456789101112131415161718192021222324252627282930CONSTANTS: LC_I TYPE C LENGTH 1 VALUE &#x27;I&#x27;, LC_MI TYPE C LENGTH 2 VALUE &#x27;MI&#x27;.DATA: LV_FNAME TYPE RLGRAP-FILENAME, LV_KEY TYPE WWWDATATAB, LV_RC TYPE I, LV_OBJID TYPE WWWDATA-OBJID VALUE &#x27;上传时的名称&#x27;.SELECT SINGLE RELID FROM WWWDATA INTO @DATA(LV_RELID) WHERE RELID = @LC_MI AND OBJID = @LV_OBJID AND SRTF2 = 0.IF SY-SUBRC &lt;&gt; 0. &quot;Template file download faild. MESSAGE TEXT-E29 TYPE LC_I DISPLAY LIKE GC_E. EXIT.ENDIF.LV_FNAME = PV_PATH.CONCATENATE LC_MI LV_OBJID INTO LV_KEY.CALL FUNCTION &#x27;DOWNLOAD_WEB_OBJECT&#x27; EXPORTING KEY = LV_KEY DESTINATION = LV_FNAME IMPORTING RC = LV_RC. 四、OLE下载1.技术要点（1）方法说明①创建实例1CREATE OBJECT name_obj &#x27;app&#x27;. ②设置属性1SET PROPERTY OF name_obj &#x27;XXX&#x27; = f. ③读取属性1GET PROPERTY OF name_obj &#x27;XXX&#x27; = f. ④调用实例方法1234CALL METHOD OF name_obj &#x27;XXX&#x27; = f &quot;接收返回值 EXPORTING #1 = F1. &quot;调用name_obj的方法XXX 传入参数f1...fn ⑤释放实例1FREE OBJECT name_obj. （2）打开Excel并激活工作表①打开Excel1CREATE OBJECT GO_EXCEL &#x27;Excel.Application&#x27;. ②设置Excel可见1SET PROPERTY OF GO_EXCEL &#x27;Visible&#x27; = 1. ③创建空白工作簿1CALL METHOD OF GO_EXCEL &#x27;Workbooks&#x27; = GO_BOOKS. ④创建工作表1CALL METHOD OF GO_BOOKS &#x27;Add&#x27; = GO_BOOK. ⑤选择工作表123CALL METHOD OF GO_EXCEL &#x27;Workwheets&#x27; = GO_BOOK. EXPORTING #1 = 1. ⑥设置工作表名1SET PROPERTY OF GO_BOOK &#x27;Name&#x27; = &#x27;Sheet1&#x27;. ⑦激活工作表1CALL METHOD OF GO_BOOK &#x27;Activate&#x27;. （3）选择单元格赋值通过将数据复制到粘贴板进行数据插入 ①清空单元格内容12345678910111213141516CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL1 EXPORTING #1 = 1 #2 = 2.GET PROPERTY OF GO_EXCEL &#x27;ActiveCell&#x27; = LOCELL2.CALL METHOD OF LOCELL2 &#x27;&#x27; = LO_CELL3 EXPORTING #1 = &#x27;11&#x27;. &quot;xlLastCell CALL METHOD OF GO_EXCEL &#x27;Range&#x27; = GO_RANGE EXPORTING #1 = LO_CELL1 #2 = LO_CELL3.CALL METHOD OF GO_RANGE &#x27;ClearContents&#x27;. ②将要下载的表格复制到剪贴板12345678910CALL METHOD CL_GUI_FRONTEND_SERICES=&gt;CLIPBOARD_EXPORT IMPORTING DATA = LT_CLIPTAB[] CHANGING RC = LV_RD EXCEPTIONS CNTL_ERROR = 1 ERROR_NO_GUI = 2 NOT_SUPPORTED_BY_GUI = 3 OTHER = 4. ③粘贴数据123456789101112131415CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL1 EXPORTING #1 = 1 #2 = 1.CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL2 EXPORTING #1 = LV_ROW #2 = LV_COL.CALL METHOD OF GO_EXCEL &#x27;Range&#x27; = GO_RANGE EXPORTING #1 = LO_CELL1 #2 = LO_CELL2.CALL METHOD OF GO_RANGE &#x27;Select&#x27;.CALL METHOD OF GO_SHEET &#x27;Paste&#x27;. （4）设置单元格格式①单元格公式 行合计：PV_VALUE &#x3D; ‘&#x3D;SUM(RC[1]:RC[7])’ 合计第一列到第七列的数据 列合计：PV_VALUE &#x3D; ‘&#x3D;SUM(R[1]:R[7]C)’ 合计第一行到第七行数据 ②设置单个单元格数据123456CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL EXPORTING #1 = PV_ROW #2 = PV_COL.SET PROPERTY OF LO_CELL &#x27;Value&#x27; = PV_VAL.FREE OBJECT LO_CELL. ③设置数据类型‘@’：常规 ‘#，##0’：金额 1SET PROPERTY OF GO_RANGE ‘NumberFormat’ = &#x27;@&#x27;. ③对齐方式 2：左对齐 3：居中 4：右对齐 1SET PROPERTY OF GO_RANGE &#x27;HorizontalAlignment&#x27; = 2. ④颜色色图编号图： 12CALL METHOD OF GO_RANGE &#x27;Interior&#x27; = GO_CELLINT.SET PROPERTY OF GO_CELLINT &#x27;Colorindex&#x27; = PV_COLOR. ⑤边框123CALL METHOD OF GO_RANGE &#x27;Borders&#x27; = GO_BORDER. &quot;实例化边框对象SET PROPERTY OF GO_BORDER &#x27;Weight&#x27; = 2. &quot;设置边框宽度SET PORPERTY OF GO_BORDER &#x27;Linestyle&#x27; = 1. &quot;设置边框类型（1实线） ⑥自适应宽度12CALL METHOD OF GO_EXCEL &#x27; Columns&#x27; = GO_COLUMNS.CALL METHOD OF GO_COLUMNS &#x27;AutoFit&#x27;. ⑦执行宏123CALL METHOD OF GO_EXCEL &#x27;RUN&#x27; EXPORTING #1 = &#x27;ZMAC&#x27;. （5）OLE保存文件①保存文件1CALL METHOD OF GO_BOOKS &#x27;Save&#x27;. ②另存为1234CALL METHOD OF GO_BOOKS &#x27;SaveAs&#x27; EXPORTING #1 = &#x27;新的地址&#x27; #2 = 1. ③关闭工作区1CALL METHOD OF GO_BOOKS &#x27;Colse&#x27;. ④退出Excel1CALL METHOD OF GO_EXCEL &#x27;Quit&#x27;. 2.流程代码OLE的下载流程主要可以概括为三个阶段： 获取下载用的数据 下载用于存放数据的Excel文件 设置数据在Excel中的格式 12345678910FROM DOWNLOAD_EXCEL_OLE CHANGING VALUE(PV_FULLPATH) TYPE STRING. &quot;Get Download data PERFORM GET_DOWNLOAD_DATA USING PV_FULLPATH. &quot;Download EXCEL PERFORM DOWNLOAD_FILE USING PV_FULLPATH. &quot;Store data stream and download data PERFORM DOWNLOAD_DATA USING PV_FULLPATH.ENDFORM. 3.流程源代码（1）获取下载数据(GET_DOWNLOAD_DATA)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980FORM GET_DOWNLOAD_DATA USING VALUE(PV_FULLPATH).*---------------------------Variables----------------------------* CONSTANTS: LC_FU TYPE C LENGTH 1 VALUE &#x27;-&#x27;, LC_D TYPE C LENGTH 1 VALUE &#x27;D&#x27;, LC_DIAN TYPE C LENGTH 1 VALUE &#x27;,&#x27;. DATA: LV_INDEX TYPE I VALUE 1, LV_DATA TYPE STRING, LV_YEAR TYPE C LENGTH 4, LV_MONTH TYPE C LENGTH 2, LV_DAY TYPE C LENGTH 2, LV_LENGTH TYPE I, LS_DOW TYPE TY_LONG, LT_FIELDCATALOG LIKE GT_FIELDCATALOG, LS_FIELDCATALOG LIKE LINE OF GT_FIELDCATALOG, LT_TABLE LIKE GT_TABLE. FIELD-SYMBOLS:&lt;FS_FIELDNAME&gt;.*-----------------------------Logic------------------------------* REFRESH: GT_DOW_DATA. &quot;Set the column name of Excel APPEND LINES OF GT_FIELDCATALOG TO LT_FIELDCATALOG. DELETE LT_FIELDCATALOG WHERE TECH = GC_X. LOOP AT LT_FIELDCATALOG INTO LS_FIELDCATALOG. IF SY-TABIX EQ 1. LS_DOW = LS_FIELDCATALOG-COLTEXT. ELSE. CONCATENATE LS_DOW LS_FIELDCATALOG-COLTEXT INTO LS_DOW SEPARATED BY CL_ABAP_CHAR_UTILITIES=&gt;HORIZONTAL_TAB. ENDIF. CLEAR: LS_FIELDCATALOG. ENDLOOP. APPEND LS_DOW TO GT_DOW_DATA. &quot;Fill in the data to be saved APPEND LINES OF GT_TABLE TO LT_TABLE. LOOP AT LT_TABLE INTO GS_TABLE. LOOP AT LT_FIELDCATALOG INTO LS_FIELDCATALOG. LV_INDEX = SY-TABIX. ASSIGN COMPONENT LS_FIELDCATALOG-FIELDNAME OF STRUCTURE GS_TABLE TO &lt;FV_VALUE&gt;. IF SY-SUBRC EQ 0. LV_DATA = &lt;FV_VALUE&gt;. &quot;Format date LV_LENGTH = STRLEN( LV_DATA ). IF LS_FIELDCATALOG-INTTYPE EQ LC_D AND LV_LENGTH EQ 8 AND &lt;FV_VALUE&gt; IS NOT INITIAL. LV_YEAR = LV_DATA+0(4). LV_MONTH = LV_DATA+4(2). LV_DAY = LV_DATA+6. CONCATENATE LV_YEAR LV_MONTH LV_DAY INTO LV_DATA SEPARATED BY LC_DIAN. ELSEIF LS_FIELDCATALOG-INTTYPE EQ LC_D AND &lt;FV_VALUE&gt; IS INITIAL. CLEAR LV_DATA. ENDIF. IF LV_INDEX EQ 1. LS_DOW = LV_DATA. ELSE. CONCATENATE LS_DOW LV_DATA INTO LS_DOW SEPARATED BY CL_ABAP_CHAR_UTILITIES=&gt;HORIZONTAL_TAB. ENDIF. ENDIF. CLEAR: LV_DATA,LS_FIELDCATALOG. ENDLOOP. APPEND LS_DOW TO GT_DOW_DATA. CLEAR: GS_TABLE,LS_DOW. ENDLOOP. &quot;Set the total number of rows and columns GV_ROW = LINES( GT_DOW_DATA ). GV_COL = LINES( LT_FIELDCATALOG ). FREE: LT_FIELDCATALOG,LT_TABLE.ENDFORM. （2）获取下载的Excel文件(DOWNLOAD_FILE)使用这个Function，他传入的参数GT_DOW_DATA不能为空，即必须有值才可以下载一个Excel。 123456789101112131415FROM DOWNLOAD_FILE USING VALUE(PV_FULLPATH).*---------------------------Variables----------------------------* DATA: LV_FILE_NAME TYPE RLGRAP-FILENAME.*-----------------------------Logic------------------------------* LV_FILE_NAME = PV_FULLPATH. CALL FUNCTION &#x27;SAP_CONVERT_TO_XLS_FORMAT&#x27; EXPORTING I_FILENAME = LV_FILE_NAME TABLES I_TAB_SAP_DATA = GT_DOW_DATA EXCEPTIONS CONVERSION_FAILED = 1 OTHER = 2.ENDFORM. 此处另外一种下载Excel文件的Function，这个Function是同事提供的，我自己暂时还没用过。 1234CALL FUNCTION &#x27;DOWNLOAD_WEB_OBJECT&#x27; EXPORTING KEY = LS_KEY DESTINATION = CONV RLGRAP-FILENAME( PV_FILENAME ). （3）将数据下载到Excel(DOWNLOAD_DATA)123456789101112131415161718192021222324252627282930313233FORM DOWNLOAD_DATA USING VALUE(PV_FULLPATH).*---------------------------Variables----------------------------* DATA: LV_SHEETNAME TYPE STRING.*-----------------------------Logic------------------------------* &quot;Create excel object CREATE OBJECT GO_EXCEL &#x27;EXCEL.APPLICATION&#x27;. &quot;Create unified file CALL METHOD OF GO_EXCEL &#x27;WORKBOOKS&#x27; = GO_BOOKS. CALL METHOD OF GO_BOOKS &#x27;OPEN&#x27; = GO_BOOKS EXPORTING #1 = PV_FULLPATH. &quot;Table name / column name CALL METHOD OF GO_EXCEL &#x27;WORKSHEETS&#x27; = GO_SHEET EXPORTING #1 = 1. CALL METHOD OF GO_SHEET &#x27;Activate&#x27;. GET PROPERTY OF GO_EXCEL &#x27;ActiveWorkbook&#x27; = GO_BOOKS. &quot;Excel data operation PERFORM EXCEL_MAIN_DATA. SET PROPERTY OF GO_EXCEL &#x27;Visible&#x27; = 1. &quot;Set Excel Sheet Name CONCATENATE GV_TITLE GC_TITLE INTO LV_SHEETNAME SEPARATED BY SPACE. SET PROPERTY OF GO_SHEET &#x27;Name&#x27; = LV_SHEETNAME. CALL METHOD OF GO_BOOKS &#x27;Save&#x27;. FREE OBJECT: GO_EXCEL,GO_BOOKS,GO_SHEET.ENDFORM. （4）将数据Copy到Excel中(EXCEL_MAIN_DATA)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990FORM EXCEL_MAIN_DATA.*---------------------------Variables----------------------------* DATA: LV_RD TYPE I, LO_CELL1 TYPE OLE2_OBJECT, LO_CELL2 TYPE OLE2_OBJECT, LO_CELL3 TYPE OLE2_OBJECT.*-----------------------------Logic------------------------------* &quot;Clear contents CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL1 EXPORTING #1 = 1 #2 = 1. GET PROPERTY OF GO_EXCEL &#x27;ActiveCell&#x27; = LO_CELL2. CALL METHOD OF LO_CELL2 &#x27;SpecialCells&#x27; = LO_CELL3 EXPORTING #1 = &#x27;9&#x27;.&quot;xl Last Cell CALL METHOD OF GO_EXCEL &#x27;Range&#x27; = GO_RANGE EXPORTING #1 = LO_CELL1 #2 = LO_CELL3. CALL METHOD OF GO_RANGE &#x27;ClearContents&#x27;. FREE OBJECT: LO_CELL1, LO_CELL2, LOCELL3, GO_RANGE. &quot;Copy to Clipboard CALL METHOD CL_GUI_FRONTEND_SERVICES=&gt;CLIPBOARD_EXPORT IMPORTING DATA = GT_DOW_DATA CHANGING RC = LV_RD EXCEPTIONS CNTL_ERROR = 1 ERROR_NO_GUI = 2 NOT_SUPPORTED_BY_GUI = 3 OTHERS =4. &quot;Paste to excel CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL1 EXPORTING #1 = 1 #2 = 1. CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL2 EXPORTING #1 = GV_ROW #2 = GV_COL. CALL METHOD OF GO_EXCEL &#x27;Range&#x27; = GO_RANGE EXPORTING #1 = LO_CELL1 #2 = LO_CELL2. CALL METHOD OF GO_RANGE &#x27;Select&#x27;. CALL METHOD OF GO_SHEET &#x27;Paste&#x27;. &quot;Center Alignment SET PROPERTY OF GO_RANGE &#x27;VerticalAlignment&#x27; = 2. &quot;Borders CALL METHOD OF GO_RANGE &#x27;Borders&#x27; = GO_BORDER. SET PROPERTY OF GO_BORDER &#x27;Weight&#x27; = 2. SET PROPERTY OF GO_BORDER &#x27;Linestyle&#x27; = 1. &quot;Auto adjust column width CALL METHOD OF GO_EXCEL &#x27;Colimns&#x27; = GO_COLUMNS. CALL METHOD OF GO_COLUMNS &#x27;AutoFit&#x27;. FREE OBJECT: LO_CELL1, LO_CELL2, GO_RANGE. CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL1 EXPORTING #1 = 1 #2 = 1. CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL2 EXPORTING #1 = 1 #2 = GV_COL. CALL METHOD OF GO_EXCEL &#x27;Range&#x27; = GO_RANGE EXPORTING #1 = LO_CELL1 #2 = LO_CELL2. &quot;Cell color: gray CALL METHOD OF GO_RANGE &#x27;Interior&#x27; = GO_CELLINT. SET PROPERTY OF GO_CELLINT &#x27;Colorindex&#x27; = &#x27;15&#x27;. &quot;Set Data Alignment PERFORM SET_ALIGNMENT.ENDFORM. （5）根据字段目录设置Excel对齐方式(SET_ALIGNMENT)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647FORM SET_ALIGNMENT.*---------------------------Variables----------------------------* CONSTANTS: LC_L TYPE C LENGTH 1 VALUE &#x27;L&#x27;, LC_C TYPE C LENGTH 1 VALUE &#x27;C&#x27;, LC_R TYPE C LENGTH 1 VALUE &#x27;R&#x27;. DATA: LO_CELL1 TYPE OLE2_OBJECT, LO_CELL2 TYPE OLE2_OBJECT. DATA: LV_JUST TYPE I, LV_COL TYPE I VALUE 1, LS_FIELDCATALOG LIKE LINE OF GT_FIELDCATALOG.*-----------------------------Logic------------------------------* LOOP GT_FIELDCATALOG INTO LS_FIELDCATALOG WHERE TECH &lt;&gt; GC_X. &quot;Select Action Column FREE OBJECT: LO_CELL1, LO_CELL2, GO_RANGE. CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL1 EXPORTING #1 = 1 #2 = LV_COL. CALL METHOD OF GO_EXCEL &#x27;Cells&#x27; = LO_CELL2 EXPORTING #1 = GV_ROW #2 = GV_COL. CALL METHOD OF GO_EXCEL &#x27;Range&#x27; = GO_RANGE EXPORTING #1 = LO_CELL1 #2 = LO_CELL2. &quot;Set alignment. CASE LS_FIELDCATALOG-JUST. WHEN LC_L. LV_JUST = 2. WHEN LC_C. LV_JUST = 3. WHEN OTHERS. LV_JUST = 4. ENDCASE. &quot;Reflect alignment to Excel SET PROPERTY OF GO_RANGE &#x27;HorizontalAlignment&#x27; = LV_JUST. LV_COL = LV_COL + 1. CLEAR: LS_FIELDCATALOG. ENDLOOP.ENDFORM. 五、DOI下载1.技术要点（1）容器对象①Container存放Excel电子表格（Spreadsheet）的容器。操作这个对象就相当于操作Excel文件。 ②Container Control容器中用于创建和管理其他Office集成所需要的对象，Container Control是一个接口。 使用的Class类为：I_OI_CONTAINER_CONTROL ③Document Proxy每一个document proxy的实例代表用Office Application打开的文档，可以是Excel，可以是Word，如果想打开多个文档，需要定义多个实例。document proxy是一个接口。 使用的Class类为：I_OI_DOCUMENT_PROXY ④SpreadsheetSpreadsheet接口，代表最终要操作的Excel文档。 使用的Class类为：I_OI_SPREADSHEET （2）通过上传模板下载Excel文件下面的流程代码中使用的是无模板的形式创建一个Excel文件，所以此处介绍一下通过SMW0和OAOR的形式上传Excel模板然后下载Excel的方式。 ①SMW012345678910111213141516171819202122232425262728293031323334DATA: LT_DOC_TABLE LIKE TABLE OF W3MIME, LV_DOC_SIZE TYPE I, LV_DOC_TYPE(80) VALUE SOI_DOCTYPE_EXCEL_SHEET, LV_DOC_FORMAT(80), LV_RETCODE TYPE SOI_RET_STRING, LV_OBJID TYPE WWWDATA-OBJID VALUE &#x27;Z9050&#x27;.&quot;SMW0上传文件名称 CALL FUNCTION &#x27;SAP_OI_LOAD_MIME_DATA&#x27; EXPORTING OBJECT_ID = LV_OBJID IMPORTING DATA_SIZE = LV_DOC_SIZE DOCUMENT_FORMAT = LV_DOC_FORMAT DOCUMENT_TYPE = LV_DOC_TYPE TABLES DATA_TABLE = LT_DOC_TABLE EXCEPTIONS OBJECT_NOT_FOUND = 1 INTERNAL_ERROR = 2 OTHER = 3.GO_DOCU_PROXY-&gt;OPEN_DOCUMENT_FROM_TABLE( EXPORTING DOCUMENT_TABLE = LT_DOC_TABLE[] DOCUMENT_SIZE = LV_DOC_SIZE NO_FLUSH = &#x27;X&#x27; IMPORTING RETCODE = LV_RETCODE ).IF LV_RETCODE &lt;&gt; C_OI_ERRORS=&gt;RET_OK. &quot;Excel download template exception. MESSAGE I000 WITH TEXT-E01 DISPLAY LIKE &#x27;E&#x27;.ENDIF. ②OAOR1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DATA: LO_BDS_DOCUMTNTS TYPE REF TO CL_DBS_DOCUMENT_SET, LV_CLASSNAME TYPE SBDST_CLASSNAME VALUE &#x27;HRFPM_EXCEL_STANDARD&#x27;, LV_CLASSTYPE TYPE SBDST_CLASSTYPE VALUE &#x27;OT&#x27;, LV_OBJECTKEY TYPE SBDST_OBJECT_KEY VALUE &#x27;DOITEST&#x27;, LV_DOC_COMPONENTS TYPE SBDST_COMPONENTS, LV_DOC_SIGNATURE TYPE SBDST_SIGNATURE.DATA: LT_BDS_URIS TYPE SBDST_URI, LS_BDS_URL LIKE LINE OF LT_BDS_URIS, LV_URL TYPE C LENGTH 256. CREATE OBJECT LO_BDS_DOCUMENTS.CL_BDS_DOCUMENT_SET=&gt;GET_INFO( EXPORTING CLASSNAME = LV_CLASSNAME CLASSTYPE = LV_CLASSTYPE OBJECT_KEY = LV_OBJECTKEY CHANGING COMPONENTS = LV_DOC_COMPONENTS SIGNATURE = LV_DOC_SIGNATURE ).CL_BDS_DOCUMENT_SET=&gt;GET_WITH_URL( EXPORTING CLASSNAME = LV_CLASSNAME CLASSTYPE = LV_CLASSTYPE OBJECT_KEY = LV_OBJECTKEY CHANGING URIS = LT_BDS_URIS SIGNATURE = LV_DOC_SIGNATURE ).FREE: LO_BDS_DOCUMENTS.READ TABLE LT_BDS_URIS INTO LS_BDS_URL INDEX 1.LV_URL = LS_BDS_URL-URI.GO_DOCU_PROXY-&gt;OPEN_DOCUMENT( EXPORTING DOCUMENT_TITLE = &#x27;excel&#x27; DOCUMENT_URL = LV_URL OPEN_INPLACE = SPACE IMPORTING ERROR = GO_ERROR ).IF GO_ERROR-&gt;HAS_FAILED = &#x27;X&#x27;. GO_ERROR-&gt;RAISE_MESSAGE( EXPORTING TYPE = &#x27;E&#x27; ).ENDIF. （3）操作工作表①获取所有工作表名123456DATA: LT_SHEETS TYPE SOI_SHEETS_TABLE.GO_SHEET-&gt;GET_SHEETS( IMPORTING SHEETS = LT_SHEETS ERROR = GO_ERROR ). ②修改工作表名修改Sheet1为Header 1234567GO_SHEET-&gt;SET_SHEET_NAME( EXPORTING NEWNAME = &#x27;Header&#x27; OLDNAME = &#x27;Sheet1&#x27; IMPORTING ERROR = GO_ERROR). ③删除工作表删除Sheet2 12345GO_SHEET-&gt;DELETE_SHEET( EXPORTING NAME = &#x27;Sheet2&#x27; IMPORTING ERROR = GO_ERROR ). ④新增工作表新增的Sheet会被放在当前激活Sheet前。 12345GO_SHEET-&gt;ADD_SHEET( EXPORTING NAME = &#x27;Item&#x27; IMPORTING ERROR = GO_ERROR ). ⑤选择工作表选择Header进行后续操作。 123456GO_SHEET-&gt;SELECT_SHEET( EXPORTING NAME = &#x27;Header&#x27; NO_FLUSH = &#x27;X&#x27; IMPORTING ERROR = GO_ERROR ). （4）设置单个单元格值在下面的流程代码Form GET_DOWNLOAD_DATA_DOI 中使用的是直接根据内表的数据将内表整个更新到Excel中。而接下来介绍的这个方法是通过设置行、列和值的形式给单元格赋值。但是这种方式只适合数据量较少或未处理的数据，例如字段标题。 1234567891011121314151617181920212223242526272829303132DATA: LV_COLUMN TYPE I, LT_RANGES TYPE SOI_RANGE_LIST, LS_RANGES TYPE SOI_RANGE_ITEM, LT_TITLE TYPE SOI_GENERIC_TABLE, LS_TITLE TYPE SOI_GENERIC_ITEM.DESCRIBE TABLE GT_FIELDCAT LIKES LV_COLUMN.&quot;Select rangeREFRESH: LT_RANGES,LT_TITLE.CLEAR LS_RANGES.LS_RANGES-NAME = &#x27;TITLE&#x27;.LS_RANGES-COLUMNS = LV_COLUMN.LS_RANGES-ROWS = 1.LS_RANGES-CODE = 1.APPEND LS_RANGES TO LT_RANGES.LOOP AT GT_FIELDCAT INTO GS_FIELDCAT. LS_TITLE-ROW = 1. LS_TITLE-COLUMN = SY-TABIX. LS_TITLE-VALUE = GS_FIELDCAT-COLTEXT. APPEND LS_TITLE TO LT_TITLE. CLEAR: LS_TITLE,GS_FIELDCAT.ENDLOOP.CALL METHOD GO_SHEET-&gt;SET_RANGES_DATA EXPORTING RANGES = LT_RANGES CONTENTS = LT_TITLE IMPORTING ERROR = GO_ERROR. （5）设置单元格格式①单元格区分1234567891011DATA: LT_RANGES TYPE SOI_FULL_RANGE_TABLE.LT_RANGES[] = VALUE #( ( NAME = &#x27;TITLE&#x27; TOP = 1 LEFT = 1 ROWS = 1 COLUMNS = 标题个数 ) ( NAME = &#x27;BODY&#x27; TOP = 2 LEFT = 1 ROWS = 数据条数 COLUMNS = 标题个数 ) ( NAME = &#x27;KEY&#x27; TOP = 2 LEFT = 1 ROWS = 数据条数 COLUMNS = Key字段个数 )).&quot;区分信息传入GO_SHEET-&gt;INSERT_RANGES( EXPORTING RANGES = LT_RANGES IMPORTING ERROR = GO_ERROR ). ②字体设置1234567891011GO_SHEET-&gt;SET_FONT( EXPORTING RANGENAME = &#x27;BODY&#x27; &quot;单元格区域，即字体样式生效区域 FAMILY = &#x27;Arial&#x27; &quot;字体样式 SIZE = 20 &quot;字体大小 BOLD = 1 &quot;字体加粗 0 不加粗 1 加粗 ITALIC = 0 &quot;字体斜体 0 非斜体 1 斜体 ALIGN = 2 &quot;对齐方式 0 左对齐 1 居中 2 右对齐 IMPORTING ERROR = GO_ERROR). ③单元格设置设置Key区域的字体颜色为红色，背景色为黄色，字体加粗并添加绿色边框。 1234567DATA: LT_FORMAT TYPE SOI_FORMAT_TABLE.LT_FORMAT = VALUE #( ( NAME = &#x27;KEY&#x27; FRONT = 3 BACK = 6 BOLD = 1 FRAMETYP = 127 FRAMECOLOR = 4 ) ).GO_SHEET-&gt;SET_RANGES_FORMAT( EXPORTING FORMATTABLE = LT_FORMAT IMPORTING ERRO = GO_ERROR ). ④宽度自适应12GO_SHEET-&gt;FIT_WIDEST( EXPORTING NAME = &#x27;TITLE&#x27; IMPORTING ERROR = GO_ERROR ). ⑤单元格边框12345678GO_SHEET-&gt;SET_FRAME( EXPORTING RANGENAME = &#x27;TITLE&#x27; TYP = &#x27;127&#x27; COLOR = &#x27;1&#x27; IMPORTING ERROR = GO_ERROR). ⑥执行宏1GO_DOCU_PROXY-&gt;EXECUTE_MACRO( EXPORTING MACRO_STRING = 宏名称 ). （6）保存文件①保存文档到本地12345678IF GO_DOCU_PROXY IS NOT INITIAL. GO_DOCU_PROXY-&gt;SAVE_AS( EXPORTING FILE_NAME = PV_FILENAME IMPORTING ERROR = GO_ERROR ).ENDIF. ②保存文档到URL12345678GO_DOCU_PROXY-&gt;SAVE_DOCUMENT_TO_URL( EXPORTING URL = LV_URL IMPORTING ERROR = GO_ERROR CHANGING DOCUMENT_SIZE = LV_SIZE). ③保存文档到内表1234567GO_DOCU_PROXY-&gt;SAVE_DOCUMENT_TO_TABLE( EXPORTING ERROR = GO_ERROR CHANGING DOCUMENT_SIZE = LV_SIZE DOCUMENT_TABLE = LT_TABLE). 2.流程代码DOI的下载流程步骤较多，但相应的对于Excel的操作相对于OLE也更加的灵活。 创建DOI的容器对象 创建一个空白的工作簿 打开工作簿并实例化表对象 设置Excel的抬头 设置Excel中的内容 设置Excel中内容的样式 将数据保存到下载到本地的Excel文件中 关闭文件并释放创建的DOI对象 全局变量定义 123456&quot;Excel ObjectDATA: GO_CONTROL TYPE REF TO I_OI_CONTAINER_CONTROL, GO_ERROR TYPE REF TO I_OI_ERROR, GO_DOCU_PROXY TYPE REF TO I_OI_DOCUMENT_PROXY, GO_DOISHEET TYPE REF TO I_OI_SPREADSHEET. 流程逻辑 1234567891011121314151617181920212223242526FROM DOWNLOAD_EXCEL_DOI CHANGING VALUE(PV_FULLPATH) TYPE STRING. &quot;Create Container PERFORM CREATE_DOI_CONTAINER. &quot;Create a blank workbook PERFORM CREATE_BLANK_WORKBOOK. &quot;Open the workbook and instantiate the table object. PERFORM OPEN_WORKBOOK. CHECK GV_MESSAGE IS INITIAL. &quot;Set Excel Header Title PERFORM SET_HEADER_TITLE. &quot;Set Excel Table Value PERFORM GET_DOWNLOAD_DATA_DOI. &quot;Set Excel Style PERFORM SET_EXCEL_DOI_STYLE. &quot;Save Data To Local File PERFORM SAVE_DATA_TO_FILE USING PV_FULLPATH. &quot;Close File And Free Object PERFORM FREE_OBJECT.ENDFORM. 3.流程源代码（1）创建DOI的容器对象（CREATE_DOI_CONTAINER）12345678910111213141516171819202122232425262728293031323334FORM CREATE_DOI_CONTAINER.*---------------------------Variables----------------------------* DATA: LV_DOC_TYPE(80) VALUE SOI_DOCTYPE_EXCEL_SHEET.&quot;Excel.sheet*-----------------------------Logic------------------------------* C_OI_CONTAINER_CONTROL_CREATOR=&gt;GET_CONTAINER_CONTROL( IMPORTING CONTROL = GO_CONTROL ERROR = GO_ERROR ). GO_ERROR-&gt;RAISE_MESSAGE( EXPORTING TYPE = GC_E ). GO_CONTROL-&gt;INIT_CONTROL( EXPORTING R3_APPLICATION_NAME = &#x27;EXCEL CONTAINER&#x27; INPLACE_ENABLED = SPACE INPLACE_RESIZE_DOCUMENTS = GC_X INPLACE_SCROLL_DOCUMENTS = GC_X INPLACE_SHOW_TOOLBARS = GC_X PARENT = CL_GUI_CONTAINER=&gt;SCREEN0 REGISTER_ON_CLOSE_EVENT = SPACE REGISTER_ON_CUSTOM_EVENT = SPACE IMPORTING ERROR = GO_ERROR ). GO_ERROR-&gt;RAISE_MESSAGE( EXPORTING TYPE = GC_E ). GO_CONTROL-&gt;GET_DOCUMENT_PROXY( EXPORTING DOCUMENT_TYPE = LV_DOC_TYPE IMPORTING DOCUMENT_PROXY = GO_DOCU_PROXY ERROR = GO_ERROR ). GO_ERROR-&gt;RAISE_MESSAGE( EXPORTING TYPE = GC_E ).ENDFORM. （2）创建一个空白的工作簿（CREATE_BLANK_WORKBOOK）1234567891011FORM CREATE_BLANK_WORKBOOK. CHECK GO_DOCU_PROXY IS BOUND. GO_DOCU_PROXY-&gt;CREATE_DOCUMENT( EXPORTING DOCUMENT_TITLE = &#x27;excel&#x27; OPEN_INPLACE = GC_X &quot;是否要将Excel嵌入GUI中展示操作 NO_FLUSH = GC_X IMPORTING ERROR = GO_ERROR ). GO_ERROR-&gt;RAISE_MESSAGE( EXPORTING TYPE = GC_E ).ENDFORM. （3）打开工作簿并实例化工作表对象（OPEN_WORKBOOK）123456789101112131415161718192021222324FORM OPEN_WORKBOOK.*---------------------------Variables----------------------------* DATA: LV_TEMP TYPE I.*-----------------------------Logic------------------------------* CLEAR: GV_MESSAGE. &quot;Indicates Whether Interface Is Supported For This Doc. Type GO_DOCU_PROXY-&gt;HAS_SPREADSHEET_INTERFACE( IMPORTING IS_AVAILABLE = LV_TEMP ). IF LV_TEMP NE 1. GV_MESSAGE = GC_X. EXIT. ENDIF. &quot;Returns an Interface Reference GO_DOCU_PROXY-&gt;GET_SPREADSHEET_INTERFACE( IMPORTING ERROR = GO_ERROR SHEET_INTERFACE = GO_DOISHEET ). IF GO_ERROR-&gt;HAS_FAILED = GC_X. GO_ERROR-&gt;RAISE_MESSAGE( EXPORTING TYPE = GC_E ). ENDIF.ENDFORM. （4）设置Excel的抬头（SET_HEADER_TITLE）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950FORM SET_HEADER_TITLE.*---------------------------Variables----------------------------* DATA: LT_RANGES TYPE SOI_RANGE_LIST, LS_RANGES TYPE SOI_RANGE_ITEM, LT_TITLE TYPE SOI_GENERIC_TABLE, LS_TITLE TYPE SOI_GENERIC_ITEM, LS_FIELDCATALOG LIKE LINE OF GT_FIELDCATALOG.*-----------------------------Logic------------------------------* CLEAR: GV_COL,GV_ROW. DELETE GT_FIELDCATALOG WHERE TECH EQ GC_X. DESCRIBE TABLE GT_FIELDCATALOG LINES GV_COL. &quot;Select the operation area. GO_DOISHEET-&gt;INSERT_RANGE_DIM( EXPORTING NAME = &#x27;TITLE&#x27; TOP = 1 LEFT = 1 ROWS = 1 &quot;total row COLUMNS = GV_COL &quot;total column UPDATING = 0 IMPORTING ERROR = GO_ERROR ). &quot;Set Range REFRESH: LT_RANGES,LT_TITLE. CLEAR LS_RANGES. LS_RANGES-NAME = &#x27;TITLE&#x27;. LS_RANGES-COLUMNS = GV_COL. LS_RANGES-ROWS = 1. LS_RANGES-CODE = 1. APPEND LS_RANGES TO LT_RANGES. &quot;Set Title LOOP AT GT_FIELDCATALOG INTO LS_FIELDCATALOG. LS_TITLE-ROW = 1. LS_TITLE-COLUMN = SY-TABIX. LS_TITLE-VALUE = LS_FIELDCATALOG-COLTEXT. APPEND LS_TITLE TO LT_TITLE. CLEAR: LS_TITLE,LS_FIELDCATALOG. ENDLOOP. CALL METHOD GO_DOISHEET-&gt;SET_RANGES_DATA EXPORTING RANGES = LT_RANGES CONTENTS = LT_TITLE IMPORTING ERROR = GO_ERROR.ENDFORM. （5）设置Excel中的内容（GET_DOWNLOAD_DATA_DOI）1234567891011121314151617181920212223242526272829303132333435363738FORM GET_DOWNLOAD_DATA_DOI.*---------------------------Variables----------------------------* DATA: LT_FIELDS LIKE TABLE OF RFC_FIELDS.*-----------------------------Logic------------------------------* GV_ROW = LINES( GT_TABLE ). GV_COL = LINES( GT_FIELDCATALOG ). &quot;Insert space range GO_DOISHEET-&gt;INSERT_RANGE_DIM( EXPORTING NAME = &#x27;DATA&#x27; TOP = 2 LEFT = 1 ROWS = GV_ROW COLUMNS = GV_COL UPDATING = 0 IMPORTING ERROR = GO_ERROR ). &quot;Set Format CALL FUNCTION &#x27;DP_GET_FIELDS_FROM_TABLE&#x27; TABLES DATA = GT_TABLE FIELDS = LT_FIELDS EXCEPTIONS DP_INVALID_TABLE = 1 OTHERS = 2. &quot;Insert a Table GO_DOISHEET-&gt;INSERT_ONE_TABLE( EXPORTING DATA_TABLE = GT_TABLE FIELDS_TABLE = LT_FIELDS RANGENAME = &#x27;DATA&#x27; WHOLETABLE = GC_X UPDATING = 1 ).ENDFORM. （6）设置Excel中内容的样式（SET_EXCEL_DOI_STYLE）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869FORM SET_EXCEL_DOI_STYLE.*---------------------------Variables----------------------------* CONSTANTS: LC_TITLE TYPE C LENGTH 5 VALUE &#x27;TITLE&#x27;, LC_BODY TYPE C LENGTH 4 VALUE &#x27;BODY&#x27;, LC_ALL TYPE C LENGTH 3 VALUE &#x27;ALL&#x27;. DATA: LT_FORMAT TYPE SOI_FORMAT_TABLE, LS_FORMAT LIKE LINE OF LT_FORMAT, LT_RANGES TYPE SOI_FULL_RANGE_TABLE WITH HEADER LINE.*-----------------------------Logic------------------------------* &quot;Set Area LT_RANGES-NAME = LC_TITLE. LT_RANGES-TOP = 1. LT_RANGES-LEFT = 1. LT_RANGES-COLUMNS = GV_COL. APPEND LT_RANGES. LT_RANGES-NAME = LC_BODY. LT_RANGES-TOP = 2. LT_RANGES-LEFT = 1. LT_RANGES-ROWS = GV_ROW + 1. LT_RANGES-COLUMNS = GV_COL. APPEND LT_RANGES. LT_RANGES-NAME = LC_ALL. LT_RANGES-TOP = 1. LT_RANGES-LEFT = 1. LT_RANGES-ROWS = GV_ROW + 1. LT_RANGES-COLUMNS = GV_COL. APPEND LT_RANGES. GO_DOISHEET-&gt;INSERT_RANGES( EXPORTING RANGES = LT_RANGES[] IMPORTING ERRPR = GO_ERROR ). &quot;Set adaptive width CALL METHOD GO_DOISHEET-&gt;FIT_WIDEST( EXPORTING NAME = LC_ALL IMPORTING ERROR = GO_ERROR ). &quot;Set Border GO_DOISHEET-&gt;SET_FRAME( EXPORTING RANGENAME = LC_ALL TYP = &#x27;127&#x27; COLOR = 1 IMPORTING ERROR = GO_ERROR ). &quot;Set Title Color LS_FORMAT-NAME = LC_TITLE. &quot;LS_FORMAT-BACK = 5. &quot;LS_FORMAT-FRONT = 3. LS_FORMAT-BOLD = 1. LS_FORMAT-FRAMETYP = 127. &quot;LS_FORMAT-FRAMECOLOR = 4. APPEND LS_FORMAT TO LT_FORMAT. GO_DOISHEET-&gt;SET_RANGES_FORMAT( EXPORTING FORMATTABLE = LT_FORMAT IMPORTING ERROR = GO_ERROR ).ENDFORM. （7）将数据保存到下载到本地的Excel文件中（SAVE_DATA_TO_FILE）1234567891011121314FORM SAVE_DATA_TO_FILE USING VALUE(PV_FULLPATH) TYPE STRING.*---------------------------Variables----------------------------* DATA: LV_FILENAME TYPE C LENGTH 255.*-----------------------------Logic------------------------------* LV_FILENAME = PV_FULLPATH. IF GO_DOCU_PROXY IS BOUND. GO_DOCU_PROXY-&gt;SAVE_AS( EXPORTING FILE_NAME = LV_FILENAME IMPORTING ERROR = GO_ERROR ). ENDIF.ENDFORM. （8）关闭文件并释放创建的DOI对象（FREE_OBJECT）1234567891011121314151617FORM FREE_OBJECT.*---------------------------Variables----------------------------* DATA: LV_FILENAME TYPE C LENGTH 255.*-----------------------------Logic------------------------------* IF GO_DOCU_PROXY IS NOT INITIAL. &quot;关闭操作好的文档 GO_DOCU_PROXY-&gt;CLOSE_DOCUMENT( ). FREE: GO_DOCU_PROXY. ENDIF. IF GO_CONTROL IS NOT INITIAL. &quot;释放资源 GO_CONTROL-&gt;DESTROY_CONTROL( ). FREE: GO_CONTROL. ENDIF.ENDFORM. 4.ALV_TREE下载ALV Tree的下载，可以使用DOI的SET_HIERARCHY_TABLE方法设置Excel的层级结构。 需要设置层级开始行，层级包含的行数和层级结构使用的Sheet名。 多个层级时需要添加空行，否则连续层级会合并到一起。 123456789101112DATA: BEGIN OF LS_HIERA, FIRSTLINE TYPE I, LENGTH TYPE I, SHEET TYPE C LENGTH 128, MODE TYPE I, END OF LS_HIERA, LT_HIERA LIKE TABLE OF LS_HIERA.CALL METHOD GO_SHEET-&gt;SET_HIERARCHY_TABLE EXPORTING TABLE = LT_HIERA. 六、XML下载1.流程代码（1）选择下载格式12345678910111213DATA: LS_XML_CHOICE TYPE IF_SALV_BS_XML=&gt;S_TYPE_XML_CHOICE, LT_XML_CHOICE TYPE IF_SALV_BS_XML=&gt;T_TYPE_XML_CHOICE, LV_XML TYPE XSTRING. R_RESULT_DATA TYPE REF TO CL_SALV_EX_RESULT_DATA_TABLE, LO_DREF TYPE REF TO DATA, LV_FLAVOUR TYPE STRING, LV_VERSION TYPE STRING.LT_XML_CHOICE = CL_SALV_EXPORT_XML_DIALOG=&gt;GET_GUI_SPREADSHEET_FORMATS( ).SORT LT_XML_CHOICE BY XML_TYPE.READ TABLE LT_XML_CHOICE INTO LS_XML_CHOICE WITH KEY XML_TYPE = &#x27;10&#x27; BINARY SEARCH. （2）根据ALV相关设置，设置数据格式123456GET PEFERENCE OF GT_TABLE INTO LO_DREF.R_RESULT_DATA = CL_SALV_EX_UTIL=&gt;FACTORY_RESULT_DATA_TABLE( R_DATA = LO_DREF S_LAYOUT = GS_LAYOUT T_FIELDCATALOG = GT_FIELDCAT T_SORT = GT_SORT ). （3）转化数据为XML格式12345678910111213141516CASE CL_SALV_EX_BASE=&gt;GET_VERSION( ). WHEN IF_SALV_BS_XML=&gt;VERSION_25. LV_VERSION = IF_SALV_BS_XML=&gt;VERSION_25. WHEN IF_SALV_BS_XML=&gt;VERSION_26. LV_VERSION = IF_SALV_BS_XML=&gt;VERSION_26.ENDCASE.LV_FLABOUR = IF_SALV_BS_C_TT=&gt;C_TT_XML_FLAVOUR_EXPORT.CALL METHOD CL_SALV_BS_TT_UTIL=&gt;IF_SALV_BS_TT_UTIL~TRANSFORM EXPORTING XML_TYPE = LS_XML_CHOICE-XML_TYPE XML_VERSION = LV_VERSION R_RESULT_DATA = R_RESULT_DATA XML_FLAVOUR = IF_SALV_BS_C_TT=&gt;C_TT_XML_FLAVOUR_EXPORT IMPORTING XML = LV_XML. （4）下载数据并打开12345GET PEFERENCE OF GT_TABLE INTO LO_DREF.R_RESULT_DATA = CL_SALV_EX_UTIL=&gt;FACTORY_RESULT_DATA_TABLE( R_DATA = LO_DREF S_LAYOUT = GS_LAYOUT T_FIELDCATALOG = GT_FIELDCAT ). 七、Excel下载注意事项1.单位字段处理例如金额，参照 货币转换为外部格式和勤奋为，并将负号提前。 12WRITE GT_MAIN-PRICE TO LV_PRICE CURRENCY GT_MAIN-CURRENCY.CONDENSE: LV_PRICE. 2.数值字段以文本格式存储的数值，需要将负号提前，必要时增加千分位。提前负号使用函数CLOI_PUT_SIGN_IN_FRONT。 12&quot;千分位WRITE LV_NUMBER TO LV_CHAR. 3.日期时间格式适应外部格式 使用函数转换日期格式：CONVERT_DATE_TO_EXTERNAL将日期格式转换为User Profile设置的日期格式 使用掩码：WRITE LV_TIME TO LV_CHAR USING EDIT MASK ‘*:*:‘. 4.含内外码根据字段的convexit属性转换成外码，例如N类型前导0，项目号去掉前导0等。 1234&quot;去除前导0SHIFT LV_CHAR LEFT DELETING LEADING 0.&quot;其他转换字段WRITE LV_PROJ USING EDIT MASK &#x27;==ABPSN&#x27;. 八、参考资料ABAP OLE COLOR","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Excel Donwload","slug":"ABAP/Excel-Donwload","permalink":"https://www.yemaojun.top/categories/ABAP/Excel-Donwload/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP GUI Dynamic Text","slug":"ABAP/ABAP杂项记录/SAP 动态GUI按钮文本/SAP-GUI-Dynmic-Text","date":"2023-04-16T08:30:32.000Z","updated":"2023-05-20T13:06:07.432Z","comments":true,"path":"2023/04/16/ABAP/ABAP杂项记录/SAP 动态GUI按钮文本/SAP-GUI-Dynmic-Text/","link":"","permalink":"https://www.yemaojun.top/2023/04/16/ABAP/ABAP%E6%9D%82%E9%A1%B9%E8%AE%B0%E5%BD%95/SAP%20%E5%8A%A8%E6%80%81GUI%E6%8C%89%E9%92%AE%E6%96%87%E6%9C%AC/SAP-GUI-Dynmic-Text/","excerpt":"这周在正式开发时碰到了一个客户提出来的要求，需要在自定义屏幕的按钮工具栏处实现一个Radio Button，用以显示不同的数据内容。当时想用静态文本然后通过隐藏按钮的方式实现，但是查询和询问一部分同事后发现使用创建按钮时的Dynamic Text的方式更加合适。现将此方式记录如下。其实OOALV也有类似的方式。","text":"这周在正式开发时碰到了一个客户提出来的要求，需要在自定义屏幕的按钮工具栏处实现一个Radio Button，用以显示不同的数据内容。当时想用静态文本然后通过隐藏按钮的方式实现，但是查询和询问一部分同事后发现使用创建按钮时的Dynamic Text的方式更加合适。现将此方式记录如下。其实OOALV也有类似的方式。 SAP GUI Dynamic Text 一、实现方式1.先创建一个程序、屏幕和GUI Status 2.创建动态按钮在新建的GUI Status中，填写动态按钮的Function Code等信息。然后可以从中打开定义动态按钮样式的帮助文档，其中介绍了用于设置按钮样式的结构体类型：SMP_DYNTXT。 TEXT：功能或菜单文本。此文本显示在菜单栏、菜单和Possible的功能列表中。只要ICON_ID组件为空，它也会出现在应用程序工具栏中。 ICON_ID 和 ICON_TEXT：如果要在按钮上显示图标，则必须填写icon_ID。您可以在icon_text中输入其他图标文本。通过为ICON_ID字段分配一个图标来填充该字段（例如，F-ICON_ID&#x3D;ICON_CANCEL）。您不能在此处使用ICON_CREATE功能模块。如果ICON_ID组件包含一个值，您还必须填写TEXT组件，因为它的内容显示在Possible的函数列表中。 QUICKINFO：此文本用作状态行中的快速信息。 3.在TOP中创建按钮样式结构体现在TOP中创建全局变量GS_RADBUT_ONE 和GS_RADBUT_TWO两个按钮样式变量。 123DATA: GS_RADBUT_ONE TYPE SMP_DYNTXT, GS_RADBUT_TWO TYPE SMP_DYNTXT. 然后将其嵌入到参照字段中。因为是定义的全局变量，所以选择Program field选项。 选择程序字段后会弹框的显示程序中你定义的所有程序字段，在其中选择之前定义好的字段即可，在选择前记得激活程序。 剩下的操作基本就和普通的创建按钮流程是一致的。 到了下面这一步就算是绑定完成了，当然也可以再通过下面的Change Text Type将其转换为静态按钮。 4.设置按钮样式与切换逻辑代码因为设置按钮的样式是Radio Button的样式，而这些样式又都存储在ICON表中，所以查询样式如下： 5.编写样式和切换的完整代码逻辑（1）Include TOP123456789101112131415161718192021*----------------------------------------------------------------------** Constants*----------------------------------------------------------------------*CONSTANTS: GC_X TYPE C LENGTH 1 VALUE &#x27;X&#x27;.*----------------------------------------------------------------------** Variables*----------------------------------------------------------------------*DATA: GV_OKCODE TYPE SY-UCOMM, GV_SAVEOK TYPE SY-UCOMM, GV_RAD_ONE TYPE C, GV_RAD_TWO TYPE C.*----------------------------------------------------------------------** Structure*----------------------------------------------------------------------*DATA: GS_RADBUT_ONE TYPE SMP_DYNTXT, GS_RADBUT_TWO TYPE SMP_DYNTXT. （2）Main Program123456789101112131415161718192021222324252627282930*&amp;---------------------------------------------------------------------**&amp; Report YTEST_PROGRAM_ *&amp;---------------------------------------------------------------------**&amp;*&amp;---------------------------------------------------------------------*REPORT YTEST_PROGRAM_ .*----------------------------------------------------------------------** Include*----------------------------------------------------------------------*INCLUDE YTEST_PROGRAM_ _TOP.INCLUDE YTEST_PROGRAM_ _SCR.INCLUDE YTEST_PROGRAM_ _CLA.INCLUDE YTEST_PROGRAM_ _PBO.INCLUDE YTEST_PROGRAM_ _PAI.INCLUDE YTEST_PROGRAM_ _F01.*----------------------------------------------------------------------** INITIALIZATION*----------------------------------------------------------------------*INITIALIZATION.*----------------------------------------------------------------------** END-OF-SELECTION*----------------------------------------------------------------------*END-OF-SELECTION.GV_RAD_ONE = GC_X.IF SY-BATCH IS INITIAL. CALL SCREEN 0100.ENDIF. （3）Include PBO12345678910111213*&amp;---------------------------------------------------------------------**&amp; Module STATUS_0100 OUTPUT*&amp;---------------------------------------------------------------------**&amp;*&amp;---------------------------------------------------------------------*MODULE STATUS_0100 OUTPUT. PERFORM SET_RADIOBUTTON_STYLE USING GV_RAD_ONE TEXT-R01 CHANGING GS_RADBUT_ONE. PERFORM SET_RADIOBUTTON_STYLE USING GV_RAD_TWO TEXT-R02 CHANGING GS_RADBUT_TWO. SET PF-STATUS &#x27;G0100&#x27;.* SET TITLEBAR &#x27;xxx&#x27;.ENDMODULE. （4）Include PAI12345678910111213141516*&amp;---------------------------------------------------------------------**&amp; Module USER_COMMAND_0100 INPUT*&amp;---------------------------------------------------------------------** text*----------------------------------------------------------------------*MODULE USER_COMMAND_0100 INPUT. PERFORM USER_COMMAND_0100.ENDMODULE.*&amp;---------------------------------------------------------------------**&amp; Module EXIT INPUT*&amp;---------------------------------------------------------------------** text*----------------------------------------------------------------------*MODULE EXIT INPUT. PERFORM EXIT.ENDMODULE. （5）Include F011234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283*&amp;---------------------------------------------------------------------**&amp; Form SET_RADIOBUTTON_STYLE*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; PV_FLAG*&amp; --&gt; PV_TEXT*&amp; &lt;-- PS_RADBUT*&amp;---------------------------------------------------------------------*FORM SET_RADIOBUTTON_STYLE USING VALUE(PV_FLAG) VALUE(PV_TEXT) CHANGING VALUE(PS_RADBUT) TYPE SMP_DYNTXT.*--------------------------Variables-----------------------------------* CONSTANTS: LC_SELECT TYPE ICON-ID VALUE &#x27;@TB@&#x27;, LC_UNSELECT TYPE ICON-ID VALUE &#x27;@SR@&#x27;.*----------------------------Logic-------------------------------------* PS_RADBUT-ICON_TEXT = PV_TEXT. PS_RADBUT-QUICKINFO = PV_TEXT. IF PV_FLAG IS NOT INITIAL. PS_RADBUT-ICON_ID = LC_SELECT. ELSE. PS_RADBUT-ICON_ID = LC_UNSELECT. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form USER_COMMAND_0100*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM USER_COMMAND_0100 .*--------------------------Variables-----------------------------------* CONSTANTS: LC_RADONE TYPE SY-UCOMM VALUE &#x27;RADONE&#x27;, LC_RADTWO TYPE SY-UCOMM VALUE &#x27;RADTWO&#x27;.*----------------------------Logic-------------------------------------* CLEAR: GV_SAVEOK. GV_SAVEOK = GV_OKCODE. CLEAR: GV_OKCODE. CASE GV_SAVEOK. WHEN LC_RADONE. IF GV_RAD_ONE IS INITIAL. GV_RAD_ONE = GC_X. CLEAR GV_RAD_TWO. ENDIF. WHEN LC_RADTWO. IF GV_RAD_TWO IS INITIAL. GV_RAD_TWO = GC_X. CLEAR GV_RAD_ONE. ENDIF. WHEN OTHERS. ENDCASE.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form EXIT*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; p1 text*&amp; &lt;-- p2 text*&amp;---------------------------------------------------------------------*FORM EXIT .*--------------------------Variables-----------------------------------* CONSTANTS: LC_BACK TYPE SY-UCOMM VALUE &#x27;BACK&#x27;, LC_EXIT TYPE SY-UCOMM VALUE &#x27;EXIT&#x27;, LC_CANC TYPE SY-UCOMM VALUE &#x27;CANC&#x27;.*----------------------------Logic-------------------------------------* CLEAR: GV_SAVEOK. GV_SAVEOK = GV_OKCODE. CLEAR: GV_OKCODE. CASE GV_SAVEOK. WHEN LC_BACK OR LC_EXIT OR LC_CANC. LEAVE TO SCREEN 0. WHEN OTHERS. ENDCASE.ENDFORM. 6.展示效果（1）初始化页面 （2）点击Radio Button One （3）点击Radio Button Two 二、OOALV的动态按钮实现方式此处提供一个思路，在定义OOALV的Toolbar事件时，通过类似于上面的方式在Toolbar里面修改按钮样式即可实现。 1.实现部分参考代码（1）Include TOP123456789101112131415161718192021222324252627282930313233343536373839404142*----------------------------------------------------------------------** Constants*----------------------------------------------------------------------*CONSTANTS: GC_X TYPE C LENGTH 1 VALUE &#x27;X&#x27;, GC_S TYPE C LENGTH 1 VALUE &#x27;S&#x27;, GC_E TYPE C LENGTH 1 VALUE &#x27;E&#x27;, GC_NULL TYPE C LENGTH 1 VALUE &#x27;&#x27;.*----------------------------------------------------------------------** Variables*----------------------------------------------------------------------*DATA: GV_MESSAGE TYPE C, GV_SAVEOK TYPE SY-UCOMM, OK_CODE TYPE SY-UCOMM, GV_RAD_ONE TYPE C, GV_RAD_TWO TYPE C.*----------------------------------------------------------------------** Structure*----------------------------------------------------------------------*DATA: BEGIN OF GS_TABLE, FIELD, END OF GS_TABLE.*----------------------------------------------------------------------** Internal Table*----------------------------------------------------------------------*DATA: GT_TABLE LIKE TABLE OF GS_TABLE, GT_FIELDCATALOG TYPE LVC_T_FCAT.*----------------------------------------------------------------------** Object*----------------------------------------------------------------------*CLASS LCL_EVENTS DEFINITION DEFERRED.DATA: GO_EVENTS TYPE REF TO LCL_EVENTS, GO_ALV TYPE REF TO CL_GUI_ALV_GRID, GO_CONTAINER TYPE REF TO CL_GUI_DOCKING_CONTAINER. （2）Include CLA123456789101112CLASS LCL_EVENTS DEFINITION. PUBLIC SECTION. METHODS: HANDLE_TOOLBAER FOR EVENT TOOLBAR OF CL_GUI_ALV_GRID IMPORTING E_OBJECT E_INTERACTIVE.ENDCLASS.CLASS LCL_EVENTS IMPLEMENTATION. METHOD HANDLE_TOOLBAER. PERFORM HANDLE_TOOLBAER CHANGING E_OBJECT E_INTERACTIVE.. ENDMETHOD.ENDCLASS. （3）Form HANDLE_TOOLBAER1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374*&amp;---------------------------------------------------------------------**&amp; Form HANDLE_TOOLBAER*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; &lt;-- E_OBJECT*&amp; &lt;-- E_INTERACTIVE*&amp;---------------------------------------------------------------------*FORM HANDLE_TOOLBAER CHANGING VALUE(PO_OBJECT) TYPE REF TO CL_ALV_EVENT_TOOLBAR_SET VALUE(PV_INTERACTIVE).*--------------------------Variables-----------------------------------* CONSTANTS: LC_RADONE TYPE SY-UCOMM VALUE &#x27;RADONE&#x27;, LC_RADTWO TYPE SY-UCOMM VALUE &#x27;RADTWO&#x27;. DATA: LS_TOOLBAER TYPE STB_BUTTON, LV_ICON TYPE ICON-NAME.*----------------------------Logic-------------------------------------* &quot;Set the vertical line that distinguishes the button area LS_TOOLBAER-BUTN_TYPE = 3. APPEND LS_TOOLBAER TO PO_OBJECT-&gt;MT_TOOLBAR. &quot;Radio Button One IF GV_RAD_ONE IS NOT INITIAL. PERFORM SET_TOOLBAER USING LC_RADONE ICON_WD_RADIO_BUTTON TEXT-R01 TEXT-R01 CHANGING PO_OBJECT. ELSE. PERFORM SET_TOOLBAER USING LC_RADONE ICON_WD_RADIO_BUTTON_EMPTY TEXT-R01 TEXT-R01 CHANGING PO_OBJECT. ENDIF. &quot;Radio Button Two IF GV_RAD_TWO IS NOT INITIAL. PERFORM SET_TOOLBAER USING LC_RADONE ICON_WD_RADIO_BUTTON TEXT-R02 TEXT-R02 CHANGING PO_OBJECT. ELSE. PERFORM SET_TOOLBAER USING LC_RADONE ICON_WD_RADIO_BUTTON_EMPTY TEXT-R02 TEXT-R02 CHANGING PO_OBJECT. ENDIF.ENDFORM.*&amp;---------------------------------------------------------------------**&amp; Form SET_TOOLBAER*&amp;---------------------------------------------------------------------**&amp; text*&amp;---------------------------------------------------------------------**&amp; --&gt; PV_FUNC*&amp; --&gt; PV_ICON*&amp; --&gt; PV_QUINFO*&amp; --&gt; PV_TEXT*&amp; &lt;-- PO_OBJECT*&amp;---------------------------------------------------------------------*FORM SET_TOOLBAER USING VALUE(PV_FUNC) VALUE(PV_ICON) VALUE(PV_QUINFO) VALUE(PV_TEXT) CHANGING VALUE(PO_OBJECT) TYPE REF TO CL_ALV_EVENT_TOOLBAR_SET.*--------------------------Variables-----------------------------------* DATA: LS_TOOLBAER TYPE STB_BUTTON.*----------------------------Logic-------------------------------------* CLEAR: LS_TOOLBAER. LS_TOOLBAER-FUNCTION = PV_FUNC. LS_TOOLBAER-ICON = PV_ICON. LS_TOOLBAER-TEXT = PV_TEXT. LS_TOOLBAER-QUICKINFO = PV_QUINFO. APPEND LS_TOOLBAER TO PO_OBJECT-&gt;MT_TOOLBAR.ENDFORM. 响应切换的代码和上面的PAI逻辑一致，但是是写在OOALV的User Command事件中的。 2.结果截图 三、参考资料DYNAMIC ICON&#x2F;TEXT FOR PF STATUS BUTTON","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Dialog","slug":"Dialog","permalink":"https://www.yemaojun.top/categories/Dialog/"},{"name":"OOALV","slug":"OOALV","permalink":"https://www.yemaojun.top/categories/OOALV/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"Walkthrough 练习笔记","slug":"Fiori/Walkthrough/Walkthrough","date":"2023-03-28T13:15:18.000Z","updated":"2023-03-28T14:45:45.012Z","comments":true,"path":"2023/03/28/Fiori/Walkthrough/Walkthrough/","link":"","permalink":"https://www.yemaojun.top/2023/03/28/Fiori/Walkthrough/Walkthrough/","excerpt":"之前学习Fiori时根据官方的帮助文档实现的一个小练习，上传上来以供后续学习参考使用。","text":"之前学习Fiori时根据官方的帮助文档实现的一个小练习，上传上来以供后续学习参考使用。 Walkthrough 练习笔记 一、应用程序的容器1&lt;Shell&gt;&lt;/Shell&gt; 该标签可以用作应用程序的一个容器，通过在桌面屏幕上引入一个所谓letterbox。Shell负责根据设备屏幕大小对应用程序进行视觉调整。 1&lt;content&gt;&lt;/content&gt; 该标签也是一个容器标签、 二、Fiori标准类以下记录的是可以直接使用的标准类，主要是用于设置各组件之间布局的标准类。SAP UI5是一个重量级的框架，也就是说它定制了很多CSS的样式以及自定义的一些组件，开发时不需要我们额外编写这些CSS属性，为开发节省了很多时间。这里就记录一下系统CSS的使用。预设CSS主要是针对于不同尺寸的Margin和Padding的一个设定。 1.marginmargin常用的有以下四个属性： Full Margin：控件四周的距离 Single-sided：上下左右单一方向距离 Two-sided：同时两个方向的距离值 Response Margin：响应式Margin （1）Full Margins sapUiTinyMargin：8px sapUiSmallMargin：16px sapUiMediumMargin：32px sapUiLargeMarin：48px （2）Single-Sided Margins 8px 16px 32px 48px sapUiTinyMarginTop sapUiSmallMarginTop sapUiMediumMarginTop sapUiLargeMarinTop sapUiTinyMarginBottom sapUiSmallMarginBottom sapUiMediumMarginBottom sapUiLargeMarinBottom sapUiTinyMarginBegin sapUiSmallMarginBegin sapUiMediumMarginBegin sapUiLargeMarinBegin sapUiTinyMarginEnd sapUiSmallMarginEnd sapUiMediumMarginEnd sapUiLargeMarinEnd （3）Two-Sided Margins 8px 16px 32px 48px sapUiTinyMarginBeginEnd sapUiSmallMarginBeginEnd sapUiMediumMarginBeginEnd sapUiLargeMarginBeginEnd sapUiTinyMarginBeginBottom sapUiSmallMarginBeginBottom sapUiMediumMarginBeginBottom sapUiLargeMarginBeginBottom （4）Responsive Margins类名： sapUiNoMarginTop； sapUiNoMarginBottom； sapUiNoMarginBegin； sapUiNoMarginEnd； sapUiResponsiveMargin针对不同尺寸进行调整，不包括sap.m.SplitApp。 小于600px时，这时在下边距有一个16像素的边距，上左右的margin都为0 600~1023px时，这时在上下左右边距有一个16像素的边距 大于1023px时，这时在上下左右边距有一个32像素的边距 （5）注意事项使用预设CSS标准类时不要将width设置成100%，而是要设置成auto。若设置为100%则会超出页面边距。 可以根据设备的屏幕大小进行调整，边距也是会对应减小的。这个设置是响应式的。 页边距可以添加到各种控件中，有许多不同的选项。我们甚至可以通过向按钮添加类sapuismallmargined，在按钮和输入字段之间添加空间。 2.Padding sapUiNoContentPadding：移除padding sapUiContentPadding：16px(1 rem) sapUiResponsiveContentPadding： (no padding,16px,32*16px) 1&lt;Page class=”sapUiResponsivePadding”&gt; [https://blog.csdn.net/carawangc/article/details/78790101]: “参考资料” 三、Fiori的CSS1.使用场景有时我们需要定义一些更精细的布局，这时我们可以利用CSS的灵活性，向控件添加自定义样式类，并根据自己的喜好设置样式。 2.注意事项正如兼容性规则中所述，SAPUI5生成的HTML和CSS不是公共API的一部分，可能会在补丁和小版本中更改。如果决定覆盖样式，则有义务在每次更新SAPUI5时测试和更新修改。这样做的前提是，您可以控制正在使用的SAPUI5版本，例如在独立场景中。在SAP Fiori launchpad中运行应用程序时，这是不可能的，因为SAP Fiori launchpad集中加载所有应用程序的SAPUI5。因此，SAP Fiori launchpad应用程序不应覆盖样式。 即使用自定义样式时不要随意覆盖样式，如果覆盖了样式则需要在每次更新UI5时对其进行测试和调试。 创建与自定义名称空间类相结合的自定义类。这样可以确保这些样式只应用于我们应用程序中使用的控件。 对于从右向左（rtl）语言，如阿拉伯语，当应用程序显示反转时，可以设置左边距并重置右边距。如果你只使用标准的SAPUI5控件，你不需要关心这一点，在我们使用自定义CSS的情况下，必须添加这些信息。 123456789101112html[dir=&quot;ltr&quot;] .myAppDemoWT .myCustomButton.sapMBtn &#123; margin-right: 0.125rem&#125;html[dir=&quot;rtl&quot;] .myAppDemoWT .myCustomButton.sapMBtn &#123; margin-left: 0.125rem&#125;.myAppDemoWT .myCustomText &#123; display: inline-block; font-weight: bold;&#125; sapThemeHighlight-asColor：自适应所选主题的颜色设置 四、嵌套视图1.使用场景我们的面板内容变得越来越复杂，现在是时候将面板内容移动到单独的视图中了。通过这种方法，应用程序结构更容易理解，应用程序的各个部分也可以重用。 2.嵌套步骤（1）在主视图中嵌入如下的内容webapp&#x2F;view&#x2F;View1.view.xml 123456789101112131415161718&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.View1&quot; xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; &quot;&lt;!--关键内容1--&gt;&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Shell&gt; &lt;App class=&quot;myAppDemoWT&quot;&gt; &lt;pages&gt; &lt;Page title=&quot;&#123;i18n&gt;title&#125;&quot;&gt; &lt;content&gt; &lt;!--关键内容2--&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.HelloPanel&quot;/&gt; &lt;!--关键内容2--&gt; &lt;/content&gt; &lt;/Page&gt; &lt;/pages&gt; &lt;/App&gt; &lt;/Shell&gt;&lt;/mvc:View&gt; 关键内容1：可以理解为导入Fiori的工具包并起别名“mvc”。 关键内容2：此处就是嵌入视图的地方。 TestCaseTwo：项目的名称，与最上面的controllerName相同； view：视图文件夹的名称； HelloPanel：嵌入的视图名称。 三者联系起来的意思是指在TestCaseTwo这个项目下的view文件夹中的名字叫HelloPanel的视图。 （2）创建嵌套视图在webapp&#x2F;view下新建一个名字叫HelloPanel的视图 webapp&#x2F;view&#x2F;HelloPanel.view.xml 123456789101112&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.HelloPanel&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Panel headerText=&quot;&#123;i18n&gt;helloPanelTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot;&gt; &lt;content&gt; &lt;Button text=&quot;&#123;i18n&gt;showHelloButtonText&#125;&quot; press=&quot;onWhowHello&quot; class=&quot;myCustomButton&quot;/&gt; &lt;Input value=&quot;&#123;/recipient/name&#125;&quot; valueLiveUpdate=&quot;true&quot; width=&quot;60%&quot;/&gt; &lt;FormattedText htmlText=&quot;Hello &#123;/recipient/name&#125;&quot; class=&quot;sapUiSmallMargin sapThemeHighlight-asColor myCustomText&quot;/&gt; &lt;/content&gt; &lt;/Panel&gt;&lt;/mvc:View&gt; （3）创建嵌套视图控制器文件在webapp&#x2F;controller的文件下新建嵌套视图的js文件 webapp&#x2F;controller&#x2F;HelloPanel.controller.js 12345678910111213141516171819202122232425262728293031323334sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/m/MessageToast&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;], function(Controller, MessageToast, JSONModel, ResourceModel) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.HelloPanel&quot;, &#123; onInit : function() &#123; var oData = &#123; recipient : &#123; name : &quot;World&quot; &#125; &#125;; var oModel = new JSONModel(oData); this.getView().setModel(oModel); // set i18n model on view var i18nModel = new ResourceModel(&#123; bundleName:&quot;TestCaseTwo.i18n.i18n&quot; &#125;); this.getView().setModel(i18nModel,&quot;i18n&quot;); &#125;, onWhowHello : function() &#123; //read msg from i18n model var oBundle = this.getView().getModel(&quot;i18n&quot;).getResourceBundle(); var sRecipient = this.getView().getModel().getProperty(&quot;/recipient/name&quot;); var sMsg = oBundle.getText(&quot;helloMsg&quot;,[sRecipient]); //show message MessageToast.show(sMsg); &#125; &#125;);&#125;); （4）主视图控制器文件webapp&#x2F;controller&#x2F;View1.controller.js 12345678sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;], function(Controller) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.View1&quot;, &#123; &#125;);&#125;); webapp&#x2F;i18n&#x2F;i18n.properties 123456title=SAPUI5 WalkthroughappTitle = App TitleappDescription=App DescriptionshowHelloButtonText=Say HellohelloMsg=Hello &#123;0&#125;helloPanelTitle=Hello World （5）效果图展示 五、片段（Dialogs and Fragments ）片段是轻量级的UI部件（UI子树），可以重用，但没有任何控制器。这意味着，无论何时，当您想要定义UI的某个部分在多个视图中可重用，或者当您想要在特定情况下（不同的用户角色、编辑模式与只读模式）交换视图的某些部分时，片段都是一个很好的候选对象，尤其是在不需要额外控制器逻辑的情况下。 一个片段可以由1到n个控件组成。在运行时，放置在视图中的片段的行为类似于“正常”视图内容，这意味着片段中的控件在渲染时只会包含在视图的DOM中。当然，有些控件不是为成为视图的一部分而设计的，例如对话框。 但即使对于这些控件，片段也可能特别有用，稍后您将看到这一点。 现在，我们将在应用程序中添加一个对话框。对话框是特殊的，因为它们是在常规应用程序内容之上打开的，因此不属于特定的视图。这意味着对话框必须在控制器代码中的某个地方实例化，但由于我们希望坚持声明性方法，并创建尽可能灵活的可重用构件，而且由于对话框不能指定为视图，因此我们将创建一个包含该对话框的XML片段。毕竟，一个对话框可以在应用程序的多个视图中使用。 若使用ABAP的知识进行理解，可类比数据库和Include。有5个数据库都使用了相同的维护结构，那么这些维护结构可以使用一个Include来代替。此时片段就相当于是5个数据库的共用结构Include，而数据库则可以理解成是视图。 1.创建片段步骤（1）添加触发片段的按钮webapp&#x2F;view&#x2F;HelloPanel.view.xml 12345678910111213141516171819202122232425262728&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.HelloPanel&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Panel headerText=&quot;&#123;i18n&gt;helloPanelTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot;&gt; &lt;content&gt; &lt;!--新增内容--&gt; &lt;Button id=&quot;helloDialogButton&quot; text=&quot;&#123;i18n&gt;openDialogButtonText&#125;&quot; press=&quot;onOpenDialog&quot; class=&quot;sapUiSmallMarginEnd&quot;/&gt; &lt;!--新增内容--&gt; &lt;Button text=&quot;&#123;i18n&gt;showHelloButtonText&#125;&quot; press=&quot;onWhowHello&quot; class=&quot;myCustomButton&quot;/&gt; &lt;Input value=&quot;&#123;/recipient/name&#125;&quot; valueLiveUpdate=&quot;true&quot; width=&quot;60%&quot;/&gt; &lt;FormattedText htmlText=&quot;Hello &#123;/recipient/name&#125;&quot; class=&quot;sapUiSmallMargin sapThemeHighlight-asColor myCustomText&quot;/&gt; &lt;/content&gt; &lt;/Panel&gt;&lt;/mvc:View&gt; 我们在视图中添加一个新按钮以打开对话框。它只是在面板内容视图的控制器中调用事件处理程序函数。 将helloWorldButton这样的唯一ID设置为应用程序的关键控件是一种很好的做法，这样可以轻松识别。如果未指定属性’id’，OpenUI5运行时将为控件生成唯一但不断变化的id，如u button23。在浏览器中检查应用程序的DOM元素以查看差异。 （2）创建片段代码webapp&#x2F;view&#x2F;HelloDialog.Fragment.xml 123456789&lt;core:FragmentDefinition xmlns=&quot;sap.m&quot; xmlns:core=&quot;sap.ui.core&quot;&gt; &lt;Dialog id=&quot;helloDialog&quot; title=&quot;Hello &#123;/recipient/name&#125;&quot;/&gt; &lt;/core:FragmentDefinition&gt; 我们添加一个新的XML文件，以声明方式在片段中定义我们的对话框。片段资产位于核心名称空间中，因此我们在FragmentDefinition标记中为其添加了一个xml名称空间。 语法类似于视图，但由于片段没有控制器，因此缺少该属性。此外，片段在应用程序的DOM树中没有任何足迹，并且片段本身没有控件实例（只有包含的控件）。它只是一组重用控件的容器。 （3）编写触发片段的按钮逻辑webapp&#x2F;controller&#x2F;HelloPanel.controller.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/m/MessageToast&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;, &quot;sap/ui/core/Fragment&quot; //新增内容], function(Controller, MessageToast, JSONModel, ResourceModel,Fragment) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.HelloPanel&quot;, &#123; onInit : function() &#123; var oData = &#123; recipient : &#123; name : &quot;World&quot;, text : &quot;ok&quot; &#125; &#125;; var oModel = new JSONModel(oData); this.getView().setModel(oModel); // set i18n model on view var i18nModel = new ResourceModel(&#123; bundleName:&quot;TestCaseTwo.i18n.i18n&quot; &#125;); this.getView().setModel(i18nModel,&quot;i18n&quot;); &#125;, onWhowHello : function() &#123; //read msg from i18n model var oBundle = this.getView().getModel(&quot;i18n&quot;).getResourceBundle(); var sRecipient = this.getView().getModel().getProperty(&quot;/recipient/name&quot;); var sMsg = oBundle.getText(&quot;helloMsg&quot;,[sRecipient]); //show message MessageToast.show(sMsg); &#125;, //新增内容 onOpenDialog : function()&#123; // create dialog lazily var oView = this.getView(); var oModel = this.getView().getModel(); if (!this.pDialog) &#123; this.pDialog = Fragment.load(&#123; id:oView.getId(), name: &quot;TestCaseTwo.view.HelloDialog&quot;, controller:this &#125;); &#125; this.pDialog.then(function(oDialog) &#123; oDialog.setModel(oModel); oDialog.open(); &#125;); &#125; //新增内容 &#125;);&#125;); 此处如果参照样例去编写会有两个问题： 读取Fragment对象时，样例使用的是this.loadFragment的方式，但是该方式使用的方法是在1.93版本的里的方法，低于该版本的Fiori无法使用该方法。所以使用相对较低的方式如代码所示； 该问题可能的原因还是版本问题，我们在实例化Dialog对象时，需要将数据模型一起传递过去，但是在样例中却没有类似的操作，所以需要我们手动补齐。 2.创建片段回调步骤（1）创建响应关闭弹窗的按钮webapp&#x2F;view&#x2F;HelloDialog.fragment.xml 123456789101112&lt;core:FragmentDefinition xmlns=&quot;sap.m&quot; xmlns:core=&quot;sap.ui.core&quot;&gt; &lt;Dialog id=&quot;helloDialog&quot; title=&quot;Hello &#123;/recipient/name&#125;&quot;&gt; &lt;!--新增内容--&gt; &lt;beginButton&gt; &lt;Button text=&quot;&#123;/recipient/text&#125;&quot; press=&quot;.onCloseDialog&quot; class=&quot;sapThemeHighlight-asColor&quot;/&gt; &lt;/beginButton&gt; &lt;/Dialog&gt; &lt;!--新增内容--&gt;&lt;/core:FragmentDefinition&gt; 新增一个按钮标签，添加点击触发的逻辑方法onCloseDialog()，设置文本来自传递过来的数据模型。Class中代表对应版本的字体颜色。 标签&lt;beginButton&gt;是一个聚合。在这两个聚合中放置按钮可以确保在UI上，beginButton放在endButton之前。然而，before的意思取决于当前语言的文本方向。因此，我们使用begin和end作为“left”和“right”的同义词。在具有从左到右方向的语言中，beginButton将呈现为left，endButton位于对话框页脚右侧；在特定语言的从右到左模式中，顺序将被切换。 （2）设置关闭方法webapp&#x2F;controller&#x2F;HelloPanel.controller.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/m/MessageToast&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;, &quot;sap/ui/core/Fragment&quot;], function(Controller, MessageToast, JSONModel, ResourceModel,Fragment) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.HelloPanel&quot;, &#123; onInit : function() &#123; var oData = &#123; recipient : &#123; name : &quot;World&quot;, text : &quot;ok&quot; //新增内容 &#125; &#125;; var oModel = new JSONModel(oData); this.getView().setModel(oModel); // set i18n model on view ... &#125;, onWhowHello : function() &#123; ... &#125;, onOpenDialog : function()&#123; // create dialog lazily var oView = this.getView(); var oModel = this.getView().getModel(); if (!this.pDialog) &#123; this.pDialog = Fragment.load(&#123; id:oView.getId(), name: &quot;TestCaseTwo.view.HelloDialog&quot;, controller:this //新增内容 &#125;); &#125; this.pDialog.then(function(oDialog) &#123; oDialog.setModel(oModel); oDialog.open(); &#125;); &#125;, //新增内容 onCloseDialog : function()&#123; // note: We don&#x27;t need to chain to the pDialog promise, since this event-handler // is only called from within the loaded dialog itself. this.byId(&quot;helloDialog&quot;).close(); &#125; //新增内容 &#125;);&#125;); 如前所述，片段是纯UI重用工件，没有控制器。但是，可以将控制器对象传递给片段。加载API。对于我们的对话框，我们参考HelloPanel控制器。然而，第三个参数不一定是控制器，但可以是任何对象。只是别忘了这个关键词。 事件处理函数被放入同一个控制器文件中，它通过访问返回对话框的内部帮助函数来关闭对话框。 （3）展示效果图 3.通过组件重用片段（1）实例化对话框组件 添加进组件的声明周期webapp&#x2F;Component.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657sap.ui.define([ &quot;sap/ui/core/UIComponent&quot;, &quot;sap/ui/Device&quot;, &quot;TestCaseTwo/model/models&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;, &quot;./controller/HelloDialog&quot;], function(UIComponent, Device, models,JSONModel,ResourceModel,HelloDialog) &#123; &quot;use strict&quot;; return UIComponent.extend(&quot;TestCaseTwo.Component&quot;, &#123; metadata: &#123; manifest: &quot;json&quot; &#125;, /** * The component is initialized by UI5 automatically during the startup of the app and calls the init method once. * @public * @override */ init: function() &#123; // call the base component&#x27;s init function UIComponent.prototype.init.apply(this, arguments); // set the device model this.setModel(models.createDeviceModel(), &quot;device&quot;); var oData = &#123; recipient : &#123; name : &quot;World&quot;, text : &quot;ok&quot; &#125; &#125;; var oModel = new JSONModel(oData); this.getView().setModel(oModel); // set i18n model on view var i18nModel = new ResourceModel(&#123; bundleName:&quot;TestCaseTwo.i18n.i18n&quot; &#125;); this.getView().setModel(i18nModel,&quot;i18n&quot;); // set dialog this._helloDialog = new HelloDialog(this.getRootControl()); // &#125;, exit : function()&#123; this._helloDialog.destroy(); delete this._helloDialog; &#125;, openHelloDialog : function()&#123; this._helloDialog.open(); &#125; &#125;);&#125;); 此处的this指代的UIComponent（UI组件），在初始化时声明了一个UI的属性 _helloDialog 。该属性是一个对象，由HelloDialog构造方法创建的对话框对象。因为我们要将重用对话框连接到应用程序根视图的生命周期，因此我们将根视图的一个实例传递给构造函数。可以通过调用组件的getRootControl方法来检索它。 为了能够从其他控制器打开对话框，我们实现了一个重用函数openHelloDialog，它调用我们的助手对象的open方法。通过这样做，我们还将重用对话框的实现细节与应用程序编码分离。 到目前为止，我们向组件添加了新属性_helloDialog，并为其分配了helloDialog对象的一个实例。我们希望确保当组件被销毁时，为这个helper对象分配的内存被释放。否则，我们的应用程序可能会导致内存泄漏。 为此，我们使用出口挂钩。SAPUI5框架在销毁组件时调用分配给退出的函数。我们调用HelloDialog的destroy函数来清理helper类并结束其生命周期。尽管如此，实例本身仍将存在于浏览器内存中。因此，我们通过调用delete this来删除对HelloDialog实例的引用_helloDialog和浏览器的垃圾收集可以清理其内存。 简言之，我们将对话框的实例化放到了UI组件的声明周期中，在Fiori开始时就将对话框组件实例化，当Fiori生命周期结束时，对话框组件也同样被释放掉。 将重用的对话框组件实例化到UI组件的声明周期中； 将对话框组件绑定为UIComponent的一个属性； 重用了一个调用对话框组件的函数。 （2）对话框组件的实例化代码注意该文件的命名不能加controller 命名似乎有限制，添加后系统会报错找不到对应的文件 webapp&#x2F;controller&#x2F;HelloDialog.js (New) 123456789101112131415161718192021222324252627282930313233343536373839404142sap.ui.define([ &quot;sap/ui/base/ManagedObject&quot;, &quot;sap/ui/core/Fragment&quot;], function (ManagedObject,Fragment ) &#123; &quot;use strict&quot;; return ManagedObject.extend(&quot;TestCaseTwo.controller.HelloDialog&quot;,&#123; constructor : function(oView)&#123; this._oView = oView; &#125;, exit : function() &#123; delete this._oView; &#125;, open : function() &#123; var oView = this._oView; // 创建对话框 if (!this.pDialog)&#123; var oFragmentController = &#123; onCloseDialog : function() &#123; oView.byId(&quot;helloDialog&quot;).close(); &#125; &#125;; // 加载异步XML片段 this.pDialog = Fragment.load(&#123; id : oView.getId(), name : &quot;TestCaseTwo.view.HelloDialog&quot;, controller : oFragmentController &#125;).then(function (oDialog) &#123; // 将对话框连接到此组件的根视图（模型、生命周期） oView.addDependent(oDialog); return oDialog; &#125;); &#125; this.oDialog.then(function(oDialog) &#123; oDialog.open(); &#125;); &#125; &#125;);&#125;); open：open方法是打开对话框的方法，先判断对话框是否实例化。若没有实例化，则先关闭对话框，在实例化对话框组件并添加进视图的声明周期。 HelloDialog重用对象的实现扩展了sap.ui.base.ManagedObject继承SAPUI5的一些核心功能。 我们的open方法是从HelloPanel控制器重构而来的，并像前面的步骤一样实例化我们的对话框片段。 我们不会将控制器作为第三个参数传递给函数片段。Fragment.load的本地助手对象，该对象包含片段所需的事件处理程序函数onCloseDialog。open方法现在包含我们的对话框实例化。第一次调用open方法时，对话框被实例化。此方法的oView参数用于将当前视图连接到对话框。稍后我们将在控制器中调用该对象的open方法。 onCloseDialog事件处理程序只需从HelloPanel控制器移动到重用对象。 我们还添加了一个退出函数，就像我们在组件中所做的那样，当对象被销毁时会自动调用该函数。为了释放helper对象中所有分配的内存，我们删除了保存视图引用的属性。视图本身将被组件破坏，所以我们不需要注意这一点。 （3）修改触发弹出框的逻辑webapp&#x2F;controller&#x2F;HelloPanel.controller.js 1234567891011121314151617181920212223sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/m/MessageToast&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;, &quot;sap/ui/core/Fragment&quot;], function(Controller, MessageToast, JSONModel, ResourceModel,Fragment) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.HelloPanel&quot;, &#123; onWhowHello : function() &#123; //read msg from i18n model var oBundle = this.getView().getModel(&quot;i18n&quot;).getResourceBundle(); var sRecipient = this.getView().getModel().getProperty(&quot;/recipient/name&quot;); var sMsg = oBundle.getText(&quot;helloMsg&quot;,[sRecipient]); //show message MessageToast.show(sMsg); &#125;, onOpenDialog : function()&#123; this.getOwnerComponent().openHelloDialog(); &#125; &#125;);&#125;); OnPendialog方法现在通过调用helper方法getOwnerComponent来访问其组件。当调用重用对象的open方法时，我们在当前视图中传递，以将其连接到对话框。 （4）创建另一个触发对话框的事件源webapp&#x2F;view &#x2F;View1.view.xml 12345678910111213141516171819&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.View1&quot; xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Shell&gt; &lt;App class=&quot;myAppDemoWT&quot;&gt; &lt;pages&gt; &lt;Page title=&quot;&#123;i18n&gt;title&#125;&quot;&gt; &lt;headerContent&gt; &lt;Button icon=&quot;sap-icon://hello-world&quot; press=&quot;.onOpenDialog&quot;/&gt; &lt;/headerContent&gt; &lt;content&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.HelloPanel&quot;/&gt; &lt;/content&gt; &lt;/Page&gt; &lt;/pages&gt; &lt;/App&gt; &lt;/Shell&gt;&lt;/mvc:View&gt; 我们在应用程序视图的标题区域添加了一个按钮，以显示hello world对话框的重用。按下按钮时，对话框将与我们之前在面板中创建的按钮一样打开。 （5）编写主视图对应的打开对话框方法webapp&#x2F;controller&#x2F;View1.controller.js 1234567891011sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;], function(Controller) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.View1&quot;, &#123; onOpenDialog : function () &#123; this.getOwnerComponent().openHelloDialog(); &#125; &#125;);&#125;); 我们还将onOpenDialog方法添加到应用程序控制器中，这样对话框将打开并引用当前视图。 （6）展示效果 六、图标SAP Fiori的图标库有500多个图标可供选择。本次在按钮和弹出框的中心设置图标用于展示。 （1）给按钮添加图标属性webapp&#x2F;view&#x2F;HelloPanel.view.xml 123456789101112131415161718192021222324252627&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.HelloPanel&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Panel headerText=&quot;&#123;i18n&gt;helloPanelTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot;&gt; &lt;content&gt; &lt;Button id=&quot;helloDialogButton&quot; icon=&quot;sap-icon://world&quot; &lt;!--新增内容--&gt; text=&quot;&#123;i18n&gt;openDialogButtonText&#125;&quot; press=&quot;onOpenDialog&quot; class=&quot;sapUiSmallMarginEnd&quot;/&gt; &lt;Button text=&quot;&#123;i18n&gt;showHelloButtonText&#125;&quot; press=&quot;onWhowHello&quot; class=&quot;myCustomButton&quot;/&gt; &lt;Input value=&quot;&#123;/recipient/name&#125;&quot; valueLiveUpdate=&quot;true&quot; width=&quot;60%&quot;/&gt; &lt;FormattedText htmlText=&quot;Hello &#123;/recipient/name&#125;&quot; class=&quot;sapUiSmallMargin sapThemeHighlight-asColor myCustomText&quot;/&gt; &lt;/content&gt; &lt;/Panel&gt;&lt;/mvc:View&gt; sap icon:&#x2F;&#x2F;协议指示应加载图标字体中的图标。 （2）在弹出框中添加图标webapp&#x2F;view&#x2F;HelloDialog.fragment.xml 123456789101112131415161718&lt;core:FragmentDefinition xmlns=&quot;sap.m&quot; xmlns:core=&quot;sap.ui.core&quot;&gt; &lt;Dialog id=&quot;helloDialog&quot; title=&quot;Hello &#123;/recipient/name&#125;&quot;&gt; &lt;!--新增内容--&gt; &lt;content&gt; &lt;core:Icon src=&quot;sap-icon://hello-world&quot; size=&quot;8rem&quot; class=&quot;sapUiMediumMargin&quot;/&gt; &lt;/content&gt; &lt;!--新增内容--&gt; &lt;beginButton&gt; &lt;Button text=&quot;&#123;/recipient/text&#125;&quot; press=&quot;.onCloseDialog&quot; class=&quot;sapThemeHighlight-asColor&quot;/&gt; &lt;/beginButton&gt; &lt;/Dialog&gt;&lt;/core:FragmentDefinition&gt; &lt;content&gt;在第一个知识点中有提到过，是一个容器标签，用于将内容限制在容器中 （3）效果展示图 七、聚合绑定（Aggregation Binding）现在我们已经为我们的应用程序建立了一个良好的结构，是时候添加更多功能了。通过添加一些JSON格式的发票数据，我们开始探索数据绑定的更多功能，这些数据显示在面板下方的列表中。 （1）创建测试数据文件webapp&#x2F;Invoices.json (New) 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;Invoices&quot;: [ &#123; &quot;ProductName&quot;: &quot;Pineapple&quot;, &quot;Quantity&quot;: 21, &quot;ExtendedPrice&quot;: 87.2000, &quot;ShipperName&quot;: &quot;Fun Inc.&quot;, &quot;ShippedDate&quot;: &quot;2015-04-01T00:00:00&quot;, &quot;Status&quot;: &quot;A&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Milk&quot;, &quot;Quantity&quot;: 4, &quot;ExtendedPrice&quot;: 9.99999, &quot;ShipperName&quot;: &quot;ACME&quot;, &quot;ShippedDate&quot;: &quot;2015-02-18T00:00:00&quot;, &quot;Status&quot;: &quot;B&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Canned Beans&quot;, &quot;Quantity&quot;: 3, &quot;ExtendedPrice&quot;: 6.85000, &quot;ShipperName&quot;: &quot;ACME&quot;, &quot;ShippedDate&quot;: &quot;2015-03-02T00:00:00&quot;, &quot;Status&quot;: &quot;B&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Salad&quot;, &quot;Quantity&quot;: 2, &quot;ExtendedPrice&quot;: 8.8000, &quot;ShipperName&quot;: &quot;ACME&quot;, &quot;ShippedDate&quot;: &quot;2015-04-12T00:00:00&quot;, &quot;Status&quot;: &quot;C&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Bread&quot;, &quot;Quantity&quot;: 1, &quot;ExtendedPrice&quot;: 2.71212, &quot;ShipperName&quot;: &quot;Fun Inc.&quot;, &quot;ShippedDate&quot;: &quot;2015-01-27T00:00:00&quot;, &quot;Status&quot;: &quot;A&quot; &#125; ]&#125; 发票文件只包含五张JSON格式的发票，我们可以使用它们在应用程序中绑定控件。JSON是一种非常轻量级的数据存储格式，可以直接用作SAPUI5应用程序的数据源。 （2）配置测试数据模型webapp&#x2F;manifest.json 123456789101112131415161718192021222324&#123;… &quot;sap.ui5&quot;: &#123; &quot;rootView&quot;: &quot;sap.ui.demo.walkthrough.view.App&quot;,[…] &quot;models&quot;: &#123; &quot;i18n&quot;: &#123; &quot;type&quot;: &quot;sap.ui.model.resource.ResourceModel&quot;, &quot;settings&quot;: &#123; &quot;bundleName&quot;: &quot;sap.ui.demo.walkthrough.i18n.i18n&quot;, &quot;supportedLocales&quot;: [&quot;&quot;], &quot;fallbackLocale&quot;: &quot;&quot; &#125; &#125; // 新增内容 , &quot;invoice&quot;: &#123; &quot;type&quot;: &quot;sap.ui.model.json.JSONModel&quot;, &quot;uri&quot;: &quot;Invoices.json&quot; &#125; // 新增内容 &#125; &#125;&#125; 该操作将自动实例化一个别名为“invoice”的数据模型。因为是数据模型，所以在类型方面传递”sap.ui.model.json.JSONModel”。uri指定的是文件所在的路径。不过要注意的是这种方式创建的数据模型只能在版本1.30以上的版中使用，低于这个版本的需要使用在组件的init方法中手动实例化资源包和应用程序的Component.js文件。 （3）增加一个嵌套视图webapp&#x2F;view&#x2F;View1.view.xml 1234567891011121314151617181920&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.View1&quot; xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Shell&gt; &lt;App class=&quot;myAppDemoWT&quot;&gt; &lt;pages&gt; &lt;Page title=&quot;&#123;i18n&gt;title&#125;&quot;&gt; &lt;headerContent&gt; &lt;Button icon=&quot;sap-icon://hello-world&quot; press=&quot;.onOpenDialog&quot;/&gt; &lt;/headerContent&gt; &lt;content&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.HelloPanel&quot;/&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.InvoiceList&quot;/&gt; &lt;!--新增内容--&gt; &lt;/content&gt; &lt;/Page&gt; &lt;/pages&gt; &lt;/App&gt; &lt;/Shell&gt;&lt;/mvc:View&gt; （4）编写嵌套的视图的内容webapp&#x2F;view&#x2F;InvoiceList.view.xml (New) 1234567891011121314&lt;mvc:View xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123;invoice&gt;/Invoices&#125;&quot;&gt; &lt;items&gt; &lt;ObjectListItem title=&quot;&#123;invoice&gt;Quantity&#125; x &#123;invoice&gt;ProductName&#125;&quot;/&gt; &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 新视图显示了一个带有自定义标题文本的列表控件。列表的项聚合绑定到JSON数据的根路径。由于我们定义了一个命名模型，我们必须在每个绑定定义前面加上标识符invoice&gt;。 在items聚合中，我们为列表定义模板，该模板将自动为测试数据的每个发票重复。更准确地说，我们使用ObjectListItem为items聚合的每个聚合子级创建一个控件。列表项的标题属性绑定到单个发票的属性。这是通过定义一个相对路径（没有&#x2F;在开始时）来实现的。这是因为我们通过items&#x3D;{invoice&gt;&#x2F;Invoices}将items聚合绑定到发票。 （5）设置i18n文件1234...# Invoice ListinvoiceListTitle=Invoices （6）展示效果图 八、数据类型接下来设置各项发票中的金额和单位。 （1）在列表中添加货币和货币单位webapp&#x2F;view&#x2F;InvoiceList.view.xml 12345678910111213141516171819202122232425&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123;invoice&gt;/Invoices&#125;&quot;&gt; &lt;items&gt; &lt;ObjectListItem title=&quot;&#123;invoice&gt;Quantity&#125; x &#123;invoice&gt;ProductName&#125;&quot; &lt;!--新增内容--&gt; number=&quot;&#123; parts:[&#123;path: &#x27;invoice&gt;ExtendedPrice&#x27;&#125;,&#123;path: &#x27;view&gt;/currency&#x27;&#125;], type: &#x27;sap.ui.model.type.Currency&#x27;, formatOpentions: &#123; showMeasure: false &#125; &#125;&quot; numberUnit=&quot;&#123;view&gt;/currency&#125;&quot;/&gt; &lt;!--新增内容--&gt; &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 通过设置了列表的number和numberUnit属性来设置列表中的金额和金额单位。因为金额是数字，所以设置显示类型是sap.ui.model.type.Currency。 如上所示，我们对ObjectListItem的number属性使用了一种特殊的绑定语法。这种绑定语法使用所谓的“计算字段”，允许将不同模型的多个属性绑定到控件的单个属性。从不同模型绑定的属性称为“零件”。在上面的示例中，控件的属性是number，从两个不同的模型检索到的绑定属性（“部件”）是invoice&gt;ExtendedPrice和view&gt;&#x2F;currency。 我们希望以欧元显示价格，通常情况下，货币是后端数据模型的一部分。在我们的例子中，情况并非如此，因此我们需要直接在应用程序中定义它。因此，我们为发票列表添加了一个控制器，并使用currency属性作为绑定语法的第二部分。货币类型将根据货币代码为我们处理价格格式。在我们的例子中，价格以2位小数显示。 此外，我们还将格式选项showMeasure设置为false。这会在属性号中隐藏货币代码，因为它会作为单独的属性号RunIt传递给ObjectListItem控件。 （2）设置货币的单位数据模型12345678910111213141516sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/model/json/JSONModel&quot;], function (Controller, JSONModel) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.InvoiceList&quot;,&#123; onInit : function()&#123; var oViewModel = new JSONModel(&#123; currency: &quot;EUR&quot; &#125;); this.getView().setModel(oViewModel,&quot;view&quot;); &#125; &#125;); &#125;); （3）效果图展示 九、绑定表达式有时，预定义的SAPUI5类型不够灵活，您需要在视图中进行简单的计算或格式化，这正是表达式真正有用的地方。我们使用它们根据数据模型中的当前数字来设置价格。 （1）添加表达式webapp&#x2F;view&#x2F;InvoiceList.view.xml 123456789101112131415161718192021222324&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123;invoice&gt;/Invoices&#125;&quot;&gt; &lt;items&gt; &lt;ObjectListItem title=&quot;&#123;invoice&gt;Quantity&#125; x &#123;invoice&gt;ProductName&#125;&quot; number=&quot;&#123; parts:[&#123;path: &#x27;invoice&gt;ExtendedPrice&#x27;&#125;,&#123;path: &#x27;view&gt;/currency&#x27;&#125;], type: &#x27;sap.ui.model.type.Currency&#x27;, formatOpentions: &#123; showMeasure: false &#125; &#125;&quot; numberUnit=&quot;&#123;view&gt;/currency&#125;&quot; numberState=&quot;&#123;= $&#123;invoice&gt;ExtendedPrice&#125; &gt; 50 ? &#x27;Error&#x27; : &#x27;Success&#x27; &#125;&quot;/&gt;//新增内容 &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 通过新增属性numberState并给属性的赋值中使用三元运算符，来进行属性的设置。当金额大于50时设置numberState为“Error”（红色），反之小于等于50的数据设置属性为“Success”（绿色）。 表达式仅限于帮助格式化数据的一组特定操作，如数学表达式、比较等。您可以在文档中查找可能的操作。 （2）效果图展示 十、自定义格式化程序如果我们想对数据模型的属性进行更复杂的格式化逻辑，我们还可以编写一个自定义格式化函数。我们现在将添加一个带有自定义格式化程序的本地化状态，因为数据模型中的状态是一种相当技术性的格式。 （1）编写自定义格式化的工具JSwebapp&#x2F;model&#x2F;formatter.js (New) 123456789101112131415161718sap.ui.define([],function () &#123; &quot;use strict&quot;; return &#123; statusText: function (sStatus)&#123; var resourceBundle = this.getView().getModel(&quot;i18n&quot;).getResourceBundle(); switch (sStatus)&#123; case &quot;A&quot;: return resourceBundle.getText(&quot;invoiceStatusA&quot;); case &quot;B&quot;: return resourceBundle.getText(&quot;invoiceStatusB&quot;); case &quot;C&quot;: return resourceBundle.getText(&quot;invoiceStatusC&quot;); default: return sStatus; &#125; &#125; &#125;;&#125;); 创建工具JavaScript文件，里面主要是使用由调用函数的对象传递进来的参数进行判断，并将i18n数据模型中对应字段的值返回回来。 函数statusText从数据模型获取技术状态作为输入参数，并返回从resourceBundle文件读取的可读文本。 （2）加载自定义格式化工具代码webapp&#x2F;controller&#x2F;InvoiceList.controller.js 123456789101112131415161718sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;./formatter&quot; //新增内容], function (Controller, JSONModel, formatter) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.InvoiceList&quot;,&#123; formatter: formatter, //新增内容 onInit : function()&#123; var oViewModel = new JSONModel(&#123; currency: &quot;EUR&quot; &#125;); this.getView().setModel(oViewModel,&quot;view&quot;); &#125; &#125;); &#125;); 要加载格式化程序函数，我们必须将其添加到InvoiceList.controller.js。在这个控制器中，我们首先向自定义格式化程序模块添加一个依赖项。控制器只是将加载的格式化程序函数存储在本地属性格式化程序中，以便能够在视图中访问它们。 （3）将自定义格式化的数据绑定视图位置webapp&#x2F;view&#x2F;InvoiceList.view.xml 123456789101112131415161718192021222324252627282930313233&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123;invoice&gt;/Invoices&#125;&quot;&gt; &lt;items&gt; &lt;ObjectListItem title=&quot;&#123;invoice&gt;Quantity&#125; x &#123;invoice&gt;ProductName&#125;&quot; number=&quot;&#123; parts:[&#123;path: &#x27;invoice&gt;ExtendedPrice&#x27;&#125;,&#123;path: &#x27;view&gt;/currency&#x27;&#125;], type: &#x27;sap.ui.model.type.Currency&#x27;, formatOpentions: &#123; showMeasure: false &#125; &#125;&quot; numberUnit=&quot;&#123;view&gt;/currency&#125;&quot; numberState=&quot;&#123;= $&#123;invoice&gt;ExtendedPrice&#125; &gt; 50 ? &#x27;Error&#x27; : &#x27;Success&#x27; &#125;&quot;&gt; &lt;!--新增内容--&gt; &lt;firstStatus&gt; &lt;ObjectStatus text=&quot;&#123; path: &#x27;invoice&gt;Status&#x27;, formatter: &#x27;.formatter.statusText&#x27; &#125;&quot;/&gt; &lt;/firstStatus&gt; &lt;/ObjectListItem&gt; &lt;!--新增内容--&gt; &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 我们使用firstStatus聚合将一个状态添加到ObjectListItem，它将显示发票的状态。自定义格式化程序函数是使用绑定语法的保留属性格式化程序指定的。“A”格式化程序名称前面表示在当前视图的控制器中查找函数。在那里，我们定义了一个属性格式化程序，它保存格式化程序函数，因此我们可以通过.formatter.statusText的方式调用方法并传递参数。 （4）设置i18n的文本webapp&#x2F;i18n&#x2F;i18n.properties 1234567...# Invoice ListinvoiceListTitle=InvoicesinvoiceStatusA=NewinvoiceStatusB=In ProgressinvoiceStatusC=Done 在工具formatter.js文件中，是通过读取数据模型i18n中的可读文本并将文本的值返回回去。 （5）效果图展示 十一、过滤器在这一步中，我们为产品列表添加一个搜索字段，并定义一个表示搜索词的过滤器。搜索时，列表会自动更新，仅显示与搜索词匹配的项目。 （1）添加搜索框webapp&#x2F;view&#x2F;InvoiceList.view.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List id=&quot;invoiceList&quot; &lt;!--新增内容--&gt; headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123;invoice&gt;/Invoices&#125;&quot;&gt; &lt;!--新增内容--&gt; &lt;headerToolbar&gt; &lt;Toolbar&gt; &lt;Title text=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot;/&gt; &lt;ToolbarSpacer/&gt; &lt;SearchField width=&quot;50%&quot; search=&quot;.onFilterInvoices&quot;/&gt; &lt;/Toolbar&gt; &lt;/headerToolbar&gt; &lt;!--新增内容--&gt; &lt;items&gt; &lt;ObjectListItem title=&quot;&#123;invoice&gt;Quantity&#125; x &#123;invoice&gt;ProductName&#125;&quot; number=&quot;&#123; parts:[&#123;path: &#x27;invoice&gt;ExtendedPrice&#x27;&#125;,&#123;path: &#x27;view&gt;/currency&#x27;&#125;], type: &#x27;sap.ui.model.type.Currency&#x27;, formatOpentions: &#123; showMeasure: false &#125; &#125;&quot; numberUnit=&quot;&#123;view&gt;/currency&#125;&quot; numberState=&quot;&#123;= $&#123;invoice&gt;ExtendedPrice&#125; &gt; 50 ? &#x27;Error&#x27; : &#x27;Success&#x27; &#125;&quot;&gt; &lt;firstStatus&gt; &lt;ObjectStatus text=&quot;&#123; path: &#x27;invoice&gt;Status&#x27;, formatter: &#x27;.formatter.statusText&#x27; &#125;&quot;/&gt; &lt;/firstStatus&gt; &lt;/ObjectListItem&gt; &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 为发票表格扩展了一个搜索控件，并为列表控件添加一个ID invoiceList，如此便可以从搜索字段的FilterInvoices上的事件处理程序函数中识别的列表。搜索字段是列表标题的一部分，因此，对列表绑定的每次更改都将触发整个列表（包括搜索字段）的重新排序。 headerToolbar聚合替换了我们之前用于列表标题的简单标题属性。工具栏控件更加灵活，可以根据需要进行调整。使用了sap.m.Title 控制表格的标题。间隔符和在右侧的sap.m.SearchField。 （2）设置过滤框的响应逻辑webapp&#x2F;controller&#x2F;InvoiceList.controller.js 12345678910111213141516171819202122232425262728293031323334353637sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;./formatter&quot;, //新增内容 &quot;sap/ui/model/Filter&quot;, &quot;sap/ui/model/FilterOperator&quot; //新增内容], function (Controller, JSONModel, formatter, Filter, FilterOperator) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.InvoiceList&quot;,&#123; formatter: formatter, onInit : function()&#123; var oViewModel = new JSONModel(&#123; currency: &quot;EUR&quot; &#125;); this.getView().setModel(oViewModel,&quot;view&quot;); &#125;, //新增内容 onFilterInvoices : function(oEvent) &#123; // 构建过滤器阵列 var aFilter = []; var sQuery = oEvent.getParameter(&quot;query&quot;); if (sQuery)&#123; aFilter.push(new Filter(&quot;ProductName&quot;,FilterOperator.Contains,sQuery)); &#125; // 过滤内容 var oList = this.byId(&quot;invoiceList&quot;); var oBinding = oList.getBinding(&quot;items&quot;); oBinding.filter(aFilter); &#125; //新增内容 &#125;); &#125;); 此处先构建了一个空数组变量aFilter，然后通过搜索帮助事件传递过来的事件对象获取搜索帮助框中传递过来的过滤内容到sQuery变量中。然后创建了一个过滤对象添加到数组中。 获取列表组件，然后在获取列表的items内容，再将添加了过滤条件的数组传递到列表的过滤函数中获取到过滤内容。并刷新列表，此处的数组aFilter可以理解成ABAP中的Rangle表。数组为空时全查，反之根据内表中的数据过滤数据。但是不同的一点是此处的查询时模糊查询。 为过滤加载了两个新的依赖项。filter对象将保存我们对filter操作的配置，FilterOperator是我们指定筛选器所需的助手类型。如果我们想搜索多个数据字段，我们还可以向数组中添加更多过滤器。在我们的示例中，我们只需在ProductName路径中搜索，并指定一个将搜索给定查询字符串的筛选器运算符。 使用我们在视图中指定的ID访问列表，因为控件自动以视图ID作为前缀，所以我们需要向视图请求带有帮助函数byId的控件。在列表控件上，我们访问聚合项的绑定，用新构造的过滤器对象对其进行过滤。这将根据我们的搜索字符串自动筛选列表，以便在触发搜索时仅显示匹配的项目。过滤器操作员过滤器操作员。Contains不区分大小写。 （3）效果图展示 十二、排序和分组为了让发票列表更加方便用户，我们按字母顺序对其排序，而不是仅仅显示数据模型中的顺序。此外，我们还引入了组，并添加了发货公司，以便更容易使用数据。 （1）修改Items设置排序字段名webapp&#x2F;view&#x2F;InvoiceList.view.xml 123456789101112131415161718192021222324252627&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List id=&quot;invoiceList&quot; headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; // 新增内容 items=&quot;&#123; path: &#x27;invoice&gt;/Invoices&#x27;, sorter: &#123; path: &#x27;ProductName&#x27;, descending: true // 设置倒叙排序 &#125; // 新增内容 &#125;&quot; &gt; &lt;headerToolbar&gt; ... &lt;/headerToolbar&gt; &lt;items&gt; ... &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 我们在绑定语法中添加了一个声明性排序器。将简单的绑定语法转换为对象表示法，指定数据的路径，现在添加一个额外的sorter属性。指定了发票项目排序的数据路径（字段名），其余的都是自动完成的。默认情况下，排序是升序的，当需要倒序排序时可以参考上面的例子设置“descending”属性值为true。 此时刷新执行程序可以发现列表中的数据时倒叙排序的。 （2）设置分组 webapp&#x2F;view&#x2F;InvoiceList.view.xml 123456789101112131415161718192021222324252627&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List id=&quot;invoiceList&quot; headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; // 新增内容 items=&quot;&#123; path: &#x27;invoice&gt;/Invoices&#x27;, sorter: &#123; path: &#x27;ShipperName&#x27;, group: true &#125; &#125;&quot; // 新增内容 &gt; &lt;headerToolbar&gt; ... &lt;/headerToolbar&gt; &lt;items&gt; ... &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 和设置排序类似，同样使用到了sorter属性，只不过该属性内部的属性由原来的倒序属性变成了组（group），并且对应的路径（字段）也变成了ShipperName。可以通过设置groupHeaderFactory属性来定义一个自定义的组件工厂。 十三、远程OData服务到目前为止，我们已经使用了本地JSON数据，但现在我们将访问一个真正的OData服务来可视化远程数据。 在现实世界中，数据通常驻留在远程服务器上，并通过OData服务进行访问。我们将向清单中添加一个数据源配置，并用公开的Northwind OData服务替换发票模型的JSONModel类型，以可视化远程数据。你会惊讶地发现，为了让这一切顺利进行，几乎不需要做什么改变！ webapp&#x2F;manifest.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;_version&quot;: &quot;1.7.0&quot;, &quot;sap.app&quot;: &#123; &quot;id&quot;: &quot;TestCaseTwo&quot;, &quot;type&quot;: &quot;application&quot;, &quot;i18n&quot;: &quot;i18n/i18n.properties&quot;, &quot;applicationVersion&quot;: &#123; &quot;version&quot;: &quot;1.0.0&quot; &#125;, ... &#125;, // 新增内容 &quot;dataSources&quot;: &#123; &quot;invoiceRemote&quot;: &#123; &quot;uri&quot;: &quot;Northwind/V2/Northwind/Northwind.svc/&quot;, &quot;type&quot;: &quot;OData&quot;, &quot;settings&quot;: &#123; &quot;odataVersion&quot;: &quot;2.0&quot; &#125; &#125; &#125; // 新增内容 &#125;, &quot;sap.ui&quot;: &#123; ... &#125;, &quot;sap.ui5&quot;: &#123; ... &quot;models&quot;: &#123; &quot;i18n&quot;: &#123; &quot;type&quot;: &quot;sap.ui.model.resource.ResourceModel&quot;, &quot;settings&quot;: &#123; &quot;bundleName&quot;: &quot;TestCaseTwo.i18n.i18n&quot; &#125; &#125;, &quot;invoice&quot;:&#123; &quot;dataSource&quot;: &quot;invoiceRemote&quot; // 新增内容 &#125; &#125;, ... &#125;&#125; 通过该方式配置时因为CORS策略的原因无法访问由SAP官方提供的资源连接。详细内容可以参考样例26下面的CORS策略解决方式。 在描述符文件的sap.app部分，我们添加了一个数据源配置。使用invoiceRemote键，我们指定一个允许自动模型实例化的配置对象。我们指定服务的类型（OData）和模型版本（2.0）。在这一步中，我们希望使用位于https://services.odata.org/V2/Northwind/Northwind.svc/.因此，URI指向官方的Northwind OData服务。 为了避免下文所述的跨源资源共享问题，典型的程序是只维护一条路径，例如&#x2F;V2&#x2F;Northwind&#x2F;Northwind。svc&#x2F;，位于数据源的URI属性中。然而，如果实际的OData服务器位于不同的地址，这也使得使用代理成为必要。 在模型部分，我们替换发票模型的内容。当模型在组件初始化期间自动实例化时，此键仍用作模型名称。然而，dataSource键的invoiceRemote值是对我们在上面指定的数据源部分的引用。此配置允许组件在应用程序启动期间检索此型号的技术信息。 我们的组件现在自动创建一个sap.ui.model.odata.v2.ODataModel根据我们上面指定的设置，并将其作为名为invoice的模型提供。使用invoiceRemote数据源时，ODataModel会从真正的Northwind OData服务获取数据。我们从Northwind OData服务收到的发票与我们之前使用的JSON数据具有相同的属性（除了status属性，它在Northwind OData服务中不可用）。 CORS策略解决方式： SAP Web IDE：如下所述配置目标（推荐） 本地开发：配置本地代理 解决方法：在本地测试中禁用浏览器中的同源策略（不推荐，仅适用于测试） 在远程系统上设置CORS相关响应头（如果可能）https://www.jianshu.com/p/72c8c7863418 详细内容参考样例26中的CORS策略。 十四、模拟服务器配置我们只是针对一个真正的服务运行我们的应用程序，但是为了开发和测试我们的应用程序，我们不想依赖“真正”服务的可用性，也不想给数据服务所在的系统增加额外的负载。 这个系统就是所谓的后端系统，我们现在将使用名为mock server的SAPUI5特性来模拟它。它为本地文件提供服务，但它模拟后端系统比只加载本地数据更现实。我们还将更改模型实例化部分，以便在描述符中配置模型，并由SAPUI5自动实例化。这样，我们就不需要在代码中处理模型实例化。 1.环境配置注意事项： 想要使用本地代理的服务器需要配置相对应的配置文件，且配置完成之后或许仍然存在问题。先将配置方法记录如下。 （1）打开Webide安装目录 （2）在当前路径后追加如下的路径\\config_master\\service.destinations\\destinations 追加回车后会进入destinations文件夹，里面应该是空的。 （3）创建配置文件在上面进入到路径中创建一个名字为：Northwind的没有后缀名的文件。 （4）编写文件内容使用记事本打开文件在其中键入如下内容： 12345678910Description=NorthwindType=HTTPAuthentication=NoAuthenticationWebIDEUsage=odata_genName=northwindWebIDEEnabled=trueCloudConnectorVersion=2URL=https\\://services.odata.orgProxyType=InternetWebIDESystem=Northwind 保存后重启Webide。 （5）对项目配置环境 能进入下面的页面并下拉出Northwind选项就说明模拟服务器的环境配置好了，接下来就只需要将对应的模拟服务器数据模型导入到项目即可。 接下来对第三步的URL进行说明： 我们需要访问如下这个资源网址：https://services.odata.org/V2/Northwind/Northwind.svc/ 然后我们打开刚刚配置的Northwind文件，可以看见其中的URL已被设置为：https:&#x2F;&#x2F;services.odata.org。所以在填写URL时只填写V2&#x2F;Northwind&#x2F;Northwind.svc&#x2F;这一部分。 （6）覆盖现有OData服务连接在上一步中点击玩Next按钮后进入该页面，勾选Overwrite existing OData service connection选项。 然后点击完成按钮。 （7）配置数据模型继续在manifest.json文件中选择Models页签点击加号按钮 在新弹出的框中左下角的选择框代表使用模型默认的名称，如果勾选了该项则在最上面的模型名称内容就可以不选了。在第二项模型来源中则可以从下拉框中查看到刚刚从资源网站中获取到的模型。 选择完成点击OK按钮后，可以发现在Models页签中多了一项Default数据模型。 如此这样就配置好了模拟服务器的环境和项目所需要的数据模型。接下来配置项目中在模拟服务器中运行的文件。 2.模拟服务器文件（1）创建模拟服务器的入口文件webapp&#x2F;test&#x2F;mockServer.html (New) 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;SAPUI5 Walkthrough - Test Page&lt;/title&gt; &lt;script id=&quot;sap-ui-bootstrap&quot; src=&quot;https://ui5.sap.com/resources/sap-ui-core.js&quot; data-sap-ui-theme=&quot;sap_belize&quot; data-sap-ui-libs=&quot;sap.m&quot; data-sap-ui-resourceroots=&#x27;&#123; &quot;TestCaseTwo&quot;: &quot;../&quot; &#125;&#x27; data-sap-ui-oninit=&quot;module:TestCaseTwo/test/initMockServer&quot; data-sap-ui-compatVersion=&quot;edge&quot; data-sap-ui-async=&quot;true&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;sapUiBody&quot; id=&quot;content&quot;&gt; &lt;div data-sap-ui-component data-name=&quot;TestCaseTwo&quot; data-id=&quot;container&quot; data-settings=&#x27;&#123;&quot;id&quot; : &quot;TestCaseTwo&quot;&#125;&#x27;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 现在存在两个不同的入口页面：一个用于真正的“连接”应用程序（index.html），另一个用于本地测试（mockServer.html）。你可以自由决定下一步是对应用程序中的实际服务数据还是本地数据执行。 我们修改mockServer.html文件，并更改页面标题以将其与生产性起始页区分开来。在引导过程中，数据sap ui resourceroots属性也发生了更改。名称空间现在指向上方的文件夹（“..&#x2F;”），因为mockServer.html文件现在位于webapp文件夹的子文件夹中。我们现在调用脚本initMockServer.js，而不是直接加载应用程序组件。 （2）创建组件初始化生命周期文件webapp&#x2F;test&#x2F;initMockServer.js (New) 1234567891011sap.ui.define([ &quot;../localService/mockserver&quot;], function (mockserver) &#123; &quot;use strict&quot;; // initialize the mock server mockserver.init(); // initialize the embedded component on the HTML page sap.ui.require([&quot;sap/ui/core/ComponentSupport&quot;]);&#125;); 我们将要实现的mockserver依赖性是我们的本地测试服务器。在加载组件之前，会立即调用它的init方法。通过这种方式，我们可以捕获所有将进入“真实”服务的请求，并在使用mockServer.html启动应用程序时，通过测试服务器在本地处理它们文件。组件本身并不“知道”它现在将在测试模式下运行。 （3）创建本地数据模型Json123456789101112131415161718192021222324252627282930313233343536373839404142[ &#123; &quot;ProductName&quot;: &quot;Pineapple&quot;, &quot;Quantity&quot;: 21, &quot;ExtendedPrice&quot;: 87.2000, &quot;ShipperName&quot;: &quot;Fun Inc.&quot;, &quot;ShippedDate&quot;: &quot;2015-04-01T00:00:00&quot;, &quot;Status&quot;: &quot;A&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Milk&quot;, &quot;Quantity&quot;: 4, &quot;ExtendedPrice&quot;: 9.99999, &quot;ShipperName&quot;: &quot;ACME&quot;, &quot;ShippedDate&quot;: &quot;2015-02-18T00:00:00&quot;, &quot;Status&quot;: &quot;B&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Canned Beans&quot;, &quot;Quantity&quot;: 3, &quot;ExtendedPrice&quot;: 6.85000, &quot;ShipperName&quot;: &quot;ACME&quot;, &quot;ShippedDate&quot;: &quot;2015-03-02T00:00:00&quot;, &quot;Status&quot;: &quot;B&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Salad&quot;, &quot;Quantity&quot;: 2, &quot;ExtendedPrice&quot;: 8.8000, &quot;ShipperName&quot;: &quot;ACME&quot;, &quot;ShippedDate&quot;: &quot;2015-04-12T00:00:00&quot;, &quot;Status&quot;: &quot;C&quot; &#125;, &#123; &quot;ProductName&quot;: &quot;Bread&quot;, &quot;Quantity&quot;: 1, &quot;ExtendedPrice&quot;: 2.71212, &quot;ShipperName&quot;: &quot;Fun Inc.&quot;, &quot;ShippedDate&quot;: &quot;2015-01-27T00:00:00&quot;, &quot;Status&quot;: &quot;A&quot; &#125;] 模拟服务器访问的数据模型文件。 （4）创建元素据服务接口文件webapp&#x2F;localService&#x2F;metadata.xml (New) 12345678910111213141516171819202122232425262728&lt;edmx:Edmx Version=&quot;1.0&quot; xmlns:edmx=&quot;http://schemas.microsoft.com/ado/2007/06/edmx&quot;&gt; &lt;edmx:DataServices m:DataServiceVersion=&quot;1.0&quot; m:MaxDataServiceVersion=&quot;3.0&quot; xmlns:m=&quot;http://schemas.microsoft.com/ado/2007/08/dataservices/metadata&quot;&gt; &lt;Schema Namespace=&quot;NorthwindModel&quot; xmlns=&quot;http://schemas.microsoft.com/ado/2008/09/edm&quot;&gt; &lt;EntityType Name=&quot;Invoice&quot;&gt; &lt;Key&gt; &lt;PropertyRef Name=&quot;ProductName&quot;/&gt; &lt;PropertyRef Name=&quot;Quantity&quot;/&gt; &lt;PropertyRef Name=&quot;ShipperName&quot;/&gt; &lt;/Key&gt; &lt;Property Name=&quot;ShipperName&quot; Type=&quot;Edm.String&quot; Nullable=&quot;false&quot; MaxLength=&quot;40&quot; FixedLength=&quot;false&quot; Unicode=&quot;true&quot;/&gt; &lt;Property Name=&quot;ProductName&quot; Type=&quot;Edm.String&quot; Nullable=&quot;false&quot; MaxLength=&quot;40&quot; FixedLength=&quot;false&quot; Unicode=&quot;true&quot;/&gt; &lt;Property Name=&quot;Quantity&quot; Type=&quot;Edm.Int16&quot; Nullable=&quot;false&quot;/&gt; &lt;Property Name=&quot;ExtendedPrice&quot; Type=&quot;Edm.Decimal&quot; Precision=&quot;19&quot; Scale=&quot;4&quot;/&gt; &lt;Property Name=&quot;Status&quot; Type=&quot;Edm.String&quot; Nullable=&quot;false&quot; MaxLength=&quot;1&quot; FixedLength=&quot;false&quot; Unicode=&quot;true&quot;/&gt; &lt;/EntityType&gt; &lt;/Schema&gt; &lt;Schema Namespace=&quot;ODataWebV2.Northwind.Model&quot; xmlns=&quot;http://schemas.microsoft.com/ado/2008/09/edm&quot;&gt; &lt;EntityContainer Name=&quot;NorthwindEntities&quot; m:IsDefaultEntityContainer=&quot;true&quot; p6:LazyLoadingEnabled=&quot;true&quot; xmlns:p6=&quot;http://schemas.microsoft.com/ado/2009/02/edm/annotation&quot;&gt; &lt;EntitySet Name=&quot;Invoices&quot; EntityType=&quot;NorthwindModel.Invoice&quot;/&gt; &lt;/EntityContainer&gt; &lt;/Schema&gt; &lt;/edmx:DataServices&gt;&lt;/edmx:Edmx&gt; 元数据文件包含有关服务接口的信息，不需要手动编写。通过调用服务URL并在末尾添加$metadata（例如，在我们的例子中），可以直接从“real”服务访问它http://services.odata.org/V2/Northwind/Northwind.svc/$metadata）。模拟服务器将读取此文件以模拟真实的OData服务，并将以正确的格式返回本地源文件的结果，以便应用程序使用（XML或JSON格式）。 为了简单起见，我们从原始Northwind OData元数据文档中删除了场景中不需要的所有内容。我们还将状态字段添加到元数据中，因为它在真正的Northwind服务中不可用。 （5）效果图展示 十五、用QUnit进行单元测试现在我们在应用程序中有了一个测试文件夹，我们可以开始增加测试覆盖率了。 在test文件假下新建一个unit文件夹，再在unit文件夹下新建一个model文件夹。 1.步骤（1）设置测试用JS文件webapp&#x2F;test&#x2F;unit&#x2F;model&#x2F;formatter.js(New) 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*global QUnit*/sap.ui.define([ &quot;sap/ui/demo/TestCaseTwo/controller/formatter&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;],function (formatter,ResourceModel) &#123; &quot;use strict&quot;; QUnit.module(&quot;Formatting functions&quot;,&#123; beforeEach: function () &#123; this._oResourceModel = new ResourceModel(&#123; bundleUrl: sap.ui.require.toUrl(&quot;sap/ui/demo/TestCaseTwo&quot;) + &quot;/i18n/i18n.properties&quot; &#125;); &#125;, afterEach: function () &#123; this._oResourceModel.destroy(); &#125; &#125;); QUnit.test(&quot;Should return the translated texts&quot;,function (assert) &#123; // Arrange // this.stub() does not support chaining and always returns the right data // even if a wrong or empty parameter is passed. var oModel = this.stub(); oModel.withArgs(&quot;i18n&quot;).returns(this._oResourceModel); var oViewStub = &#123; getModel: oModel &#125;; var oControllerStub = &#123; getView: this.stub().returns(oViewStub) &#125;; // System under test var fnIsolatedFormatter = formatter.statusText.bind(oControllerStub); // Assert assert.strictEqual(fnIsolatedFormatter(&quot;A&quot;), &quot;New&quot;, &quot;The long text for status A is correct&quot;); assert.strictEqual(fnIsolatedFormatter(&quot;B&quot;), &quot;In Progress&quot;, &quot;The long text for status B is correct&quot;); assert.strictEqual(fnIsolatedFormatter(&quot;C&quot;), &quot;Done&quot;, &quot;The long text for status C is correct&quot;); assert.strictEqual(fnIsolatedFormatter(&quot;Foo&quot;), &quot;Foo&quot;, &quot;The long text for status Foo is correct&quot;); &#125;);&#125;); 我们在webapp&#x2F;test&#x2F;unit&#x2F;model下创建了一个新的formatter.js文件，其中实现了自定义格式化程序的单元测试。我们要测试的格式化程序文件作为依赖项加载。我们还需要对ResourceModel的依赖，因为我们想检查翻译的文本是否正确。 格式化程序文件只包含一个用于格式化程序功能的QUnit模块。它用beforeach函数中的本地化文本实例化我们的ResourceBundle，并在afterEach函数中再次销毁它。在执行每个测试之前和之后都会调用这些函数。 接下来是格式化程序函数的单元测试。在我们在设置自定义格式化步骤中创建的statusText函数的实现中，我们通过以下排队调用访问ResourceBundle：var resourceBundle &#x3D; this.getView().getModel(“i18n”).getResourceBundle(); 由于我们不想测试控制器、视图或模型功能，我们首先在SinonJS及其存根方法的帮助下，通过用空外壳替换这些调用来删除依赖项。这发生在单元测试的排列部分。SinonJS为所有对象注入一个存根方法，因此我们可以简单地调用它。stub（）为我们需要模拟的任何行为创建一个新的stub。 然后通过调用JavaScript的bind函数将stub绑定到statusText格式化程序。当使用变量fnIsolatedFormatter调用函数时，this指针现在绑定到我们的控制器stub，并且我们仍然可以随心所欲地传入参数。这发生在测试的“测试中的系统”部分。 最后，我们执行我们的assertions。我们通过使用数据模型中预期的值（A、B、C和其他所有内容）调用独立的格式化程序函数来检查格式化程序逻辑的每个分支。我们严格比较格式化程序函数的结果和我们期望从资源包中得到的硬编码字符串，如果测试失败，我们会给出一条有意义的错误消息。我们在这里硬编码字符串，以确定资源包属性的问题。如果缺少一个属性，那么如果我们对照资源包中的实际值（两边都是空字符串）进行检查，测试仍然会成功。 （2）创建单元测试运行文件并加载单元测试的基本功能webapp&#x2F;test&#x2F;unit&#x2F;unitTests.qunit.html (New) 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Unit tests for SAPUI5 Walkthrough&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script id = &quot;sap-ui-bootstrap&quot; src = &quot;https://openui5.hana.ondemand.com/resources/sap-ui-core.js&quot; data-sap-ui-resourceroots = &#x27;&#123; &quot;sap.ui.demo.TestCaseTwo&quot;: &quot;../../&quot; &#125;&#x27; data-sap-ui-async = &quot;true&quot;&gt; &lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://openui5.hana.ondemand.com/resources/sap/ui/thirdparty/qunit-2.css&quot;&gt; &lt;script src=&quot;https://openui5.hana.ondemand.com/resources/sap/ui/thirdparty/qunit-2.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://openui5.hana.ondemand.com/resources/sap/ui/qunit/qunit-junit.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://openui5.hana.ondemand.com/resources/sap/ui/qunit/qunit-coverage.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://openui5.hana.ondemand.com/resources/sap/ui/thirdparty/sinon.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://openui5.hana.ondemand.com/resources/sap/ui/thirdparty/sinon-qunit.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;unitTests.qunit.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt; &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 所谓的QUnit测试套件是一个HTML页面，用于触发应用程序的所有QUnit测试。大部分内容是生成结果页面的布局，您可以在预览中看到，我们不会进一步解释这些部分，而是将重点放在应用程序部分。 让我们从名称空间开始。由于我们现在在webapp&#x2F;test&#x2F;unit文件夹中，我们实际上需要升级两个级别才能再次获得src文件夹。这个名称空间可以在测试中用于加载和触发应用程序功能。 首先，我们通过脚本标签加载一些基本的QUnit功能。这里还可以添加其他QUnit测试。然后HTML页面加载另一个名为unitTests的脚本。昆特。js，我们将在下一步创建它。这个脚本将执行我们的格式化程序。 （3）创建单元测试入口程序加载的js文件webapp&#x2F;test&#x2F;unit&#x2F;unitTests.qunit.js (New) 123456789101112/* global QUnit */QUnit.config.autostart = false;sap.ui.getCore().attachInit(function () &#123; &quot;use strict&quot;; sap.ui.require([ &quot;sap/ui/demo/TestCaseTwo/test/unit/model/formatter&quot; ], function () &#123; QUnit.start(); &#125;);&#125;); 这个脚本加载并执行我们的格式化程序。如果我们现在打开webapp&#x2F;test&#x2F;unit&#x2F;unitTests.qunit.html中，我们应该看到我们的测试正在运行并验证格式化程序逻辑。 （4）效果图展示 2.注意事项 所有单元测试都放在应用程序的webapp&#x2F;test&#x2F;unit文件夹中。 测试套件中的文件以*.qunit.html. unitTests.qunit.html文件触发应用程序的所有单元测试。 应该为格式化程序、控制器逻辑和其他单个功能编写单元测试。 所有依赖项都被stubs替换，以便只测试范围内的功能。 十六、路由和导航到目前为止，我们已将所有应用程序内容放在一个页面上。随着我们添加越来越多的功能，我们希望分割内容并将其放在单独的页面上。 在这一步中，我们将使用SAPUI5导航功能加载并显示一个单独的详细信息页面，稍后可以使用该页面显示发票的详细信息。在前面的步骤中，我们直接在应用程序视图中定义了页面，以便在加载应用程序时显示页面。我们现在将使用SAPUI5路由器类来加载页面并自动更新URL。我们为应用程序指定路由配置，并为应用程序的每个页面创建单独的视图，然后通过触发导航事件连接视图。 1.路由设置（1）配置路由webapp&#x2F;manifest.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;_version&quot;: &quot;1.12.0&quot;, … &quot;sap.ui5&quot;: &#123; … &quot;models&quot;: &#123; … &#125;, &quot;routing&quot;: &#123; &quot;config&quot;: &#123; &quot;routerClass&quot;: &quot;sap.m.routing.Router&quot;, &quot;viewType&quot;: &quot;XML&quot;, &quot;viewPath&quot;: &quot;TestCaseTwo.view&quot;, &quot;controlId&quot;: &quot;app&quot;, &quot;controlAggregation&quot;: &quot;pages&quot;, &quot;async&quot;: true &#125;, &quot;routes&quot;: [ &#123; &quot;pattern&quot;: &quot;&quot;, &quot;name&quot;: &quot;overview&quot;, &quot;target&quot;: &quot;overview&quot; &#125;, &#123; &quot;pattern&quot;: &quot;detail&quot;, &quot;name&quot;: &quot;detail&quot;, &quot;target&quot;: &quot;detail&quot; &#125; ], &quot;targets&quot;: &#123; &quot;overview&quot;: &#123; &quot;viewId&quot;: &quot;overview&quot;, &quot;viewName&quot;: &quot;Overview&quot;, &quot;viewPath&quot;: &quot;TestCaseTwo.view&quot; &#125;, &quot;detail&quot;: &#123; &quot;viewId&quot;: &quot;detail&quot;, &quot;viewName&quot;: &quot;Detail&quot;, &quot;viewPath&quot;: &quot;TestCaseTwo.view&quot; &#125; &#125; &#125; &#125;&#125; 我们在描述符的sap.ui5部分添加了一个新的“路由”部分。有三个子部分定义了应用程序的路由和导航结构： config 本节包含适用于所有路由和目标的全局路由器配置和默认值。我们定义要使用的路由器类，以及视图在应用程序中的位置。为了自动加载和显示视图，我们还指定了用于显示页面的控件，以及显示新页面时应填充的聚合。 routes 每条路线都定义了一个名称、一种模式以及一个或多个目标，以便在路线被选中时导航到这些目标。模式基本上是与路由匹配的URL部分，我们为应用程序定义了两条路由。第一个是默认路由，它将显示包含前面步骤内容的概览页面，第二个是包含URL模式细节的详细路由，它将显示新页面。 targets 目标定义了显示的视图，它与一条或多条路线关联，也可以从应用程序中手动显示。无论何时显示目标，相应的视图都会加载并显示在应用程序中。在我们的应用程序中，我们只需使用与目标名称对应的视图名称定义两个目标。 （2）初始化激 活路由webapp&#x2F;Component.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061sap.ui.define([ &quot;sap/ui/core/UIComponent&quot;, &quot;sap/ui/Device&quot;, &quot;TestCaseTwo/model/models&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;, &quot;./controller/HelloDialog&quot;], function(UIComponent, Device, models,JSONModel,ResourceModel,HelloDialog) &#123; &quot;use strict&quot;; return UIComponent.extend(&quot;TestCaseTwo.Component&quot;, &#123; metadata: &#123; manifest: &quot;json&quot; &#125;, /** * The component is initialized by UI5 automatically during the startup of the app and calls the init method once. * @public * @override */ init: function() &#123; // call the base component&#x27;s init function UIComponent.prototype.init.apply(this, arguments); // set the device model this.setModel(models.createDeviceModel(), &quot;device&quot;); var oData = &#123; recipient : &#123; name : &quot;World&quot;, text : &quot;ok&quot; &#125; &#125;; var oModel = new JSONModel(oData); this.setModel(oModel); // set i18n model on view var i18nModel = new ResourceModel(&#123; bundleName:&quot;TestCaseTwo.i18n.i18n&quot; &#125;); this.setModel(i18nModel,&quot;i18n&quot;); // set dialog this._helloDialog = new HelloDialog(this.getRootControl()); // 新增内容 // create the views based on the url/hash this.getRouter().initialize(); // 新增内容 &#125;, exit : function()&#123; this._helloDialog.destroy(); delete this._helloDialog; &#125;, openHelloDialog : function()&#123; this._helloDialog.open(); &#125; &#125;);&#125;); 在组件初始化方法中，我们现在添加一个调用来初始化路由器。我们不需要手动实例化路由器，它会根据AppDescriptor配置自动实例化并分配给组件。 初始化路由器将评估当前URL并自动加载相应的视图。这是在AppDescriptor中配置的路由和目标的帮助下完成的。如果路线被选中，则加载并显示其相应目标的视图。 （3）路由入口视图webapp&#x2F;view&#x2F;Overview.view.xml (New) 12345678910111213141516&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.View1&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;Page title=&quot;&#123;i18n&gt;homePageTitle&#125;&quot;&gt; &lt;headerContent&gt; &lt;Button icon=&quot;sap-icon://hello-world&quot; press=&quot;.onOpenDialog&quot;/&gt; &lt;/headerContent&gt; &lt;content&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.HelloPanel&quot;/&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.InvoiceList&quot;/&gt; &lt;/content&gt; &lt;/Page&gt;&lt;/mvc:View&gt; 我们将前面步骤的内容从应用程序视图移动到新的概览视图。为简单起见，我们不更改控制器，因为它只包含打开对话框的助手方法，这意味着我们重用了控制器sap.ui.demo.walkthrough.controller.App用于两种不同视图的应用程序（用于新概述和应用程序视图）。然而，该控制器的两个实例在运行时被实例化。通常，每个引用控制器的视图都会实例化一个控制器实例。 （4）修改主视图webapp&#x2F;view&#x2F;View1.view.xml 123456789&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.View1&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Shell&gt; &lt;App class=&quot;myAppDemoWT&quot; id=&quot;app&quot;/&gt; &lt;/Shell&gt;&lt;/mvc:View&gt; 我们的应用程序视图现在只包含空的应用程序标签。路由器将自动将与当前URL对应的视图添加到应用程序控件中。路由器使用与AppDescriptor中的属性controlId:“app”对应的ID标识应用程序控件。 （5）路由跳转视图webapp&#x2F;view&#x2F;Detail.view.xml (New) 123456789&lt;mvc:View xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;Page title=&quot;&#123;i18n&gt;detailPageTitle&#125;&quot;&gt; &lt;ObjectHeader title=&quot;Invoice&quot;/&gt; &lt;/Page&gt;&lt;/mvc:View&gt; 现在，我们为详图视图添加第二个视图。它目前只包含一个页面和一个ObjectHeader控件，用于显示静态文本发票。 （6）设置I8n中的视图标题webapp&#x2F;i18n&#x2F;i18n.properties 1234...# Detail PagedetailPageTitle=Walkthrough - Details （7）设置列表点击切换视图事件webapp&#x2F;view&#x2F;InvoiceList.view.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;List id=&quot;invoiceList&quot; headerText=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123; path: &#x27;invoice&gt;/Invoices&#x27;, sorter: &#123; path: &#x27;ShipperName&#x27;, group: true &#125; &#125;&quot; &gt; &lt;headerToolbar&gt; &lt;Toolbar&gt; &lt;Title text=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot;/&gt; &lt;ToolbarSpacer/&gt; &lt;SearchField width=&quot;50%&quot; search=&quot;.onFilterInvoices&quot;/&gt; &lt;/Toolbar&gt; &lt;/headerToolbar&gt; &lt;items&gt; &lt;ObjectListItem title=&quot;&#123;invoice&gt;Quantity&#125; x &#123;invoice&gt;ProductName&#125;&quot; number=&quot;&#123; parts:[&#123;path: &#x27;invoice&gt;ExTendedPrice&#x27;&#125;,&#123;path: &#x27;view&gt;/currency&#x27;&#125;], type: &#x27;sap.ui.model.type.Currency&#x27;, formatOpentions: &#123; showMeasure: false &#125; &#125;&quot; numberUnit=&quot;&#123;view&gt;/currency&#125;&quot; numberState=&quot;&#123;= $&#123;invoice&gt;ExtendedPrice&#125; &gt; 50 ? &#x27;Error&#x27; : &#x27;Success&#x27; &#125;&quot; &lt;!--新增内容--&gt; type=&quot;Navigation&quot; press=&quot;onPress&quot;&gt; &lt;!--新增内容--&gt; &lt;firstStatus&gt; &lt;ObjectStatus text=&quot;&#123; path: &#x27;invoice&gt;Status&#x27;, formatter: &#x27;.formatter.statusText&#x27; &#125;&quot;/&gt; &lt;/firstStatus&gt; &lt;/ObjectListItem&gt; &lt;/items&gt; &lt;/List&gt;&lt;/mvc:View&gt; 在“发票列表”视图中，我们向列表项添加一个按下事件，并将项类型设置为“导航”，以便可以实际单击该项。 （8）设置列表路由跳转逻辑webapp&#x2F;controller&#x2F;InvoiceList.controller.js 1234567891011121314151617181920sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;./formatter&quot;, &quot;sap/ui/model/Filter&quot;, &quot;sap/ui/model/FilterOperator&quot;], function (Controller, JSONModel, formatter, Filter, FilterOperator) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.InvoiceList&quot;,&#123; ... // 新增内容 onPress: function (oEvent) &#123; var oRouter = this.getOwnerComponent().getRouter(); oRouter.navTo(&quot;detail&quot;); &#125; // 新增内容 &#125;); &#125;); 我们将事件处理函数添加到发票列表的控制器中。现在是时候通过单击发票列表中的项目导航到详细信息页面了。我们通过调用助手方法getOwnerComponent（）来访问应用程序的路由器实例。getRouter（）。在路由器上，我们调用navTo方法来导航到我们在路由配置中指定的详细路由。 现在，当您单击发票列表中的一个项目时，您应该会看到详细信息页面。 （9）效果图展示 2.带参数的路由我们现在可以在概览和详细信息页面之间导航，但我们在概览中选择的实际项目尚未显示在详细信息页面上。我们的应用程序的一个典型用例是在详细信息页面上显示所选项目的附加信息。 （1）设置路由传递的参数webapp&#x2F;manifest.json 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;_version&quot;: &quot;1.7.0&quot;, ... &quot;sap.ui5&quot;: &#123; ... &quot;resources&quot;: &#123; ... &#125;, &quot;routing&quot;: &#123; &quot;config&quot;: &#123; &quot;routerClass&quot;: &quot;sap.m.routing.Router&quot;, &quot;viewType&quot;: &quot;XML&quot;, &quot;viewPath&quot;: &quot;TestCaseTwo.view&quot;, &quot;controlId&quot;: &quot;app&quot;, &quot;controlAggregation&quot;: &quot;pages&quot;, &quot;async&quot;: true &#125;, &quot;routes&quot;: [&#123; &quot;pattern&quot;: &quot;&quot;, &quot;name&quot;: &quot;overview&quot;, &quot;target&quot;: &quot;overview&quot; &#125;, &#123; &quot;pattern&quot;: &quot;detail/&#123;invoicePath&#125;&quot;, // 新增内容 &quot;name&quot;: &quot;detail&quot;, &quot;target&quot;: &quot;detail&quot; &#125;], &quot;targets&quot;: &#123; &quot;overview&quot;: &#123; &quot;viewId&quot;: &quot;overview&quot;, &quot;viewName&quot;: &quot;Overview&quot;, &quot;viewPath&quot;: &quot;TestCaseTwo.view&quot; &#125;, &quot;detail&quot;: &#123; &quot;viewId&quot;: &quot;detail&quot;, &quot;viewName&quot;: &quot;Detail&quot;, &quot;viewPath&quot;: &quot;TestCaseTwo.view&quot; &#125; &#125; &#125; &#125;&#125; 现在，我们将导航参数invoicePath添加到详细信息路由，以便将所选项目的信息移交给详细信息页面。导航参数必须用花括号定义。 （2）配置视图显示的数据内容webapp&#x2F;view&#x2F;Detail.view.xml 12345678910111213&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.Detail&quot; // 新增内容 xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;Page title=&quot;&#123;i18n&gt;detailPageTitle&#125;&quot;&gt; &lt;ObjectHeader // 新增内容 intro=&quot;&#123;invoice&gt;ShipperName&#125;&quot; title=&quot;&#123;invoice&gt;ProductName&#125;&quot;/&gt; // 新增内容 &lt;/Page&gt;&lt;/mvc:View&gt; 将路由传递过来的数据模型内容展示在页面上。我们添加了一个控制器，负责在视图上设置项目的上下文，并将ObjectHeader的一些属性绑定到发票模型的字段。 （3）配置传递的路由参数webapp&#x2F;controller&#x2F;InvoiceList.controller.js 123456789101112131415161718192021222324252627282930313233343536sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;./formatter&quot;, &quot;sap/ui/model/Filter&quot;, &quot;sap/ui/model/FilterOperator&quot;], function (Controller, JSONModel, formatter, Filter, FilterOperator) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.InvoiceList&quot;,&#123; formatter: formatter, onInit : function()&#123; ... &#125;, onFilterInvoices : function(oEvent) &#123; ... &#125;, onPress: function (oEvent) &#123; // 获取列表的Item对象 var oItem = oEvent.getSource();//谁触发了这个方法就是指谁 // 获取路由对象 var oRouter = this.getOwnerComponent().getRouter(); // 获取数据模型对象，上下文对象 var oModel = oItem.getBindingContext(&quot;invoice&quot;); // 获取鼠标点击选中的数据模型路径 var oPath = oModel.getPath(); // 去除掉通过路径获取到的数据模型格式，主要是去掉路劲获取到数据前的‘/’字符 var oObject = oPath.substr(1); oRouter.navTo(&quot;detail&quot;,&#123; // 将选中数据模型的路径传递过去 invoicePath: window.encodeURIComponent(oObject) &#125;); &#125; &#125;); &#125;); oModel对象中的获取上下文对象的方法虽然此处使用的是列表，但是一般表格和列表一类用来判断被点击选中的数据时都是使用该方法获取上下文对象然后通过getPath()方法获取到被选中数据的索引。substr(1)方法是字符串处理方法，去除掉字符串的第一个字符（因为传递的参数是1，当传递的参数是2或3则会取出开头的前2个或3个字符）。 与之交互的控件实例可以通过适用于所有SAPUI5事件的getSource方法访问。它将返回在本例中已单击的ObjectListItem。我们将使用它将单击的项目的信息传递到详细信息页面，以便相同的项目可以显示在那里。 在navTo方法中，我们现在添加一个配置对象，用项目的当前信息填充导航参数invoicePath。这将更新URL，同时导航到详细信息视图。在详细信息页面上，我们可以再次访问此上下文信息并显示相应的项。 为了识别我们选择的对象，我们通常会在后端系统中使用该项的键，因为它简短而精确。然而，对于我们的发票项目，我们没有简单的密钥，直接使用绑定路径来保持示例简短。项的路径是绑定上下文的一部分，绑定上下文是SAPUI5的帮助对象，用于管理控件的绑定信息。可以通过在任何绑定的SAPUI5控件上使用模型名调用getBindingContext方法来访问绑定上下文。我们需要通过调用从绑定路径中删除第一个&#x2F;。字符串上的substr（1），因为这是URL中的一个特殊字符，不允许使用，所以我们将在详细信息页面上再次添加它。 （4）创建跳转页面的控制器文件webapp&#x2F;controller&#x2F;Detail.controller.js (New) 123456789101112131415161718sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot; ], function (Controller) &#123; &quot;use strict&quot;; return Controller.extend(&quot;sap.ui.demo.TestCaseTwo.controller.Detail&quot;, &#123; onInit: function () &#123; var oRouter = this.getOwnerComponent().getRouter(); oRouter.getRoute(&quot;detail&quot;).attachPatternMatched(this._onObjectMatched, this); &#125;, _onObjectMatched: function (oEvent) &#123; this.getView().bindElement(&#123; path: &quot;/&quot; + window.decodeURIComponent(oEvent.getParameter(&quot;arguments&quot;).invoicePath), model: &quot;invoice&quot; &#125;); &#125; &#125;);&#125;); 最后一块拼图是细节控制器。它需要设置我们在视图上用URL参数invoicePath传入的上下文，以便实际显示发票列表中已选择的项目，否则，视图将保持为空。 在控制器的onInit方法中，我们获取应用程序路由的实例，并通过调用通过其名称访问的路由上的attachPatternMatched方法来附加到详细路由。我们注册了一个内部回调函数_onObjectMatched，它将在点击路由时执行，方法是单击该项目，或者使用详细信息页面的URL调用应用程序。 在路由器触发的_onObjectMatched方法中，我们接收到一个事件，可以用来访问URL和导航参数。arguments参数将返回一个与路由模式中的导航参数相对应的对象。我们访问在invoice list控制器中设置的invoicePath，并调用视图上的bindElement函数来设置上下文。我们必须再次在路径前面添加根&#x2F;作为URL参数在路径上传递时删除的路径。 bindElement函数正在为SAPUI5控件创建绑定上下文，并接收模型名以及配置对象中某个项的路径。这将触发与发票模型字段连接的UI控件的更新。现在，当您单击发票列表中的项目时，您应该可以在单独的页面上看到发票详细信息。 3.路由回逆现在，我们可以导航到详细信息页面并显示发票，但我们还不能返回概览页面。我们将在详细信息页面中添加一个后退按钮，并实现一个再次显示概览页面的功能。 （1）添加回逆按钮webapp&#x2F;view&#x2F;Detail.view.xml 123456789101112131415&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.Detail&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;Page title=&quot;&#123;i18n&gt;detailPageTitle&#125;&quot; &lt;!--新增内容--&gt; showNavButton = &quot;true&quot; navButtonPress = &quot;.onNavBack&quot;&gt; &lt;!--新增内容--&gt; &lt;ObjectHeader intro=&quot;&#123;invoice&gt;ShipperName&#125;&quot; title=&quot;&#123;invoice&gt;ProductName&#125;&quot;/&gt; &lt;/Page&gt;&lt;/mvc:View&gt; 在详细信息页面上，我们通过将参数showNavButton设置为true来告诉控件显示后退按钮，并注册一个事件处理程序，当按下后退按钮时调用该事件处理程序。 （2）编写回逆按钮逻辑webapp&#x2F;controller&#x2F;Detail.controller.js 12345678910111213141516171819202122232425262728293031323334353637383940sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/core/routing/History&quot; // 新增内容], function (Controller, History) &#123; &quot;use strict&quot;; return Controller.extend(&quot;sap.ui.demo.TestCaseTwo.controller.Detail&quot;, &#123; onInit: function () &#123; var oRouter = this.getOwnerComponent().getRouter(); // 设置上下文对象 oRouter.getRoute(&quot;detail&quot;).attachPatternMatched(this._onObjectMatched, this); &#125;, _onObjectMatched: function (oEvent) &#123; var oPath = oEvent.getParameter(&quot;arguments&quot;).invoicePath; this.getView().bindElement(&#123; // 获取的是URL路径上传递过来的数据模型路径 path: &quot;/&quot; + window.decodeURIComponent(oPath), model: &quot;invoice&quot; &#125;); &#125;, // 新增内容 onNavBack: function () &#123; // 获取历史记录 var oHistory = History.getInstance(); var sPreviousHash = oHistory.getPreviousHash(); if (sPreviousHash !== undefined) &#123; // 浏览器历史记录，-1代表上一个记录 window.history.go(-1); &#125; else &#123; // 若历史记录为空则设置跳转的路由ID为overview进行跳转 var oRouter = this.getOwnerComponent().getRouter(); // 三个参数的含义 // 路由跳转的视图ID 数组 用新的历史状态替换当前的历史状态 oRouter.navTo(&quot;overview&quot;, &#123;&#125; ,true); &#125; &#125; // 新增内容 &#125;);&#125;); 我们加载一个新的依赖项，帮助我们从sap管理导航历史记录。用户界面。果心路由命名空间，并将事件处理程序的实现添加到我们的detail page控制器。 在事件处理程序中，我们访问导航历史，并尝试确定上一个哈希。与浏览器历史记录不同，只有在应用程序中的导航步骤已经完成时，我们才能得到有效的结果。然后，我们将简单地使用浏览器历史记录返回上一页。如果之前没有导航，我们可以告诉路由器直接进入我们的概览页面。第三个参数true告诉路由器用新的历史状态替换当前的历史状态，因为我们实际上是自己进行反向导航的。第二个参数是一个空数组（{}），因为我们不向这个路由传递任何额外的参数。 对于我们的用例，这个实现比浏览器的后退按钮要好一点。即使我们在应用程序之外的另一个页面上，浏览器也会简单地回到历史上的一步。在应用程序中，我们总是想回到概览页面，即使我们来自另一个链接，或者直接用书签打开了详细信息页面。你可以直接在一个新选项卡中加载详细信息页面，然后点击应用程序中的后退按钮，它仍然会返回到概览页面。 （3）效果图展示 十七、自定义控件在这一步中，我们将使用自定义控件扩展SAPUI5的功能。我们希望对细节页面上显示的产品进行评分，因此我们使用SAPUI5扩展机制创建了多个标准控件的组合，并添加了一些粘合代码，使它们能够很好地协同工作。这样，我们可以在整个应用程序中重用控件，并将所有相关功能保留在一个模块中。 （1）创建控件对象文件webapp&#x2F;control&#x2F;ProductRating.js (New) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192sap.ui.define([ &quot;sap/ui/core/Control&quot;, &quot;sap/m/RatingIndicator&quot;, &quot;sap/m/Label&quot;, &quot;sap/m/Button&quot;], function (Control, RatingIndicator, Label, Button) &#123; &quot;use strict&quot;; return Control.extend(&quot;sap.ui.demo.TestCaseTwo.control.ProductRating&quot;, &#123; // 定义组件属性 metadata: &#123; properties: &#123; value: &#123;type: &quot;float&quot;, defaultValue: 0&#125; &#125;, aggregations: &#123; _rating: &#123;type: &quot;sap.m.RatingIndicator&quot;, multiple: false, visibility: &quot;hidden&quot;&#125;, _label: &#123;type: &quot;sap.m.Label&quot;, multiple: false, visibility: &quot;hidden&quot;&#125;, _button: &#123;type: &quot;sap.m.Button&quot;, multiple: false,visibility: &quot;hidden&quot;&#125; &#125;, events: &#123; change: &#123; parameters: &#123; value: &#123;type : &quot;int&quot;&#125; &#125; &#125; &#125; &#125;, init: function () &#123; this.setAggregation(&quot;_rating&quot;, new RatingIndicator(&#123; value: this.getValue(), iconSize: &quot;2rem&quot;, visualMode: &quot;Half&quot;, liveChange: this._onRate.bind(this) &#125;)); this.setAggregation(&quot;_label&quot;,new Label(&#123; text: &quot;&#123;i18n&gt;productRatingLabelInitial&#125;&quot; &#125;).addStyleClass(&quot;sapUiSmallMargin&quot;)); this.setAggregation(&quot;_button&quot;, new Button(&#123; text: &quot;&#123;i18n&gt;productRatingButton&#125;&quot;, press: this._onSubmit.bind(this) &#125;).addStyleClass(&quot;sapUiTinyMarginTopBottom&quot;)); &#125;, setValue: function (fValue) &#123; this.setProperty(&quot;value&quot;, fValue, true); this.getAggregation(&quot;_rating&quot;).setValue(fValue); &#125;, reset: function () &#123; var oResourceBundle = this.getModel(&quot;i18n&quot;).getResourceBundle(); this.setValue(0); this.getAggregation(&quot;_label&quot;).setDesign(&quot;Standard&quot;); this.getAggregation(&quot;_rating&quot;).setEnabled(true); this.getAggregation(&quot;_label&quot;).setText(oResourceBundle.getText(&quot;productRatingLabelInitial&quot;)); this.getAggregation(&quot;_button&quot;).setEnabled(true); &#125;, _onRate: function (oEvent) &#123; var oResourceBundle = this.getModel(&quot;i18n&quot;).getResourceBundle(); var fValue = oEvent.getParameter(&quot;value&quot;); this.setProperty(&quot;value&quot;, fValue, true); this.getAggregation(&quot;_label&quot;).setText(oResourceBundle.getText(&quot;productRatingLabelIndicator&quot;, [fValue, oEvent.getSource().getMaxValue()])); this.getAggregation(&quot;_label&quot;).setDesign(&quot;Bold&quot;); &#125;, _onSubmit: function (oEvent) &#123; var oResourceBundle = this.getModel(&quot;i18n&quot;).getResourceBundle(); this.getAggregation(&quot;_rating&quot;).setEnabled(false); this.getAggregation(&quot;_label&quot;).setText(oResourceBundle.getText(&quot;productRatingLabelFinal&quot;)); this.getAggregation(&quot;_button&quot;).setEnabled(false); this.fireEvent(&quot;change&quot;, &#123; value: this.getValue() &#125;); &#125;, renderer: function (oRm, oControl) &#123; oRm.openStart(&quot;div&quot;, oControl); oRm.class(&quot;myAppDemoWTProductRating&quot;); oRm.openEnd(); oRm.renderControl(oControl.getAggregation(&quot;_rating&quot;)); oRm.renderControl(oControl.getAggregation(&quot;_label&quot;)); oRm.renderControl(oControl.getAggregation(&quot;_button&quot;)); oRm.close(&quot;div&quot;); &#125; &#125;);&#125;); 创建一个控件的JS的文件。与我们的控制器和视图一样，自定义控件从SAPUI5基对象继承公共控件功能，对于控件，这是通过扩展基类sap.ui.core.Control.来完成的。 自定义控件是可以在应用程序中轻松创建的小型重用组件。由于其性质，它们有时也被称为“notepad”或“on the fly”控件。自定义控件是一个JavaScript对象，它有两个特殊部分（元数据和渲染器）和许多实现控件功能的方法。 元数据部分定义了数据结构，从而定义了控件的API。有了这些关于控件属性、事件和聚合的元信息，SAPUI5自动创建setter和getter方法以及其他可以在应用程序中调用的方便函数。 渲染器（css）定义HTML结构，每当控件在视图中实例化时，该结构将添加到应用程序的DOM树中。它通常最初由SAPUI5的核心调用，并且每当控件的属性发生更改时调用。render函数的参数oRM是SAPUI5 render manager，可用于将字符串和控件属性写入HTML页面。 init方法是一个特殊的函数，每当实例化控件时，SAPUI5内核都会调用它。它可用于设置控件并准备显示其内容。 现在，我们用所需的自定义功能增强了新的自定义控件。在我们的例子中，我们希望创建一个交互式产品评级，因此我们定义了一个值，并使用三个内部控件，这些控件会自动显示并更新。RatingIndicator控件用于收集用户对产品的输入，标签显示更多信息，按钮将评级提交给应用程序以存储。 因此，在元数据部分，我们定义了几个在实现中使用的属性： 属性（Properties） 值（value） 我们定义了一个控件属性值，它将保存用户在评级中选择的值。该属性的Getter和setter函数将自动创建，如果愿意，我们还可以将其绑定到XML视图中的数据模型字段。 聚合（Aggregations） 如第一段所述，我们需要三个内部控制来实现我们的评级功能。因此，我们通过将visibility属性设置为hidden来创建三个“隐藏聚合”。通过这种方式，我们可以使用视图中设置的模型以及内部控件，SAPUI5将负责生命周期管理，并在不再需要控件时销毁它们。聚合也可以用来保存控件数组，但我们只希望每个聚合中有一个控件，所以我们需要通过将属性multiple设置为false来调整基数。 _rating：用于用户输入的sap.m.RatingIndicator 控件 _label：显示附加信息sap.m.Label。 _button：提交评级的sap.m.button。 事件（Events） 改变（Change） 我们指定了一个更改事件，控件在提交评级时将触发该事件。它包含作为事件参数的当前值。应用程序可以注册到此事件，并处理类似于“常规”SAPUI5控件的结果，实际上，SAPUI5控件的构建类似于自定义控件。 每当一个新的控件实例被实例化时，SAPUI5就会自动调用init函数，在该函数中，我们设置了内部控件。我们实例化这三个控件，并通过调用从sap.ui.core.Control.继承的框架方法setAggregation将它们存储在内部聚合中。我们传递上面指定的内部聚合和新控件实例的名称。并指定一些控件属性，以使自定义控件看起来更好，并将liveChange事件注册到rating，将press事件注册到button。标签和按钮的初始文本来自我们的i18n模型。 每当一个新的控件实例被实例化时，SAPUI5就会自动调用init函数，在该函数中，我们设置了内部控件。我们实例化这三个控件，并通过调用从sap继承的框架方法setAggregation将它们存储在内部聚合中。用户界面。果心控制我们传递上面指定的内部聚合和新控件实例的名称。我们指定了一些控件属性，以使自定义控件看起来更好，并将liveChange事件注册到rating，将press事件注册到button。标签和按钮的初始文本来自我们的i18n型号。 让我们暂时忽略其他internal helper函数和事件处理程序，定义渲染器。在SAPUI5呈现管理器和作为引用传递的控件实例的帮助下，我们现在可以呈现控件的HTML结构。我们将外部标记的开头呈现为&lt;div，并调用helper方法writeControlData来呈现div标记内控件的ID和其他基本属性。接下来，我们添加一个自定义CSS类，以便稍后在CSS文件中为自定义控件定义样式规则。然后，通过调用renderer实例上的WriteClass来呈现视图中添加的这个CSS类和其他CSS类。然后，我们关闭周围的div标记，并通过将内部聚合的内容传递给render managers renderControl函数来呈现三个内部控件。这将调用控件的呈现程序，并将它们的HTML添加到页面中。最后，我们关闭周围的标签。 setValue是一个重写的setter。SAPUI5将生成一个setter，在控制器中调用或在XML视图中定义时更新属性值，但我们还需要更新隐藏聚合中的内部评级控制，以正确反映状态。此外，我们还可以通过调用setProperty方法以true作为第三个参数来更新控件属性，从而跳过SAPUI5的重新排序，SAPUI5通常在控件的属性更改时触发。 现在我们为内部评级控制定义事件处理程序。每次用户更改评级时都会调用它。评级控制的当前值可以从sap.m.RatingIndicator的事件参数值中读取。使用我们调用重写设置器的值来更新控件状态，然后更新评级旁边的标签，以显示用户当前选择的值，并显示最大值。带有占位符值的字符串从自动分配给控件的i18n模型中读取。 接下来，我们有了提交评级的评级按钮的按下处理程序。我们假设对产品进行评级是一次性的，首先禁用评级和按钮，这样用户就不允许提交另一个评级。我们还更新了标签，以显示“感谢您的评分！”消息，然后我们触发控件的更改事件，并将当前值作为参数传递，以便侦听该事件的应用程序可以对评级交互做出反应。 我们定义了重置方法，以便能够将UI上控件的状态恢复到其初始状态，以便用户可以再次提交评级。 （2）添加自定义控件到视图webapp&#x2F;view&#x2F;Detail.view.xml 1234567891011121314151617&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.Detail&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; xmlns:wt=&quot;TestCaseTwo.controller&quot;&gt; &lt;!--新增内容--&gt; &lt;Page title=&quot;&#123;i18n&gt;detailPageTitle&#125;&quot; showNavButton = &quot;true&quot; navButtonPress = &quot;.onNavBack&quot;&gt; &lt;ObjectHeader intro=&quot;&#123;invoice&gt;ShipperName&#125;&quot; title=&quot;&#123;invoice&gt;ProductName&#125;&quot;/&gt; &lt;!--新增内容--&gt; &lt;wt:ProductRating id=&quot;rating&quot; class=&quot;sapUiSmallMarginBeginEnd&quot; change=&quot;.onRatingChange&quot;/&gt; &lt;!--新增内容--&gt; &lt;/Page&gt;&lt;/mvc:View&gt; 在detail视图上定义了一个新的名称空间wt，以便我们可以在视图中轻松地引用自定义控件。然后，我们将ProductRating控件的一个实例添加到详细信息页面，并为更改事件注册一个事件处理程序。为了有一个合适的布局，我们还添加了一个边距样式类。 （3）设置新添加视图中的按钮逻辑webapp&#x2F;controller&#x2F;Detail.controller.js 12345678910111213141516171819202122232425262728sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/core/routing/History&quot;, &quot;sap/m/MessageToast&quot; // 新增内容], function (Controller, History, MessageToast) &#123; &quot;use strict&quot;; return Controller.extend(&quot;sap.ui.demo.TestCaseTwo.controller.Detail&quot;, &#123; ... _onObjectMatched: function (oEvent) &#123; this.byId(&quot;rating&quot;).reset(); // 新增内容 this.getView().bindElement(&#123; // 获取的是URL路径上传递过来的数据模型路径 path: &quot;/&quot; + window.decodeURIComponent(oEvent.getParameter(&quot;arguments&quot;).invoicePath), model: &quot;invoice&quot; &#125;); &#125;, ... // 新增内容 onRatingChange: function (oEvent) &#123; var fValue = oEvent.getParameter(&quot;value&quot;); var oResourceBundle = this.getView().getModel(&quot;i18n&quot;).getResourceBundle(); MessageToast.show(oResourceBundle.getText(&quot;ratingConfirmation&quot;, [fValue])); &#125; // 新增内容 &#125;);&#125;); 在Detail controller中，我们将依赖项加载到sap.m. MessageToast，因为我们只显示一条消息，而不是将评级发送到后端，以保持示例的简单性。事件处理程序onRatingChange读取提交评级时触发的自定义更改事件的值。然后，我们在MessageToast控件中显示一条带有该值的确认消息。 在OnObject Matched private方法中，我们调用重置方法，以便在显示不同项目的详细信息视图时，可以提交另一个评级。 （4）设置CSS渲染器webapp&#x2F;css&#x2F;style.css 12345678910/* Enter your custom styles here */.../* ProductRating */.myAppDemoWTProductRating &#123; padding: 0.75rem;&#125;.myAppDemoWTProductRating .sapMRI &#123; vertical-align: initial;&#125; 为了布局我们的控件，我们在根类中添加了一点填充，以便在三个内部控件周围有一些空间，我们重写RatingIndicator控件的对齐方式，以便它与标签和按钮对齐。 我们也可以在渲染器中使用更多HTML来实现这一点，但这是最简单的方法，它只会应用于我们的自定义控件中。但是，请注意，自定义控件在您的应用程序中，可能需要在SAPUI5的未来版本中更改内部控件时进行调整。 （5）设置响应文本内容webapp&#x2F;i18n&#x2F;i18n.properties、 12345678910…# Detail PagedetailPageTitle=Walkthrough - DetailsratingConfirmation=You have rated this product with &#123;0&#125; stars# Product RatingproductRatingLabelInitial=Please rate this productproductRatingLabelIndicator=Your rating: &#123;0&#125; out of &#123;1&#125;productRatingLabelFinal=Thank you for your rating!productRatingButton=Rate 资源包通过确认消息和我们在自定义控件中引用的字符串进行扩展。现在，我们可以使用全新的控件在详细信息页面上对产品进行评级。 （6）效果图展示 十八、响应性在这一步中，我们提高了应用程序的响应能力。SAPUI5应用程序可以在手机、平板电脑和桌面设备上运行，我们可以对应用程序进行配置，以便在每个场景中充分利用屏幕状态。幸运的是，SAPUI5可以像sap.m.Table一样控制。已经提供了很多我们可以使用的功能。 （1）修改列表视图webapp&#x2F;view&#x2F;InvoiceList.view.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;Table &lt;!--新增内容--&gt; id=&quot;invoiceList&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123; path: &#x27;invoice&gt;/Invoices&#x27;, sorter: &#123; path: &#x27;ShipperName&#x27;, group: true &#125; &#125;&quot; &gt; &lt;headerToolbar&gt; &lt;Toolbar&gt; &lt;Title text=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot;/&gt; &lt;ToolbarSpacer/&gt; &lt;SearchField width=&quot;50%&quot; search=&quot;.onFilterInvoices&quot;/&gt; &lt;/Toolbar&gt; &lt;/headerToolbar&gt; &lt;!--新增内容--&gt; &lt;columns&gt; &lt;Column hAlign=&quot;End&quot; minScreenWidth=&quot;Small&quot; demandPopin=&quot;true&quot; width=&quot;5em&quot;&gt; &lt;Text text=&quot;&#123;i18n&gt;columnQuantity&#125;&quot;/&gt; &lt;/Column&gt; &lt;Column&gt; &lt;Text text=&quot;&#123;i18n&gt;columnName&#125;&quot;/&gt; &lt;/Column&gt; &lt;Column minScreenWidth=&quot;Small&quot; demandPopin=&quot;true&quot;&gt; &lt;Text text=&quot;&#123;i18n&gt;columnStatus&#125;&quot;/&gt; &lt;/Column&gt; &lt;Column minScreenWidth=&quot;Tablet&quot; demandPopin=&quot;false&quot;&gt; &lt;Text text=&quot;&#123;i18n&gt;columnSupplier&#125;&quot;/&gt; &lt;/Column&gt; &lt;Column hAlign=&quot;End&quot;&gt; &lt;Text text=&quot;&#123;i18n&gt;columnPrice&#125;&quot;/&gt; &lt;/Column&gt; &lt;/columns&gt; &lt;items&gt; &lt;ColumnListItem type=&quot;Navigation&quot; press=&quot;.onPress&quot;&gt; &lt;cells&gt; &lt;ObjectNumber number=&quot;&#123;invoice&gt;Quantity&#125;&quot; emphasized=&quot;false&quot;/&gt; &lt;ObjectIdentifier title=&quot;&#123;invoice&gt;ProductName&#125;&quot;/&gt; &lt;Text text=&quot;&#123; path: &#x27;invoice&gt;Status&#x27;, formatter: &#x27;.formatter.statusText&#x27; &#125;&quot;/&gt; &lt;Text text=&quot;&#123;invoice&gt;ShipperName&#125;&quot;/&gt; &lt;ObjectNumber number=&quot;&#123; parts: [&#123;path: &#x27;invoice&gt;ExtendedPrice&#x27;&#125;, &#123;path: &#x27;view&gt;/currency&#x27;&#125;], type: &#x27;sap.ui.model.type.Currency&#x27;, formatOptions: &#123; showMeasure: false &#125; &#125;&quot; unit=&quot;&#123;view&gt;/currency&#125;&quot; state=&quot;&#123;= $&#123;invoice&gt;ExtendedPrice&#125; &gt; 50 ? &#x27;Error&#x27; : &#x27;Success&#x27; &#125;&quot;/&gt; &lt;/cells&gt; &lt;/ColumnListItem&gt; &lt;/items&gt; &lt;/Table&gt; &lt;!--新增内容--&gt;&lt;/mvc:View&gt; 我们只需将标签替换为即可将列表与表交换。该表具有内置的响应功能，允许我们使应用程序更加灵活。表和列表共享同一组属性，因此我们可以简单地重用这些属性和分类器。 由于一个表的每行有多个单元格，我们必须为表定义列，并根据数据命名这些列。我们添加了五个 sap.m.Column 控件添加到列聚合中，并对每个控件进行稍微不同的配置： Quantity 此列将包含一个短数字，因此我们将对齐设置为End（在LTR语言中是“right”的意思），并将宽度设置为5em，这对于列描述来说足够长。作为描述文本，我们使用sap.m.Text引用资源束属性的控件。我们将属性minScreenWidth设置为Small，以表明此列在手机上不太重要。通过将属性demandPopin设置为true，我们将告诉表在主列下方显示此列。 Name 我们的主栏有一个相当大的宽度来显示所有的细节。它将始终显示出来。 Status 状态并不是那么重要，所以我们还可以通过将minScreenWidth设置为small，将demandPopin设置为true，在小屏幕上的name字段下方显示状态 Supplier 我们将minScreenWidth设置为Tablet，demandPopin设置为false，从而完全隐藏手机设备上的供应商栏。 Price 此列始终可见，因为它包含我们的发票价格。 我们不再使用之前的ObjectListItem，而是将信息拆分到与上面定义的列匹配的单元格中。因此，我们将其更改为具有相同属性的ColumnListItem控件，但现在使用cells聚合。在这里，我们创建五个控件来显示数据： Quantity 一个简单的sap.m.ObjectNumber控件，绑定到我们的数据字段。 Name 指定名称的sap.m.ObjectIdentifier控件。 Status 使用与以前相同的格式化程序的sap.m.Text控件。 Supplier 一个简单的sap.m.Text控件。 Price 一个ObjectNumber控件，其格式与前面步骤中的属性number和NumberRunIt相同。 （2）设置列名文本webapp&#x2F;i18n&#x2F;i18n.properties 1234567891011121314...# Invoice ListinvoiceListTitle=InvoicesinvoiceStatusA=NewinvoiceStatusB=In ProgressinvoiceStatusC=DonecolumnQuantity=QuantitycolumnName=NamecolumnSupplier=SuppliercolumnStatus=StatuscolumnPrice=Price# Detail Page... 我们将列名和属性标题添加到i18n文件中。 当我们缩小浏览器的屏幕大小或在小型设备上打开应用程序时，我们可以看到结果。 （3）效果图展示 十九、设备适配接下来设置页面的设备适配，页面会根据不同的设备进行相应的响应。 （1）设置可扩展属性webapp&#x2F;view&#x2F;HelloPanel.view.xml 12345678910111213141516171819202122232425262728&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.HelloPanel&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Panel headerText=&quot;&#123;i18n&gt;helloPanelTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; expandable=&quot;&#123;device&gt;/system/phone&#125;&quot; expanded=&quot;&#123;= !$&#123;device&gt;/system/phone&#125; &#125;&quot;&gt; &lt;!--新增内容--&gt; &lt;content&gt; &lt;Button id=&quot;helloDialogButton&quot; icon=&quot;sap-icon://world&quot; text=&quot;&#123;i18n&gt;openDialogButtonText&#125;&quot; press=&quot;onOpenDialog&quot; class=&quot;sapUiSmallMarginEnd sapUiVisibleOnlyOnDesktop&quot;/&gt; &lt;!--新增内容--&gt; &lt;Button text=&quot;&#123;i18n&gt;showHelloButtonText&#125;&quot; press=&quot;onWhowHello&quot; class=&quot;myCustomButton&quot;/&gt; &lt;Input value=&quot;&#123;/recipient/name&#125;&quot; valueLiveUpdate=&quot;true&quot; width=&quot;60%&quot;/&gt; &lt;FormattedText htmlText=&quot;Hello &#123;/recipient/name&#125;&quot; class=&quot;sapUiSmallMargin sapThemeHighlight-asColor myCustomText&quot;/&gt; &lt;/content&gt; &lt;/Panel&gt;&lt;/mvc:View&gt; 在HelloPanel中添加了两个可以扩展的新属性，用户可以在手机等小屏幕设备上浏览网页。可扩展属性绑定到名为device的模型和path &#x2F;system&#x2F;phone。因此，该页面只能在手机设备上扩展。设备模型中填充了SAPUI5的sap.ui.Device 的API。扩展属性控制面板的状态，我们使用表达式绑定语法在电话设备上关闭面板，并在所有其他设备上扩展面板。 当我们设置像sapUiVisibleOnlyOnDesktop或sapUiHideOnDesktop这样的CSS类时，我们也可以按设备类型隐藏单个控件。我们只显示在桌面设备上打开对话框的按钮，而在其他设备上隐藏对话框。 sap.ui.Device API根据用户代理和设备的许多其他属性检测设备类型（电话、平板电脑、桌面）。因此，简单地减小屏幕大小不会改变设备类型。要测试此功能，您必须在浏览器中启用设备模拟或在真实设备上打开它。 （2）在程序组件中添加依赖项webapp&#x2F;Component.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061sap.ui.define([ &quot;sap/ui/core/UIComponent&quot;, &quot;sap/ui/Device&quot;, &quot;sap/ui/model/json/JSONModel&quot;, &quot;sap/ui/model/resource/ResourceModel&quot;, &quot;./controller/HelloDialog&quot; // 新增内容], function(UIComponent, Device, JSONModel, ResourceModel, HelloDialog) &#123; &quot;use strict&quot;; return UIComponent.extend(&quot;TestCaseTwo.Component&quot;, &#123; metadata: &#123; manifest: &quot;json&quot; &#125;, /** * The component is initialized by UI5 automatically during the startup of the app and calls the init method once. * @public * @override */ init: function() &#123; // call the base component&#x27;s init function UIComponent.prototype.init.apply(this, arguments); var oData = &#123; recipient : &#123; name : &quot;World&quot;, text : &quot;ok&quot; &#125; &#125;; var oModel = new JSONModel(oData); this.setModel(oModel); // set i18n model on view var i18nModel = new ResourceModel(&#123; bundleName:&quot;TestCaseTwo.i18n.i18n&quot; &#125;); this.setModel(i18nModel,&quot;i18n&quot;); // 新增内容 // set device model var oDeviceModel = new JSONModel(Device); oDeviceModel.setDefaultBindingMode(&quot;OneWay&quot;); this.setModel(oDeviceModel, &quot;device&quot;); // 新增内容 // set dialog this._helloDialog = new HelloDialog(this.getRootControl()); // create the views based on the url/hash this.getRouter().initialize(); &#125;, exit : function()&#123; this._helloDialog.destroy(); delete this._helloDialog; &#125;, openHelloDialog : function()&#123; this._helloDialog.open(); &#125; &#125;);&#125;); 在应用程序组件中，我们向BBB添加一个依赖项，并在init方法中初始化设备模型。我们可以简单地将加载的依赖项设备传递给JSONModel的构造函数。这将使SAPUI5设备API的大多数属性作为JSON模型提供。然后将该模型作为命名模型设置在组件上，以便我们可以在数据绑定中引用它，正如我们在上面的视图中看到的那样。 我们必须将绑定模式设置为单向，因为设备模型是只读的，并且我们希望避免在将控件的属性绑定到它时意外更改模型。默认情况下，SAPUI5中的模型是双向的（双向的）。属性更改时，绑定模型值也会更新。 （3）设置详情页面表格webapp&#x2F;view&#x2F;Detail.view.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.Detail&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; xmlns:wt=&quot;TestCaseTwo.controller&quot;&gt; &lt;Page title=&quot;&#123;i18n&gt;detailPageTitle&#125;&quot; showNavButton = &quot;true&quot; navButtonPress = &quot;.onNavBack&quot;&gt; &lt;ObjectHeader &lt;!--新增内容--&gt; responsive=&quot;true&quot; fullScreenOptimized=&quot;true&quot; number=&quot;&#123; parts: [&#123;path: &#x27;invoice&gt;ExtendedPrice&#x27;&#125;, &#123;path: &#x27;view&gt;/currency&#x27;&#125;], type: &#x27;sap.ui.model.type.Currency&#x27;, formatOptions: &#123; showMeasure: false &#125; &#125;&quot; numberUnit=&quot;&#123;view&gt;/currency&#125;&quot; &lt;!--新增内容--&gt; intro=&quot;&#123;invoice&gt;ShipperName&#125;&quot; title=&quot;&#123;invoice&gt;ProductName&#125;&quot;&gt; &lt;!--新增内容--&gt; &lt;attributes&gt; &lt;ObjectAttribute title=&quot;&#123;i18n&gt;quantityTitle&#125;&quot; text=&quot;&#123;invoice&gt;Quantity&#125;&quot;&gt;&lt;/ObjectAttribute&gt; &lt;ObjectAttribute title=&quot;&#123;i18n&gt;dateTitle&#125;&quot; text=&quot;&#123; path: &#x27;invoice&gt;ShippedDate&#x27;, type: &#x27;sap.ui.model.type.Date&#x27;, formatOptions: &#123; style: &#x27;long&#x27;, source: &#123; pattern: &#x27;yyyy-MM-ddTHH:mm:ss&#x27; &#125; &#125; &#125;&quot;/&gt; &lt;/attributes&gt; &lt;!--新增内容--&gt; &lt;/ObjectHeader&gt; &lt;wt:ProductRating id=&quot;rating&quot; class=&quot;sapUiSmallMarginBeginEnd&quot; change=&quot;.onRatingChange&quot;/&gt; &lt;/Page&gt;&lt;/mvc:View&gt; 一些控件已经具有可配置的内置响应功能。ObjectHeader控件可以设置为更灵活的模式，方法是将属性responsive设置为true和fullScreenOptimized设置为true。这将根据设备大小在屏幕上的不同位置显示我们现在添加到视图中的数据。 我们还将前面步骤列表中的number和numberUnit字段添加到ObjectHeader中，并使用与前面步骤中相同的货币类型格式化程序。然后我们定义两个属性：发票数量和发货日期，这是数据模型的一部分。到目前为止，我们还没有使用发票JSON文件中的shippedDate字段，它包含一个典型字符串格式的日期。 我们现在使用日期类型，并在格式选项的源部分提供日期格式的模式。它将显示更具可读性的格式化日期文本，也适用于小屏幕设备。 （4）设置详情页面的单位数据模型webapp&#x2F;controller&#x2F;Detail.controller.js 123456789101112131415161718192021222324sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;, &quot;sap/ui/core/routing/History&quot;, &quot;sap/m/MessageToast&quot;, &quot;sap/ui/model/json/JSONModel&quot; // 新增内容], function (Controller, History, MessageToast, JSONModel) &#123; &quot;use strict&quot;; return Controller.extend(&quot;sap.ui.demo.TestCaseTwo.controller.Detail&quot;, &#123; onInit: function () &#123; // 新增内容 var oViewModel = new JSONModel(&#123; currency: &quot;EUR&quot; &#125;); this.getView().setModel(oViewModel, &quot;view&quot;); // 新增内容 var oRouter = this.getOwnerComponent().getRouter(); // 设置上下文对象 oRouter.getRoute(&quot;detail&quot;).attachPatternMatched(this._onObjectMatched, this); &#125;, ... &#125;);&#125;); 因为在详情页面有单位的内容需要显示，但是没并没有单位的数据，所以需要设置一个单位并使用数据模型传递过去。 （5）设置文本内容webapp&#x2F;i18n&#x2F;i18n.properties 1234# Detail Page...dateTitle=Order datequantityTitle=Quantity 因为无法测试，所以本案例不设置效果图 二十、内容密度在本演练教程的这一步中，我们将根据用户的设备调整内容密度。SAPUI5包含不同的内容密度，允许您为支持触摸的设备显示更大的控件，并为通过鼠标操作的设备显示更小、更紧凑的设计。在我们的应用程序中，我们将检测设备并相应地调整密度。 （1）设置内容密度助手方法webapp&#x2F;Component.js 1234567891011121314151617... init: function () &#123;... &#125;,... getContentDensityClass : function () &#123; if (!this._sContentDensityClass) &#123; if (!Device.support.touch) &#123; this._sContentDensityClass = &quot;sapUiSizeCompact&quot;; &#125; else &#123; this._sContentDensityClass = &quot;sapUiSizeCozy&quot;; &#125; &#125; return this._sContentDensityClass; &#125; &#125;);&#125;); 为了准备内容密度特性，我们还将添加一个助手方法getContentDensityClass。SAPUI5控件可以以多种尺寸显示，例如，以适合桌面和非触摸设备的紧凑尺寸显示，以及以适合触摸交互的舒适模式显示。这些控件在应用程序的HTML结构中查找特定的CSS类，以调整其大小。 此助手方法直接查询设备API以获得客户端的触摸支持，如果不支持触摸交互，则返回CSS类sapUiSizeCompact，对于所有其他情况，则返回sapUiSizeCozy。我们将在整个应用程序编码过程中使用它来设置适当的内容密度CSS类。 （2）设置视图上相应的样式类webapp&#x2F;controller&#x2F;View1.controller.js 12345678910111213141516sap.ui.define([ &quot;sap/ui/core/mvc/Controller&quot;], function(Controller) &#123; &quot;use strict&quot;; return Controller.extend(&quot;TestCaseTwo.controller.View1&quot;, &#123; // 新增内容 onInit : function () &#123; this.getView().addStyleClass(this.getOwnerComponent().getContentDensityClass()); &#125;, // 新增内容 onOpenDialog : function () &#123; this.getOwnerComponent().openHelloDialog(); &#125; &#125;);&#125;); 我们在app控制器上添加了一个方法onInit，在实例化app视图时调用该方法。在这里，我们查询应用程序组件上定义的helper函数，以在应用程序视图上设置相应的样式类，应用程序视图中的所有控件现在将自动调整为样式定义的紧凑或舒适大小。 （3）同步对话框的样式类与应用程序一致webapp&#x2F;controller&#x2F;HelloDialog.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647sap.ui.define([ &quot;sap/ui/base/ManagedObject&quot;, &quot;sap/ui/core/Fragment&quot;, &quot;sap/ui/core/syncStyleClass&quot; // 新增内容], function (ManagedObject,Fragment,syncStyleClass) &#123; &quot;use strict&quot;; return ManagedObject.extend(&quot;TestCaseTwo.controller.HelloDialog&quot;,&#123; constructor : function(oView)&#123; this._oView = oView; &#125;, exit : function() &#123; delete this._oView; &#125;, open : function() &#123; var oView = this._oView; // create dialog lazily if (!this.pDialog)&#123; var oFragmentController = &#123; onCloseDialog : function() &#123; oView.byId(&quot;helloDialog&quot;).close(); &#125; &#125;; // load asynchronous XML fragment this.pDialog = Fragment.load(&#123; id : oView.getId(), name : &quot;TestCaseTwo.view.HelloDialog&quot;, controller : oFragmentController &#125;).then(function (oDialog) &#123; // connect dialog to the root view of this component (models,lifecycle) oView.addDependent(oDialog); // 新增内容 // forward compact/cozy style into dialog syncStyleClass(oView.getController().getOwnerComponent().getContentDensityClass(), oView, oDialog); // 新增内容 return oDialog; &#125;); &#125; this.pDialog.then(function(oDialog) &#123; oDialog.open(); &#125;); &#125; &#125;);&#125;); “Hello World”对话框不是应用程序视图的一部分，而是在DOM中名为“静态区域”的特殊部分打开的。对话框不知道应用程序视图中定义的内容密度类，因此我们手动将应用程序的样式类与对话框同步。 （4）设置应用程序的支持模式webapp&#x2F;manifest.json 123456789101112... &quot;sap.ui5&quot;: &#123; ... &quot;dependencies&quot;: &#123; ... &#125;, &quot;contentDensities&quot;: &#123; &quot;compact&quot;: true, &quot;cozy&quot;: true &#125; &#125; 在sap的内容密度部分。在ui5命名空间中，我们指定应用程序支持的模式。SAP Fiori launchpad等容器允许根据这些设置切换内容密度。\\ 由于我们刚刚根据设备功能启用了应用程序以两种模式运行，因此我们可以在应用程序描述符中将这两种模式都设置为true。 二十一、可达性提高应用程序的可访问性。 为了实现这一点，我们将添加ARIA属性。屏幕阅读器使用ARIA属性来识别应用程序结构并正确解释UI元素。通过这种方式，我们可以让我们的应用程序更容易被那些使用电脑受到限制的用户访问， for example visually impaired persons。这里的主要目标是让我们的应用程序能为尽可能多的人使用。 （1）设置ARIA角色和标签webapp&#x2F;view&#x2F;Overview.view.xml 123456789101112131415161718192021222324252627&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.View1&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;Page title=&quot;&#123;i18n&gt;homePageTitle&#125;&quot;&gt; &lt;!--新增内容--&gt; &lt;landmarkInfo&gt; &lt;PageAccessibleLandmarkInfo rootRole=&quot;Region&quot; rootLabel=&quot;&#123;i18n&gt;Overview_rootLabel&#125;&quot; contentRole=&quot;Main&quot; contentLabel=&quot;&#123;i18n&gt;Overview_contentLabel&#125;&quot; headerRole=&quot;Banner&quot; headerLabel=&quot;&#123;i18n&gt;Overview_headerLabel&#125;&quot;/&gt; &lt;/landmarkInfo&gt; &lt;!--新增内容--&gt; &lt;headerContent&gt; &lt;Button icon=&quot;sap-icon://hello-world&quot; press=&quot;.onOpenDialog&quot;/&gt; &lt;/headerContent&gt; &lt;content&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.HelloPanel&quot;/&gt; &lt;mvc:XMLView viewName=&quot;TestCaseTwo.view.InvoiceList&quot;/&gt; &lt;/content&gt; &lt;/Page&gt;&lt;/mvc:View&gt; 我们使用sap.m.PageAccessibleLandmarkInfo为概览页面区域定义ARIA角色和标签。有关更多信息，请参阅API参考：sap。m、 PageAccessibleLandmarkInfo。 （2）设置工具栏标题webapp&#x2F;view&#x2F;InvoiceList.view.xml 123456789101112131415161718192021222324252627282930313233343536&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.InvoiceList&quot; xmlns=&quot;sap.m&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot;&gt; &lt;Panel accessibleRole=&quot;Region&quot;&gt; &lt;headerToolbar&gt; &lt;Toolbar&gt; &lt;Title text=&quot;&#123;i18n&gt;invoiceListTitle&#125;&quot;/&gt; &lt;ToolbarSpacer/&gt; &lt;SearchField width=&quot;50%&quot; search=&quot;.onFilterInvoices&quot; ariaLabelledBy=&quot;searchFieldLabel&quot; ariaDescribedBy=&quot;searchFieldDescription&quot; placeholder=&quot;&#123;i18n&gt;searchFieldPlaceholder&#125;&quot;/&gt; &lt;/Toolbar&gt; &lt;/headerToolbar&gt; &lt;Table id=&quot;invoiceList&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; items=&quot;&#123; path : &#x27;invoice&gt;/Invoices&#x27;, sorter : &#123; path : &#x27;ShipperName&#x27;, group : true &#125; &#125;&quot;&gt; &lt;columns&gt; &lt;Column hAlign=&quot;End&quot; … &lt;/columns&gt; &lt;/Table&gt; &lt;/Panel&gt;&lt;/mvc:View&gt; 我们在发票列表周围添加了一个sap.m.Panel，并将工具栏从表中移动到面板中，以便该区域可以将工具栏的标题作为自己的标题。这意味着它现在将成为我们地标性建筑中的一个区域。 webapp&#x2F;view&#x2F;HelloPanel.view.xml 123456789101112131415&lt;mvc:View controllerName=&quot;TestCaseTwo.controller.HelloPanel&quot; xmlns:mvc=&quot;sap.ui.core.mvc&quot; displayBlock=&quot;true&quot; xmlns=&quot;sap.m&quot;&gt; &lt;Panel headerText=&quot;&#123;i18n&gt;helloPanelTitle&#125;&quot; class=&quot;sapUiResponsiveMargin&quot; width=&quot;auto&quot; expandable=&quot;&#123;device&gt;/system/phone&#125;&quot; expanded=&quot;&#123;= !$&#123;device&gt;/system/phone&#125; &#125;&quot; accessibleRole=&quot;Region&quot;&gt; … &lt;/Panel&gt;&lt;/mvc:View&gt; 在这个视图中，我们已经有了一个面板，所以我们只需添加accessibleRole属性。 （3）设置文本内容webapp&#x2F;i18n&#x2F;i18n.properties 1234567...#Overview PageOverview_rootLabel=Overview PageOverview_headerLabel=HeaderOverview_contentLabel=Page ContentratingTitle=Rate the Product... 在这里，我们将评级面板标题的文本和ARIA区域的标签添加到文本包中。","categories":[{"name":"Fiori基础","slug":"Fiori基础","permalink":"https://www.yemaojun.top/categories/Fiori%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Fiori","slug":"Fiori","permalink":"https://www.yemaojun.top/tags/Fiori/"}]},{"title":"ABAP 面试问题收集","slug":"面试总结/ABAP 面试内容收集/ABAP面试问题收集","date":"2023-03-25T23:01:56.000Z","updated":"2023-03-05T23:10:05.130Z","comments":true,"path":"2023/03/26/面试总结/ABAP 面试内容收集/ABAP面试问题收集/","link":"","permalink":"https://www.yemaojun.top/2023/03/26/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/ABAP%20%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9%E6%94%B6%E9%9B%86/ABAP%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/","excerpt":"入行SAP算上实习已经两年时间，为了看看新机会和了解学习方向参加了一些面试。现将面试过程中尚有疑问的部分记录如下，后续会在此或另起笔记记录问题的解答情况。","text":"入行SAP算上实习已经两年时间，为了看看新机会和了解学习方向参加了一些面试。现将面试过程中尚有疑问的部分记录如下，后续会在此或另起笔记记录问题的解答情况。 ABAP面试问题收集 一、2023年2月20日星期一，上海乙方外企1.BAPI的查找方式当时没有答出在SAP中的查找方式。后续研究后将内容补至此处。 2.FI模块中部分表是做什么的业务部分确实是短板，后续另起笔记记录业务的学习进度。 3.","categories":[{"name":"面试","slug":"面试","permalink":"https://www.yemaojun.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"OData 学习笔记","slug":"ABAP/OData/OData学习笔记","date":"2023-03-15T12:02:18.000Z","updated":"2023-05-20T13:01:52.682Z","comments":true,"path":"2023/03/15/ABAP/OData/OData学习笔记/","link":"","permalink":"https://www.yemaojun.top/2023/03/15/ABAP/OData/OData%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本篇笔记主要用于记录学习OData时的学习总结，不定期更新。这一片主要介绍了OData的创建与CTS之间的绑定、测试等相关内容。","text":"本篇笔记主要用于记录学习OData时的学习总结，不定期更新。这一片主要介绍了OData的创建与CTS之间的绑定、测试等相关内容。 OData 学习笔记 一、创建Gateway的五个步骤1.OData Service DefinitionOData服务定义。 2.Data Model Definition（MPC）OData模型定义。Model Import、RFC&#x2F;BOR、DDIC、File、Search Help。 3.Service Generation服务生成。SRV Class自动生成。 4.Service Implementation（DPC）服务实施。Read、Create、Delete和Update等。 5.Service Registration and Activation服务注册和启用。 二、OData创建 1.TCODESEGW 2.输入必输项 **Project:**项目名称 **Description:**项目描述 Package：项目存放的包 3.默认项 Generation Strategy Project Type 三、导入数据模型 导入数据模型的四种方式： 1.Data Model From File（文件数据模型）通过上传一个文件（.edmx或.xml包含可在服务生成器项目中重用的预定义数据）。 2.DDIC Structure（DDIC结构）将现有的ABAP结构作为复杂类型或实体类型重用。包括Views、Database Tables、Structure。 3.RFC&#x2F;BOR Interface（RFC&#x2F;BOR接口）实现RFC或BOR生成器。 4.Search Help（搜索帮助）导入与模型关联的搜索帮助并在项目中重用。 四、DDIC Structure创建数据模型DDIC形式是通过将现有的ABAP结构作为复杂类型或实体类型重用。即是用SE11中存在的Views、Database Tables、Structure等作为数据模型使用。这种方式也是OData创建数据模型的最常用的形式之一。 1.选择DDIC创建数据模型 2.选择数据模型表本次使用Sflight表作为数据模型表进行演示。 3.选择需要操作的字段 4.设置主键字段设置主键字段时，建议设置成和ABAP TABLE一样的主键，并且需要确保ABAP Name 与Name（Entity Property Name）的名字保持一致。 5.设置各个Property字段的属性在进行完上面的操作之后，点击Entity Types文件夹，可以在其中看到我们刚刚创建的名字叫UserInfo的数据模型。按照图片中提示的点击内容，设置相应字段的属性。设置完属性之后点击图中的激活按钮。 关于该表格中的各项属性的含义可以参照下面的第七项读取数据模型的属性（Entity Types）中的内容。 五、设置OData的增删改查方法实现CRUD的方式有很多，可以使用Function、CDS和重写OData中的类方法。本次介绍较常使用的重写类的方式。 1.打开Runtime Artifacts文件夹选择带有DPC_EXT的类，右键选择“Go To ABAP Workbench”。进入该类的SE80状态。 2.在左侧的工具栏中按照下图的内容选择需要重定义的方法需要重写的有5个方法，分别对应CRDU： Create：(Entity Types Name)_CREATE_ENTITY Read：(Entity Types Name)_GET_ENTITY（单条） (Entity Types Name)_GET_ENTITYSET（多条） Delete：(Entity Types Name)_DELETE_ENTITY Update：(Entity Types Name)_UPDATE_ENTITY 选择重定义的方法之后会在Methods文件下新建一个文件夹Redefinitions，此处存放的是重定义的方法。 （1）重写创建方法 （2）重写修改方法 （3）重写删除方法 （4）编写查询数据用CDS如图中的文字，在此处设置字段的变量，如果使用到WHERE中，则在前端使用CDS时这几个参数必须作为必输参数传递到后端查询数据。但是前端很多时候是不确定使用哪些字段进行查询的。所以建议在创建CDS时，不要设置WHERE条件中的参数，除非业务需要。 （5）将OData与CDS相关联在Data Model文件上右键选择Reference —&gt; Data Source 在弹出的框中填入CDS的视图名称，此处可以使用搜索帮助。 （6）CDS与查询数据的关系OData中查询数据有两种方式，一种是查询单条数据使用的GetEntity，一种是查询多条数据所使用的GetEntitySet。而当绑定CDS之后，CDS会自动与这两种数据查询Method相关联。当前端发送请求数据的请求后，会自动调用CDS并结合Fieter中的筛选数据对数据进行筛选。详细的可以参照OData的测试 六、Entity Types &amp; Entity Set1.Entities Entity Types：定义如名字、类型、Key等属性（ex .Employee等） Entities：Entity Types的实例 Entity Key：会unique地定义Entities，用于定义其他Entities之间的关系（ex.CustomerId，OrderId） Entity Set：可以使用数据模型的基本单位 利用Entity Types生成Entity Set 一个Entity Set包含Create、Delete、Update、GetEntitySet(Query)、GetEntity(Read)共5个基本METHOD。 2.Associations定义两个或多个Entity Type关系 七、读取数据模型的属性（Entity Types） Field Annotation Description Createable sap:createable 对应Entity Type Field值输入设定。勾选该属性在执行创建的时候可以由前台录入数据来填充（比如客户编码）；若不勾选，则在前台执行创建时，由后台指定数据来填充（比如销售订单编码等），一般Key字段都会勾选 Updateable sap:updateable 对应Entity Type Field值修改设定。勾选该属性，在执行更新的时候可以由前台录入数据来填充（比如手机号）；若不勾选，则在前台执行更新时，由后台指定数据来填充（比如时间戳&#x2F;日期等） Deleteable N&#x2F;A 是否勾选并不影响 Sortable sap:sortable 对应Entity Type Field值排序设定，勾选后，则可以使用Sorderby查询（比如Sorderby &#x3D; CustomerName） Nullable Nullable 对应Entity Type Field值排序设定，勾选后，则可以使用Sorderby查询（比如Sorderby &#x3D; CustomerName） Filterable sap:filterable 对应Entity Type Field值Filter许可。勾选后则可以使用Sfilter查询（比如Sfilter &#x3D; orderNumber eq ‘1234’） Name N&#x2F;A property的名字 Key N&#x2F;A 是否是对应property的Key Edm Core Type N&#x2F;A property的类型经常使用的类型：Edm.String（字符串）Edm.DateTime(日期)Edm.Decimal（数字）Edm.Time(时间) Label N&#x2F;A UI上要显示的Label Text ABAP Field N&#x2F;A 生成property时参考的ABAP Field名。生成Entity Type时参考ABAP Object生成的话，可以使用对应字段及字段所参照的Date Element属性进行modeling（ex.Alpha conversion等）-&gt;设计时需要明示要参考的ABAP字段 八、Entity Set的属性设置 Field Annotation Description Createable sap:createable 可以通过Http的post方法来执行创建数据 Updateable sap:updateable 可以通过Http的put方法来执行更新数据 Deleteable sap:deletable 可以通过Http的delete方法来执行删除数据 Pageable sap:pageable 勾选后可以支持分页查询，比如指定页面数据的条目数和大小，跳过指定条目数等（top&#x2F;skip） Addressable sap:addressable 是否勾选表示，可以直接导航到相关EntitySet（即是否可以使用navigation） Searchable sap:searchable 是否勾选表示,可以支持search语句的使用（比如productSet?search&#x3D;’box’） Subrchable N&#x2F;A 是否勾选表示在修改的时候是否同时支持对其下属关联属性的修改，一般用于RFC&#x2F;BOR等 RequiresFilter sap:requiresfilter 是否勾选表示是否支持Filter语句 ![Entity Set属性说明](OData学习笔记&#x2F;Entity Set属性说明.PNG) 九、关联关系Association1.关联关系介绍从下面的图中可以看到YLPP_TEST_EXPAND3_SRV中含有三个Entity Types和两个Association。其中，在图片的右侧，可以清楚的看到Association。其中HeaderToItem是将Entity Types中的Header和Item关联起来。同理，Association中的ItemToProduct是将Entity Types中的Item和Product关联起来。也可以看到他们之间的对应关系。 2.关联关系的创建（1）当当前OData还没有关联关系时先按照下图所示的方式新建一个关联关系 （2）填写该页面的内容 完全创建好关联关系需要三个步骤。 Principal Entity：建立关联的起始字段设置 Dependent Entity：从关联起始字段到该关联字段结束的字段设置 Cardinality：关联关系一对多、多对一等设置 Navigation Property：关联关系的向导设置 Cardinality Description 0 .. 1 记录可有可无，最多一条记录 1 必须存在一条记录 0 .. n 记录可有可无，可有n条记录 1 .. n 至少存在一条记录，可有n条记录 ①第一个步骤——填写关联的数据模型和设置关联属性 可以在对话框的左上角看到当前步骤1 ②第二个步骤——设置关联相关的字段 ③第三个步骤 创建Association Set 当创建完成之后会在页面下方提示如下信息 3.Navigation导航在生成Association时，系统会自动生成一个Navigation。在Entity Types中展开刚刚设置的起始模型可以看到Navigation Properties可以下拉，下拉后可以找到刚刚创建的Navigation Properties。双击后可以看到对应的关系，此处的ABAP Field Name十分重要。 4.使用Association的理由Header数据和Item数据都存在时，很多情况都是以Header数据为基准查找Item数据，这种情况： （1）创建Header数据和Item数据混合在一起的Entity Types（这种情况保存数据时，需要区分Header数据和Item数据）； （2）创建Header Entity Set和Item Entity Set后读取Header数据并以Key值为基准依次连接Item Entity Set（这种情况如果两个Entity Set之间）没有连接的话，需要调用两次Model） 这时为了在UI上方便读取Header Entity Set和Item Entity Ser，通过Navigation进行Modeling操作。 十、Gateway Service生成1.登记Gateway Service登记Gateway Service后，系统会自动生成以下各类，建议不要修改Class Name **DPC:**数据提供程序类 **DPC_EXT:**数据提供程序类扩展 **MPC:**模型提供程序类 **MPC_EXT:**模型提供程序类扩展 **SRV:**OData服务识别 2.生成类介绍MPC和MPC_EXT：当用户访问该服务的metadata（元数据）时，他们负责把通过ABAP DDIC Structure描述的metadata信息转化为odata协议规范的格式并返回。当对odata进行修改后，点击“generate”图标，MPC的代码会重新生成。如果开发者需要在model上添加一些额外信息时，那么需要在MPC_EXT里通过ABAP代码实现。MPC_EXT是MPC的子类，在重新生成odata时，此部分代码不会被覆盖。 **DPC和DPC_EXT:**包含了odata服务的实现，实际上就是基于OData的CRUD操作。我们通过重新定义DPC_EXT类方法，来实现CRUD。 十一、Gateway Service测试1.测试路径打开OData文件目录下的Service Maintenance 文件，双击GW_HUB点击右侧画面中的SAP Gateway Client按钮。 2.注册Service 在测试时可能会遇到报错说该服务没有注册系统。此时按照图中红框标记的点击Register按钮或使用TCODE &#x2F;IWFND&#x2F;MAINT_SERVICE。 （1）Register 按钮 点击对勾后需要绑定存放Service的包，该界面和下面的绑定包的界面一致。 （2）TOCDE使用TCODE后进入相应的界面，点击上方的Add Service按钮。 点击对应按钮后进入一个新界面，在上方的输入框中输入ODATA中项目的名称并在其后添加“_SRV”，详细的参照下图。 点击注册的按钮需要绑定存放的包。 3.测试注册完成之后，再次点击SAP Gateway Client按钮进入测试界面。 （1）查询数据在界面上选择请求方式为GET的请求方式，因为我们使用的是CDS的方式进行的数据查询，所以不能使用Data Model 中的Entity Types进行数据查询。点击界面上的EntitySets按钮。添加请求的路径为CDS。再点击Add URI Option按钮添加数据格式为’JSON‘格式。最后点击执行按钮Execute。 EntitySets按钮 Add URI Option按钮 执行效果如下图所示 接下来介绍添加筛选条件的查询方式，其实也就是在URI的后面添加关键字filter然后后接字段的筛选条件。 因为我们的筛选条件是查询carrid 字段等于 AA，connid 字段等于0064的数据，所以可以从下面的返回结果集中看到数据确实是所需要的数据。 （2）新增数据新增数据选择的请求方式是POST请求方式。因为我们的新增逻辑是放在重写的实现类中的。所以本次需要使用Data Model 中的Entity Types进行数据的新建操作。和查询数据进行的操作类似，先点击EntitySets按钮。添加请求的路径为想要新建的Entity Types。再点击Add URI Option按钮添加数据格式为’JSON‘格式。最后点击执行按钮Execute。 然后在左下角的框中输入想要新增的数据内容。此处有一个注意事项。在编写Json对象字符串时，使用的是左侧为字段名：右侧为字段值。但是此处的字段名称需要和Data Model 中的Entity Types 的Properties中的字段名称保持一致。下面放上对比图。 接下来放完整的请求JSON对象数据 最后同样点击Execyte按钮可以查看到最后执行的效果图。 数据库查询检测是否成功新建成功。 （3）修改数据因为操作和过程基本都是如出一辙的，所以就直接放出不同的地方URI，另外请求方式需要设置成PUT，修改数据需要在URI中传入修改数据的主键，然后再左下角的框中输入修改的各项字段值即可，本次修改前4个数字字段值为40。 从数据库中也可以查看到对应字段值的修改。 （4）删除数据删除数据和修改数据基本一致，不过请求方式是DELETE。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"OData","slug":"OData","permalink":"https://www.yemaojun.top/categories/OData/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP 杂项知识","slug":"ABAP/ABAP杂项记录/杂项知识收集/杂项知识收集","date":"2023-03-15T11:51:35.000Z","updated":"2023-05-20T13:01:11.631Z","comments":true,"path":"2023/03/15/ABAP/ABAP杂项记录/杂项知识收集/杂项知识收集/","link":"","permalink":"https://www.yemaojun.top/2023/03/15/ABAP/ABAP%E6%9D%82%E9%A1%B9%E8%AE%B0%E5%BD%95/%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/","excerpt":"文档中记录了在日常开发中遇到的小技术和知识点，用于存放暂时没有分类的不足以形成分类的知识。","text":"文档中记录了在日常开发中遇到的小技术和知识点，用于存放暂时没有分类的不足以形成分类的知识。 SAP 杂项知识 一、维护TCODE（SE93）的国际化文本语言1.应用场景新建了一个区域按钮（SE43），要求在英文系统中显示英文描述，韩文系统中显示韩文描述。 2.解决方案（1）先使用TCODE SE63 &#x2F; I18N，此TCODE需要在 S4H 系统中使用，ECC较低版本无法使用。 （2）进入对应TCODE后点击Short Text，查找Transaction。找到之后双击进入 （3）Object Name填写对应的需要维护的TCODE ，然后在下方需要填写原语言与目标语言。选择后点击Edit按钮。 （4）然后就可以维护两种语言版本的描述信息。 （5）还需要传送短文本到CTS中，操作如下 使用TCODE SLXT 在开头填写维护的目标语言 在Transport Request取消勾选Create new Request 在Transport Request的Transport Request填写你要传入的CTS号码 也可以在下方的Time Period中的Processing Date中填写日期信息 在Filter中的Object Processor中填写CTS的创建人名称，可以快速找到CTS并加入。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"ABAP基础","slug":"ABAP基础","permalink":"https://www.yemaojun.top/categories/ABAP%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"OOALV 事件类","slug":"ABAP/OOALV/OOALV事件类/OOALV事件类","date":"2023-02-23T13:18:10.000Z","updated":"2024-07-01T04:25:04.579Z","comments":true,"path":"2023/02/23/ABAP/OOALV/OOALV事件类/OOALV事件类/","link":"","permalink":"https://www.yemaojun.top/2023/02/23/ABAP/OOALV/OOALV%E4%BA%8B%E4%BB%B6%E7%B1%BB/OOALV%E4%BA%8B%E4%BB%B6%E7%B1%BB/","excerpt":"本篇可以说是OOALV的核心篇章，因为不同于Module Pool程序，OOALV是依靠事件驱动的。所以本片详细介绍了OOALV的事件使用方法和与经常与事件一起使用的Module。","text":"本篇可以说是OOALV的核心篇章，因为不同于Module Pool程序，OOALV是依靠事件驱动的。所以本片详细介绍了OOALV的事件使用方法和与经常与事件一起使用的Module。 OOALV 事件类 一、事件类介绍1.概念ABAP OOALV是依靠事件驱动的，而ABAP的Dialog则是依靠屏幕驱动的。怎么理解这一段话？OOALV的用户操作基本都是依靠OOALV的事件类中的逻辑进行的。而Dialog中用户的操作基本都是依靠自定义屏幕中的屏幕逻辑流实现的。 二、OOALV中的Function1.获取光标所在的单元格属性和值（1）方法名GET_CURRENT_CELL （2）介绍该方法用于返回ALV Grid控件中光标所在的单元格属性和值，若没有选择任何单元格则返回Row的值为0。返回时返回两个行和索引号，一个行是现在被选择的行和字段的索引号，另一个是输出表（内表）的行和字段索引号。设置了隐藏字段时，画面上显示的字段顺序与内表顺序不同。 （3）参数 参数 参数类型 参数说明 E_ROW I 返回ALV画面上当前单元格（光标所在单元格）的行的索引值，如果未选择任何单元格，则返回0 E_VALUE C 返回ALV画面上当前单元格的值 E_COL I 返回ALV画面上当前单元格所在列的列名 ES_ROW_ID LVC_S_ROW 返回当前行信息（Index），包含行类型（Rowtype）（如：是否合计行） ES_COL_ID LVC_S_COL 返回当前行信息（Hierlevel），列名（Fieldname）等 ES_ROW_NO LVC_S_ROID 返回当前行信息（Row_id），包含下级行号（Sub_row_id） （4）用例1234567891011121314151617DATA: LV_ROW TYPE I, LV_VALUE TYPE C,&quot;这个值基本不使用 LV_COL TYPE I, LS_ROW_ID TYPE LVC_S_ROW, LS_COL_ID TYPE LVC_S_COL, LS_ROW_NO TYPE LVC_S_ROID.CHECK GO_ALV IS BOUND.CALL METHOD GO_ALV-&gt;GET_CURRENT_CELL IMPORTING E_ROW = LV_ROW E_VALUE = LV_VALUE E_COL = LV_COL ES_ROW_ID = LS_ROW_ID ES_COL_ID = LS_COL_ID ES_ROW_NO = LS_ROW_NO. 2.获取ALV Grid布局信息（1）方法名GET_FRONTEND_LAYOUT （2）介绍返回当前ALV Grid上设置的布局信息。 （3）参数 参数 参数类型 参数说明 ES_LAYOUT LVC_S_LAYO 当前ALV Grid上设置的布局信息 （4）用例1234567DATA: LS_LAYOUT TYPE LVC_S_LAYO.CHECK GO_ALV IS BOUND.CALL METHOD GO_ALV-&gt;GET_FRONTEND_CELLS IMPORTING ES_LAYOUT = LS_LAYOUT. 3.返回所选多个单元格的信息（1）方法名GET_SELECTED_CELLS （2）介绍返回所选多个单元格信息。 和其他编程语言一样，既然有Get方法也就基本会有Set方法，而Set方法的效果不仅仅体现在代码层面，也可以反应在画面上。在画面上的效果其实也就和你选择一个单元格或多个单元格的效果一致。不过不一样的地方就是如果你希望在画面上显示出选择单元格的黄色选中效果则在执行完Set方法之后不可以调用ALV刷新方法。一旦调用刷新方法选中的画面效果就不显示了。 （3）参数 参数 参数类型 参数说明 ET_CELL LVC_T_CELL 存放有选择的单元格的字段名（Col_id）、行索引值（Row_id）和单元格值（Value） （4）用例1234567DATA: LT_CELL TYPE LVC_T_CELL. CHECK GO_ALV IS BOUND.CALL METHOD GO_ALV-&gt;GET_SELECTED_CELLS IMPORTING ET_CELL = LT_CELL. 4.返回所选列的信息（1）方法名GET_SELECTED_COLUMNS （2）介绍返回所选列的信息。 和其他编程语言一样，既然有Get方法也就基本会有Set方法，而Set方法的效果不仅仅体现在代码层面，也可以反应在画面上。在画面上的效果其实也就和你选择一列或多列的效果一致。不过不一样的地方就是如果你希望在画面上显示出选择列的黄色选中效果则在执行完Set方法之后不可以调用ALV刷新方法。一旦调用刷新方法选中的画面效果就不显示了。 （3）参数 参数 参数类型 参数说明 ET_INDEX_COLUMNS LVC_T_COL 返回列名（Fieldname）和层级结构类型（Hierlevel） （4）用例1234567DATA: LT_COLUMNS TYPE LVC_T_COL. CHECK GO_ALV IS BOUND.CALL METHOD GO_ALV-&gt;GET_SELECTED_COLUMNS IMPORTING ET_INDEX_COLUMNS = LT_COLUMNS. 5.返回所选行的信息（1）方法名GET_SELECTED_ROWS （2）介绍返回在OOALV界面左侧点击一个或多个行选择按钮的行信息 和其他编程语言一样，既然有Get方法也就基本会有Set方法，而Set方法的效果不仅仅体现在代码层面，也可以反应在画面上。在画面上的效果其实也就和你选择一行或多行的效果一致。不过不一样的地方就是如果你希望在画面上显示出选择行的黄色选中效果则在执行完Set方法之后不可以调用ALV刷新方法。一旦调用刷新方法选中的画面效果就不显示了。 （3）参数 参数 参数类型 参数说明 ET_INDEX_ROWS LVC_T_ROW 返回行类型（Rowtype）和行的索引（Index） （4）用例1234567DATA: LT_ROWS TYPE LVC_T_ROW.CHECK GO_ALV IS BOUND.CALL METHOD GO_ALV-&gt;GET_SELECTED_ROWS IMPORTING ET_INDEX_ROWS = LT_ROWS. 6.刷新方法（1）方法名REFRESH_TABLE_DISPLAY （2）介绍当内表在执行完事件或对页面有更改的操作后，调用该方法将内表的内容重新加载到页面上，但并不是只要执行完事件就需要调用该方法，具体的情况需要具体分析。 （3）参数 参数 参数类型 参数说明 IS_STABLE LVC_S_STB1 用于设置刷新时行和列保持不变的参数 I_SOFT_REFESH CHAR01 设置排序、筛选和求和等布局不变的参数 （4）用例12345678910111213DATA: LS_STABLE TYPE LVC_S_STB1, LV_SOFT_REFRESH TYPE CHAR01. CHECK GO_ALV IS BOUND.LS_STABLE-ROW = &#x27;X&#x27;.&quot;刷新后行保持不变LS_STABLE-COL = &#x27;X&#x27;.&quot;刷新后列保持不变LV_SOFT_REFRESH = &#x27;X&#x27;.&quot;刷新后保持Sort、Filter、Sum等布局设置CALL METHOD GO_ALV-&gt;REFRESH_TABLE_DISPLAY EXPORTING IS_STABLE = LS_STABLE I_SOFT_REFESH = LV_SOFT_REFRESH. 三、ALV 事件OOALV 是通过事件驱动的，所以事件之于OOALV就相当于人的行动和思想。没有事件进行驱动的OOALV就相当于一个不会做任何事情的人。 1.双击事件（Double Click）（1）触发条件当用户在ALV界面上双击某一行或单元格时触发事件。 （2）事件参数 参数 参数类型 参数说明 E_ROW LVC_S_ROW 双击行的索引 E_CLOUMN LVC_S_COL 双列的字段名 ES_ROW_NO LVC_S_ROID 行ID（ROW_ID）和下级行ID（SUB_ROW_ID） （3）事件示例①事件的定义 ②事件的实现 ③事件的注册1SET HANDLER GO_EVENTS-&gt;HANDLE_DOUBLE_CLICK FOR GO_ALV. ④事件效果演示双击其中一行或单元格会显示你当前单击的行号。 2.热键&#x2F;单击事件（Hotspot）（1）触发条件当用户在ALV上点击在字段目录中设置了Hotspot属性的字段并注册该事件后会触发该事件。设置了Hotspot属性的字段会在其内容下添加下划线，类似于HTML中添加了a标签和URL属性的内容。 （2）事件参数 参数 参数类型 参数说明 E_ROW_ID LVC_S_ROW 单击行的索引 E_COLUMN_ID LVC_S_COL 单击列的索引 ES_ROW_NO LVC_S_ROID 行ID和下级行ID （3）事件示例①事件的定义 ②事件的实现 ③事件的注册1SET HANDLER GO_EVENTS-&gt;HANDLE_HOTSPOT_CLICK FOR GO_ALV. ④事件效果演示 3.添加按钮事件（Toolbar）（1）触发条件该事件没有触发条件，或者说触发条件是在注册然后调用ALV的时候。因为该事件的作用是在ALV上添加自定义按钮。只是添加按钮而不实现按钮的逻辑。设置按钮的逻辑是通过USER COMMAND事件进行设置的。 （2）事件参数 参数 参数类型 参数说明 E_OBJECT CL_ALV_EVENT_TOOLBAR_SET ALV TOOLBAR对象 E_INTERACTIVE CHAR01 交互式调用与否 （3）事件示例①事件的定义 ②事件的实现 ③事件的注册1SET HANDLER GO_EVENTS-&gt;HANDLE_TOOLBAER FOR GO_ALV. ④事件效果演示 4.按钮响应事件（User Command）（1）触发条件当点击Toolbar事件添加的自定义按钮时触发。相关的事件还有AFTER_USER_COMMAND和BEFORE_USER_COMMAND。该事件只有一个参数E_UCOMM。该参数存放的是在添加自定按钮时的Function Code。 （2）事件参数 参数 参数类型 参数说明 E_UCOMM E_UCOMM 接收Toolbar按钮返回的Function Code （3）事件示例①事件的定义 ②事件的实现 ③事件的注册1SET HANDLER GO_EVENTS-&gt;HANDLE_USER_COMMAND FOR GO_ALV. ④事件效果演示 5.修改事件（Data Change）（1）触发条件在ALV中编辑完数据后，按Enter键或移动光标触发。但是这个触发条件有个前提，就是需要注册Enter键和光标移动事件。如果不注册这两个相应事件，Data Change事件依然不会触发。 （2）事件参数 参数 参数类型 参数说明 ER_DATA_CHANGED CL_ALV_CHANGED_DATA_PROTOCOL ALV Data Change对象，包含了变更后的数据信息 E_ONF4 CHAR01 变更后是否由搜索帮助触发 E_ONF4_BEFORE CHAR01 变更后是否由搜索帮助触发（事前） E_ONF4_AFTER CHAR01 变更后是否由搜索帮助触发（事后） E_UCOMM SY-UCOMM 由屏幕上的按钮触发，返回该按钮的Function Code 虽然参数众多，但是实际使用过程中只会使用第一个参数，ER_DATA_CHANGED。因为该对象内部才存有修改后的数据信息。 （3）事件示例①事件的定义 ②事件的实现 ③事件的注册 6.TOP OF PAGE事件（1）触发条件和Toolbar事件一样，没有触发条件，或者说触发条件是调用ALV组件的时候。 （2）事件参数 参数 参数类型 参数说明 E_DYNDOC_ID CL_DD_DOCUMENT 动态文件 TABLE_INDEX SYINDEX Loops,Current Loop Pass （3）事件示例①事件的定义 ②事件的实现 ③事件的注册 ④事件效果演示 7.搜索帮助事件（Onf4）（1）触发条件此处是用于设置OOALV单元格中搜索帮助的事件。 （2）事件参数 参数 参数类型 参数说明 E_FIELDNAME LVC_FNAME 字段的名称 ES_ROW_NO LVC_S_ROID 行ID（ROW_ID） ER_EVENT_DATA CL_ALV_EVENT_DATA 事件数据 （3）事件示例①事件的定义 ②事件的实现 ③事件的注册 ④事件效果演示因为CARRID字段被占用，所以本次使用旁边的字段进行校验。实际效果类似或相同。 8.Button Click（1）触发条件该事件是和Pushbutton一起使用的事件，当在OOALV中设置了Pushbutton，然后点击该按钮后即可触发 （2）事件参数 参数 参数类型 参数说明 ES_COL_ID LVC_S_COL 列的ID信息 ES_ROW_NO LVC_S_ROID 行的索引信息 （3）事件示例①事件的定义 ②事件的实现 ③事件的注册1SET HANDLER GO_EVENTS-&gt;HANDLE_BUTTON_CLICK FOR GO_ALV. ④事件效果演示图片中红色框圈出来的就是通过Layout设置的Pushbutton按钮。点击该按钮就会触发Button Click事件。 四、ALV Grid其他要素1.红绿信号灯（1）步骤虽然OOALV提供了专门设置红绿信号灯的样式设置属性，但是在实际开发过程中也可以通过新增一个ICON ID属性的字段，然后直接设置红绿信号灯的图标样式来实现红绿信号灯的切换效果。 通过OOALV设置的红绿信号的等会出现在ALV的最左侧，这一列将不受字段目录的控制。意味着你无法设置其的然和属性（列名、位置等）。当你在OOALV最左侧需要设置一列CheckBox时或其他需要在最开头有限展示的内容时，通过OOALV自带的设置红绿信号灯的方式并不适合，因为他会显示在CheckBox的前面。 因为红绿信号灯设置的是一行的红绿信号灯样式，所以需要在结构体中新增一个字段用于设置红绿信号灯的样式。 在取数完成后设置红绿信号灯的字段值（1：红色；2：黄色；3：绿色）。 将设置红绿信号灯样式的字段传入Layout的excp_fname字段中，代表该字段是控制红绿信号灯的样式字段。 （2）核心代码参考12345678910111213141516171819202122DATA: BEGIN OF GS_TABLE, .... LIGHT TYPE C, &quot;设置红绿信号灯样式的字段 END OF GS_TABLE.DATA: GT_TABLE LIKE TABLE OF GS_TABLE. LOOP AT GT_TABLE INTO GS_TABLE. IF SY-TABIX &lt; 10. GS_TABLE-LIGHT = &#x27;1&#x27;. ELSEIF SY-TABIX &gt; 10 AND SY-TABIX &lt; 20. GS_TABLE-LIGHT = &#x27;2&#x27;. ELSE. GS_TABLE-LIGHT = &#x27;3&#x27;. ENDIF. MODIFY GT_TABLE FROM GS_TABLE TRANSPORTING LIGHT. CLEAR: GS_TABLE.ENDLOOP.GS_LAYOUT-EXCP_FNAME = &#x27;LIGHT&#x27;. &quot;告诉Layout那个字段是设置红绿信号灯的样式字段... 2.设置行颜色（1）步骤设置行颜色在OOALV中总共分为大致7种大类。此外还可以根据这七大类颜色去设置字体颜色。 和设置红绿信号灯的步骤基本一样，先在结构体中设置一个用于设置行颜色样式的字段，然后填入下面表格中的值用于设置行颜色&#x2F;字体颜色。 值 颜色 值 颜色 值 字体颜色 C100 C110 C101 C200 C210 C201 C300 C310 C301 C400 C410 C401 C500 C510 C501 C600 C610 C601 C700 C710 C701 （2）核心代码参考12345678910111213141516171819202122DATA: BEGIN OF GS_TABLE, .... ROWCOLOR TYPE C LENGTH 4, &quot;设置行颜色样式的字段 END OF GS_TABLE.DATA: GT_TABLE LIKE TABLE OF GS_TABLE.LOOP AT GT_TABLE INTO GS_TABLE. IF SY-TABIX &lt; 10. GS_TABLE-ROWCOLOR = &#x27;C110&#x27;. ELSEIF SY-TABIX &gt; 10 AND SY-TABIX &lt; 20. GS_TABLE-ROWCOLOR = &#x27;C210&#x27;. ELSE. GS_TABLE-ROWCOLOR = &#x27;C310&#x27;. ENDIF. MODIFY GT_TABLE FROM GS_TABLE TRANSPORTING ROWCOLOR. CLEAR: GS_TABLE.ENDLOOP.GS_LAYOUT-INFO_FNAME = &#x27;ROWCOLOR&#x27;.&quot;告诉Layout那个字段是设置行颜色的样式字段... （3）效果演示此处只是演示行颜色设置的效果，与上面的代码逻辑无关。上面的逻辑知识参考使用。 3.设置单元格颜色（1）步骤设置单元格颜色相较于设置列和行颜色会占用更多的资源，所以一般情况下非必要不建议使用。 和上面的步骤差不多，可以参考查看。 （2）核心代码参考123456789101112131415161718192021222324252627DATA: BEGIN OF GS_TABLE, .... CELLCOLOR TYPE LVC_T_SCOL, &quot;设置单元格颜色样式的内表字段 END OF GS_TABLE.DATA: LS_COLOR TYPE LVC_S_SCOL, &quot;设置单元格颜色的结构体 GT_TABLE LIKE TABLE OF GS_TABLE. LOOP AT GT_TABLE INTO GS_TABLE. IF SY-TABIX &lt; 10. LS_COLOR-FNAME = &#x27;FLDATE&#x27;. &quot;设置单元格变色的字段名称 LS_COLOR-COLOR-COL = &#x27;1&#x27;. &quot;所在的列索引 LS_COLOR-COLOR-INT = &#x27;1&#x27;. &quot;设置单元格的颜色 APPEND LS_COLOR TO GS_TABLE-CELLCOLOR. ELSEIF SY-TABIX &gt; 10 AND SY-TABIX &lt; 20. LS_COLOR-FNAME = &#x27;SEATSMAX&#x27;.&quot;设置单元格变色的字段名称 LS_COLOR-COLOR-COL = &#x27;7&#x27;. &quot;所在的列索引 LS_COLOR-COLOR-INT = &#x27;1&#x27;. &quot;设置单元格的颜色 APPEND LS_COLOR TO GS_TABLE-CELLCOLOR. ENDIF. MODIFY GT_TABLE FROM GS_TABLE TRANSPORTING CELLCOLOR. CLEAR: GS_TABLE.ENDLOOP.GS_LAYOUT-CTAB_FNAME = &#x27;CELLCOLOR&#x27;. &quot;告诉Layout那个字段是设置单元格的样式字段... （3）效果演示 4.设置Pushbutton（1）步骤在ALV中将满足条件的单元格设置成Pushbutton，当用户点击该按钮时可以跳转到其他页面或者显示更多的相关信息等，此时会触发ALV Grid的Button Click事件。 步骤基本类似，也是添加字段然后再在Layout中设置样式字段。 （2）核心代码参考1234567891011121314151617181920DATA: BEGIN OF GS_TABLE, .... BUTTON LIKE ICON-ID, &quot;被设置成PushButton样式的字段 STYLE TYPE LVC_T_STYL, &quot;设置PushButton样式的内表字段 END OF GS_TABLE.DATA: LS_STYLE TYPE LVC_S_STYL, &quot;设置PushButton样式的结构体 GT_TABLE LIKE TABLE OF GS_TABLE.GS_TABLE-BUTTON = ICON_WS_PLANE. &quot;设置按钮的图标LS_STYLE-FIELDNAME = &#x27;BUTTON&#x27;. &quot;被设置成PushButton按钮样式的字段名LS_STYLE-STYLE = CL_GUI_ALV_GRID=&gt;MC_STYLE_BUTTON. &quot;ALV Grid中的按钮样式APPEND LS_STYLE TO GS_TABLE-STYLE.&quot;修改内表中所有数据的STYLE BUTTON字段值MODIFY GT_TABLE FROM GS_TABLE TRANSPORTING STYLE BUTTON WHERE CARIID &lt;&gt; &#x27;&#x27;.GS_LAYOUT-STYLEFNAME = &#x27;STYLE&#x27;. &quot;告诉Layout那个字段是设置PushButton的样式字段... （3）效果演示","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"OOALV","slug":"OOALV","permalink":"https://www.yemaojun.top/categories/OOALV/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"OOALV 容器","slug":"ABAP/OOALV/OOALV容器/OOALV容器","date":"2023-02-23T13:17:18.000Z","updated":"2023-06-15T02:33:48.445Z","comments":true,"path":"2023/02/23/ABAP/OOALV/OOALV容器/OOALV容器/","link":"","permalink":"https://www.yemaojun.top/2023/02/23/ABAP/OOALV/OOALV%E5%AE%B9%E5%99%A8/OOALV%E5%AE%B9%E5%99%A8/","excerpt":"接着上一篇继续写容器相关的内容，主要介绍了五种容器类型（自定义容器、对话框容器、Docking容器、拆分容器和细拆分容器）与其相关的特性。","text":"接着上一篇继续写容器相关的内容，主要介绍了五种容器类型（自定义容器、对话框容器、Docking容器、拆分容器和细拆分容器）与其相关的特性。 OOALV 容器 一、容器种类介绍 类别 类名 说明 自定义容器 CL_GUI_CUSTOM_CONTAINER 在使用屏幕编辑器的一般画面上定义一个特定的领域（需手动画出区域）。 对话框控件 CL_GUI_DIALOGBOX_CONTAINER 对话框，或者再全画面上以对话框的形式显示。 Docking容器 CL_GUI_DOCKING_CONTAINER 在屏幕领域的各边角设置的容器，可以调节其大小，是ALV程序开发中经常与自定义控件一起使用的控件。 拆分容器 CL_GUI_SPLITTER_CONTAINER 可以将容器拆分成几部分。 细拆分容器 CL_GUI_EASY_SPLITTER_CONTAINER 和拆分控件功能相同，可以再次拆分已经被拆分的容器，在程序中使用 此外还有一个类，名字叫做容器类，是上面这些容器类的父类（CL_GUI_CONTAINER）。 二、注意事项本次主要介绍容器相关的内容，而这部分的内容主要是在第一章《OOALV 基础知识》的初始化屏幕Model Initial_0100的 From “Create_Container_ALV”中的逻辑。其余部分没有变化。所以主要介绍创建容器From中的内容。其余内容不再复述。 现将公共TOP中的内容展示如下： 三、自定义容器1.容器类CL_GUI_CUSTOM_CONTAINER 2.使用过程（1）创建屏幕0100此过程在前一章《OOALV基础知识》有介绍，此处就不再赘述 （2）定义容器所需要的变量 自定义容器对象变量定义 因为该变量在代码层面只在ALV Grid对象创建时使用，所以写在了局部Form中 “Create_Container_ALV” （3）屏幕绘制容器创建好屏幕后点击Layout按钮打开屏幕的绘制界面 选择红框选中的按钮，在屏幕上画出一个区域，该区域就是你在屏幕上的容器区域。 在画完容器区域之后双击你所画的容器，为其起一个名字，这个名字在后面要作为关联的Key使用。 （4）自定义容器对象的创建12345678910111213&quot;自定义容器对象定义DATA: LO_CCONTAINER TYPE REF TO CL_GUI_CUSTOM_CONTAINER.&quot;自定义容器创建CREATE OBJECT LO_CCONTAINER EXPORTING CONTAINER_NAME = &#x27;CONTAINER&#x27;.ASSIGN LO_CCONTAINER TO &lt;FO_CONTAINER&gt;.CHECK &lt;FO_CONTAINER&gt; IS ASSIGNED.CREATE OBJECT GO_ALV EXPORTING I_PARENT = &lt;FO_CONTAINER&gt;. （5）效果展示 四、自适应容器1.容器类CL_GUI_DOCKING_CONTAINER 2.使用过程（1）创建自适应容器对象1234567891011DATA: LO_DCONTAINER TYPE REF TO CL_GUI_DOCKING_CONTAINER. CREATE OBJECT LO_DCONTAINER EXPORTING REPID = SY-REPID // 当前程序名 DYNNR = SY-DYNNR // 当前屏幕号 EXTENSION = 2000. // 当前长宽ASSIGN LO_DCONTAINER TO &lt;FO_CONTAINER&gt;.... （2）效果展示 五、对话框容器1.容器类CL_GUI_DIALOGBOX_CONTAINER 2.注意事项该容器和上面介绍的两种容器有一定的区别。首先通过名称可以知道该容器是弹出框式的容器。并且没办法绑定GUI Status。在使用过程中也可以不创建屏幕，使用容器父类的静态属性屏幕。这也就是说他所能添加的按钮只能通过事件实现。而且该容器虽然创建出来是一个弹框，但是退出容器的逻辑却需要自己通过事件实现。 3.使用过程（1）创建对话框容器对象因为要通过事件实现退出逻辑，所以将其定义为一个全局对象在TOP中。 123456789101112131415DATA: GO_ACONTAINER TYPE REF TO CL_GUI_DIALOGBOX_CONTAINER.CREATE OBJECT GO_ACONTAINER EXPORTING PARENT = CL_GUI_CONTAINER=&gt;SCREEN0 &quot; 容器父类的屏幕静态属性 CAPTION = &#x27;TITLE&#x27; &quot; 标题 REPID = SY-REPID &quot; 当前程序名 DYNNR = SY-DYNNR &quot; 当前屏幕号 WIDTH = 600 &quot; 对话框的宽度 HEIGHT = 200 &quot; 对话框的高度 TOP = 60 &quot; 距离顶上的距离 LEFT = 500. &quot; 距离左边的距离ASSIGN GO_ACONTAINER TO &lt;FO_CONTAINER&gt;.... （2）退出事件的实现 （3）事件注册 （4）效果展示 六、拆分容器1.容器类CL_GUI_SPLITTER_CONTAINER 2.注意事项拆分容器无法单独创建，必须存在可以分割的容器才可以创建。而允许被分割的容器就是上面讲述的三种容器。必须先创建好上面的三种容器才可以继续使用和创建拆分容器。 本次在使用拆分容器时，将容器分割为两部分。上部分的容器用于实现了TOP_OF_PAGE事件。下面的容器实现了ALV Grid。所以在此处简单的提一下TOP_OF_PAGE事件。 3.使用过程（1）创建拆分容器的对象 （2）拆分容器的创建 （3）TOP OF PAGE事件的实现 定义TOP OF PAGE事件需要使用的容器和变量 TOP_OF_PAGE事件的定义与实现 将展示TOP OF PAGE事件的容器分配好，该过程就是上面使用分割容器进行拆分的过程 注册TOP OF PAGE事件 （4）效果展示 自定义容器 自适应容器 对话框容器 七、细拆分容器1.容器类CL_GUI_EASY_SPLITTER_CONTAINER 2.注意事项在实际开发过程中，一般拆分容器就已经够用了。所以细拆分容器使用的次数很少。 在我的理解中，细拆分容器是作用在拆分容器上的。但最后经过测试发现细拆分容器也可以作用在其他的容器上。所以具体两者的区别是什么可以作为课下去了解的内容进行探究。 3.使用过程（1）细拆分对象的创建在上面拆分容器中我们拆分出来了用于展示TOP OF PAGE的容器，所以我们此次就直接拆分该容器。 （2）效果展示 八、代码参考部分程序名：YTEST_OOALV_CYH (BIO) 1.选择屏幕 2.主程序 3.自定义屏幕的PBO部分 4.自定义屏幕的PAI部分 5.容器创建From","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"OOALV","slug":"OOALV","permalink":"https://www.yemaojun.top/categories/OOALV/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"搜索帮助增强","slug":"ABAP/搜索帮助增强/搜索帮助增强","date":"2023-02-23T13:15:18.000Z","updated":"2023-05-20T13:03:09.452Z","comments":true,"path":"2023/02/23/ABAP/搜索帮助增强/搜索帮助增强/","link":"","permalink":"https://www.yemaojun.top/2023/02/23/ABAP/%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9%E5%A2%9E%E5%BC%BA/%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9%E5%A2%9E%E5%BC%BA/","excerpt":"前段时间在开发时涉及到了标准的搜索帮助出口方面的开发，后面研究了一下，现在将笔记记录如下。","text":"前段时间在开发时涉及到了标准的搜索帮助出口方面的开发，后面研究了一下，现在将笔记记录如下。 搜索帮助增强 一、搜索帮助基本参数的介绍 1.选择方法指定列表的数据来源，可以是数据库表、视图、CDS。如果指定了搜索帮助出口函数则该字段可以不输入，数据来源可以在出口函数中自行定义。 2.对话类型（1）立即显示在调用输入帮助后立即显示筛选清单，通常如果筛选清单只包含一些条目则建议使用该选项。 （2）带有值限制的对话带有筛选和限制约束条件的对话框，类似于选择画面。如果正常情况下清单的条目十分大，则推荐选择该选项。 （3）基于值集的对话如果筛选清单包含的条目小于100个，那么立即显示该筛选清单。如果包含的条目多于100个，则显示限制值用对话框。 3.输入字段的建议搜索如果勾选该字段则不需要调用搜索帮助，在输入字段中直接输入与该字段同名的搜索帮助的输入参数的值，系统会根据你输入的内容在下方显示筛选结果，不过只有数据源内容较少时建议使用。 简单来说，类似于ABAP代码中自定义一个结构体，然后使用结构体名-之后弹出的提示弹框，会根据你后面输入的字母来动态的展示数据。 如上图所示，我在当前的输入框中输入了“ZFI”，下方的弹框就只剩下了ZFI的选项。 4.多列全文搜索可以在输入字段中输入与搜索帮助所有选择参数相关的内容，系统会进行全文搜索，并将结果显示在输入字段下方。 5.精确度值值的范围在0.1至1之间。系统中定义的标准值为0.8（默认值）。值越小表示搜索查询允许的最大错误容差越大，反之1表示搜索必须提供精确匹配。 6.搜索帮助出口此处便是所谓的搜索帮助增强，需要填写一个和函数模块 F4IF_SHLP_EXIT_EXAMPLE有一样的参数.使用出口函数可以使搜索帮助更加灵活。 7.搜索帮助参数如果指定了选择方法,则参数必须是选择方法中的字段.如果使用了出口函数,则随意,但是要指定参数的数据元素. 8.IMP该参数是否为输入参数,用来筛选命中列表 9.EXP该字段是否为输出参数,用来赋值给使用该搜索帮助的输入字段 10.LPOS列表该参数字段在命中列表的位置，即决定字段显示顺序的属性 11.SPOS选择列表该字段在选择屏幕中位置 12.SDIS选择该参数字段在选择屏幕中仅显示，不可编辑，如果该字段被勾选，则必须指定该参数字段的默认值 13.数据元素该字段的参考数据类型，只要设置了字段则为必填项。 14.Modifyed该字段被修改则可以调整参数字段对应的数据元素，但调整的数据元素的数据类型、长度要和选择方法中的数据元素相同。主要用了决定参数字段在命中列表和选择列表中的字段名称。 15.缺省值 包含在省略号中的常数，该常数必须在参量的内部表示中指定。参量的数据类型有一个编辑屏蔽（例如日期和时间）。例如日期1998年3月1日必须定义为‘19980301’。 系统字段。这是DDIC结构SYST的字段，其中的前缀SY-可以用来代替前缀SYST-。 GET参数的标识。 二、表或者结构绑定搜索帮助及字段分配与联动搜索帮助1.建立如下搜索帮助 2.将搜索帮助绑定到自定义结构或者表字段上这一步很重要，因为是实现联动的关键步骤。 3.创建一个程序，定义其选择屏幕如下123PARAMETERS p_werks TYPE zstest-werks.PARAMETERS p_lgort TYPE zstest-lgort.PARAMETERS p_lgobe TYPE zstest-lgobe. 4.选择屏幕输入值现在选择屏幕输入工厂字段的值，对库存地点使用搜索帮助时，工厂字段会自动带入选择屏幕输入的参数WERKS的值。选择命中列表的条目后，会同时填写库存地点与库存地点描述。 三、搜索帮助出口搜索帮助出口可以时搜索帮助更加的灵活，搜索帮助出口函数要求和系统函数F4IF_SHLP_EXIT_EXAMPLE具有相同的参数。复制函数F4IF_SHLP_EXIT_EXAMPLE到自定义的函数，参照F4IF_SHLP_EXIT_EXAMPLE的代码根据需求完成自定义函数的代码。 1.搜索帮助出口方法的参数含义 SHLP：现在使用的搜索帮助相关信息，参数字段，产生字段描述，输入字段选择条件等，是一个结构体； CALLCONTROL：搜索帮助流程控制，若存在输入画面，则部分输入画面的字段值也存在于该变量中； SHLP_TAB：集合帮助下的所有简单搜索帮助相关信息，其内容和结构与SHLP一致； RECORD_TAB：命中清单，即查询返回的记过内表。 增强的出口函数在搜索帮助被调用时会反复执行 2.搜索帮助各个阶段（1）SELONE①官方解释此步骤仅用于集体搜索帮助。它可用于减少SHLP_TAB中给出的基本搜索帮助的数量。SHLP中提供了复合搜索帮助。如果不更改CALLCONTROL-STEP，则下一步是对话框，选择一个基本搜索帮助。如果要跳过此对话框，必须在SHLP中返回选定的基本搜索帮助，并将CALLCONTROL-STEP更改为设置为 “PRESEL” 或 “SELECT”。 ②理解简单理解成，若你的搜索帮助有选择屏幕，则设置选择屏幕内容，描述，顺序等在该阶段。进行完该阶段一般会直接进行到SELECT阶段。 （2）PRESEL①官方解释此步骤允许您在显示选择条件之前或为了完全跳过对话框而影响选择条件。如果要跳过该对话框，应将CALLCONTROL-STEP更改为“SELECT”。在本步骤中，通常只应更改SHLP-SELOPT。 ②理解按照官方的解释，该阶段是用来修改选择屏幕在获取到筛选值后，用于对筛选值进行操作的阶段（SHLP-SELOPT：选择屏幕填之后，会将值以Range表的形式添加进来）。 但是在我实际测试和校验时发现从SELONE阶段执行完毕后会直接跳转到SELECT阶段，即使在SELONE阶段后添加CALLCONTROL-STEP &#x3D; ‘PRESEL’也会在最后变成CALLCONTROL-STEP &#x3D; ‘SELECT’。而且变更SHLP-SELOPT的值其实也可以在SELECT阶段完成。 （3）SELECT①官方解释此步骤可用于跳过数据选择。要跳过标准选择，应按照CALLCONTROL-step中的以下步骤返回“DISP”。通常，此步骤后应填写RECORD_TAB。标准功能模块F4UT_RESULTS_MAP在此步骤中可能非常有用。 ②理解查询数据阶段，因为有该阶段，所以才可以在SE11中不填写数据源，因为数据源可以在出口函数中指定。该阶段如果有选择屏幕带回来的值，则可以通过选择屏幕的值限制查询的内容，然后将结果装填进RECORD_TAB内表。向该内表存值时可以使用Function F4UT_RESULTS_MAP将内表转换成搜索帮助的结果内表。 （4）DISP①官方解释在显示所选数据之前，调用此步骤。例如，您可以根据用户权限修改或减少RECORD_TAB中的数据。如果您希望以后获得标准显示对话框，则不应更改CALLCONTROL-STEP。如果您想自己跳过对话框，则必须在CALLCONTROL-STEP中返回以下值： “return”（如果选择了一行）。所选行必须是record_TAB中仅剩的记录。该行的相应字段将输入屏幕。 如果要返回选择对话框，则选择“EXIT”（退出） 如果要返回到选择对话框，选择“PRESEL”（预设）。 标准功能模块F4UT_PARAMETER_VALUE_GET和F4UT_PARAM ETER_RESULTS_PUT在此步骤中可能非常有用。 ②理解该阶段一般是在显示选择结果前对需要显示的结果进行操作的阶段，也可以在选择完结果之后对部分字段进行填充。 3.搜索帮助增强代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116*&quot;*&quot;本地接口：*&quot; TABLES*&quot; SHLP_TAB TYPE SHLP_DESCT*&quot; RECORD_TAB STRUCTURE SEAHLPRES*&quot; CHANGING*&quot; VALUE(SHLP) TYPE SHLP_DESCR*&quot; VALUE(CALLCONTROL) LIKE DDSHF4CTRL STRUCTURE DDSHF4CTRL*&quot;----------------------------------------------------------------------* EXIT immediately, if you do not want to handle this step IF callcontrol-step &lt;&gt; &#x27;SELONE&#x27; AND callcontrol-step &lt;&gt; &#x27;SELECT&#x27; AND &quot; AND SO ON callcontrol-step &lt;&gt; &#x27;DISP&#x27;. EXIT. ENDIF.*&quot;----------------------------------------------------------------------* STEP SELONE (Select one of the elementary searchhelps)*&quot;----------------------------------------------------------------------* This step is only called for collective searchhelps. It may be used* to reduce the amount of elementary searchhelps given in SHLP_TAB.* The compound searchhelp is given in SHLP.* If you do not change CALLCONTROL-STEP, the next step is the* dialog, to select one of the elementary searchhelps.* If you want to skip this dialog, you have to return the selected* elementary searchhelp in SHLP and to change CALLCONTROL-STEP to* either to &#x27;PRESEL&#x27; or to &#x27;SELECT&#x27;. IF callcontrol-step = &#x27;SELONE&#x27;.* PERFORM SELONE ......... EXIT. ENDIF.*&quot;----------------------------------------------------------------------* STEP PRESEL (Enter selection conditions)*&quot;----------------------------------------------------------------------* This step allows you, to influence the selection conditions either* before they are displayed or in order to skip the dialog completely.* If you want to skip the dialog, you should change CALLCONTROL-STEP* to &#x27;SELECT&#x27;.* Normaly only SHLP-SELOPT should be changed in this step. IF callcontrol-step = &#x27;PRESEL&#x27;.* PERFORM PRESEL .......... EXIT. ENDIF.*&quot;----------------------------------------------------------------------* STEP SELECT (Select values)*&quot;----------------------------------------------------------------------* This step may be used to overtake the data selection completely.* To skip the standard seletion, you should return &#x27;DISP&#x27; as following* step in CALLCONTROL-STEP.* Normally RECORD_TAB should be filled after this step.* Standard function module F4UT_RESULTS_MAP may be very helpfull in this* step. IF callcontrol-step = &#x27;SELECT&#x27;. IF sy-uname = &#x27;PLM-SEAN&#x27;. BREAK-POINT. ENDIF. &quot;RECORD_TAB表的string字段里边包含了三位的空位及按照搜索帮助输出字段位置lpos顺序排列的各个输出字段的合并 SELECT FROM t001l FIELDS concat( concat( concat( mandt ,werks ), lgort ),lgobe ) AS string INTO TABLE @record_tab. SELECT * FROM t001l INTO TABLE @DATA(lt_t001l). &quot;也可以使用系统标准函数F4UT_RESULTS_MAP将源数据绑定到recordtab CALL FUNCTION &#x27;F4UT_RESULTS_MAP&#x27;* EXPORTING* SOURCE_STRUCTURE =* APPLY_RESTRICTIONS = &#x27; &#x27; TABLES shlp_tab = shlp_tab record_tab = record_tab source_tab = lt_t001l CHANGING shlp = shlp callcontrol = callcontrol* EXCEPTIONS* ILLEGAL_STRUCTURE = 1* OTHERS = 2 . IF sy-subrc &lt;&gt; 0.* Implement suitable error handling here ENDIF. callcontrol-step = &#x27;DISP&#x27;.* IF RC = 0.* CALLCONTROL-STEP = &#x27;DISP&#x27;.* ELSE.* CALLCONTROL-STEP = &#x27;EXIT&#x27;.* ENDIF. EXIT. &quot;Don&#x27;t process STEP DISP additionally in this call. ENDIF.*&quot;----------------------------------------------------------------------* STEP DISP (Display values)*&quot;----------------------------------------------------------------------* This step is called, before the selected data is displayed.* You can e.g. modify or reduce the data in RECORD_TAB* according to the users authority.* If you want to get the standard display dialog afterwards, you* should not change CALLCONTROL-STEP.* If you want to overtake the dialog on you own, you must return* the following values in CALLCONTROL-STEP:* - &quot;RETURN&quot; if one line was selected. The selected line must be* the only record left in RECORD_TAB. The corresponding fields of* this line are entered into the screen.* - &quot;EXIT&quot; if the values request should be aborted* - &quot;PRESEL&quot; if you want to return to the selection dialog* Standard function modules F4UT_PARAMETER_VALUE_GET and* F4UT_PARAMETER_RESULTS_PUT may be very helpfull in this step. IF callcontrol-step = &#x27;DISP&#x27;.* PERFORM AUTHORITY_CHECK TABLES RECORD_TAB SHLP_TAB* CHANGING SHLP CALLCONTROL. EXIT. ENDIF. 四、案例教程1.需求说明使用搜索帮助增强制作一个根据数据库表名与字段名的搜索帮助。即：传入一个数据库表名与该数据库表的一个字段名。然后做一个该字段名的搜索帮助。 要求搜索帮助有选择画面，选择画面内容为作为搜索帮助字段的字段与该数据库表的主键字段。在选择数据画面展示的结构为主键字段与搜索帮助字段。 例：输入数据库表名SFLIGHT与字段名CARRID。然后在下面的输入框中点击搜索帮助按钮，弹出选择屏幕，内容为： 在第二行输入0017点击对勾，进入选择数据画面。选择其中一条数据，然后查看结果。 同理，也可以由其他字段使用例如同一张表中的CONNID字段 2.代码示例（1）搜索帮助出口函数 （2）程序选择画面代码 五、参考资料SAP基本搜索帮助及增强出口 标准搜索帮助的增强 SAP 通过出口函数创建搜索帮助（六）","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"搜索帮助出口增强","slug":"搜索帮助出口增强","permalink":"https://www.yemaojun.top/categories/%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9%E5%87%BA%E5%8F%A3%E5%A2%9E%E5%BC%BA/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"OOALV 基础知识","slug":"ABAP/OOALV/OOALV基础知识/OOALV基础知识","date":"2023-02-23T13:15:18.000Z","updated":"2024-07-01T03:45:31.659Z","comments":true,"path":"2023/02/23/ABAP/OOALV/OOALV基础知识/OOALV基础知识/","link":"","permalink":"https://www.yemaojun.top/2023/02/23/ABAP/OOALV/OOALV%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/OOALV%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"最近经常开发OOALV相关的报表程序，所以为了自己能够记住和帮助新手能够更快的掌握OOALV的开发写了这篇笔记。如果能帮到你就好了，后续还有容器和事件相关的内容，敬请期待。","text":"最近经常开发OOALV相关的报表程序，所以为了自己能够记住和帮助新手能够更快的掌握OOALV的开发写了这篇笔记。如果能帮到你就好了，后续还有容器和事件相关的内容，敬请期待。 OOALV 基础知识 一、概要OOALV也被称为面向对象的ALV（ABAP List Viewer）。 1.ALV的功能 排序数据 过滤数据 变更列宽 变更布局 下载Excel等文档 2.ALV的类型 Function ALV OOALV SALV SALV IDA 3.ALV程序的执行顺序 定义内表：定义显示再ALV画面上的内表，存储显示数据； 创建屏幕、容器和Grid对象 设置画面的字段目录 输出内表中的数据 二、SAP 容器1.创建SAP容器及容器对象若要显示ALV页面，有三样元素作为支撑。分别是承载容器和组件的屏幕、划分组件区域的容器和用于展示功能的组件。所以要使一个组件完整的运行下来，需要屏幕、容器和组件三样元素。 2.容器类型 类别 类名 说明 自定义容器 CL_GUI_CUSTOM_CONTAINER 在使用屏幕编辑器的一般画面上定义一个特定的领域（需手动画出区域）。 对话框控件 CL_GUI_DIALOGBOX_CONTAINER 对话框，或者再全画面上以对话框的形式显示。 Docking控件 CL_GUI_DOCKING_CONTAINER 在屏幕领域的各边角设置的容器，可以调节其大小，是ALV程序开发中经常与自定义控件一起使用的控件。 拆分控件 CL_GUI_SPLITTER_CONTAINER 可以将容器拆分成几部分。 细拆分控件 CL_GUI_EASY_SPLITTER_CONTAINER 和拆分控件功能相同，可以再次拆分已经被拆分的容器，在程序中使用 三、使用Docking控件创建OOALV示例1.创建Report程序（1）通过SE38，输入程序名，点击Create按钮创建程序 （2）输入程序描述，和设置程序类型 1 （3）因为是练习程序，所以一般选择的Package都是本地 2.编写程序履历、主界面和对应Include（1）创建好程序第一件事是编写程序履历，各个模块的程序履历不一样，所以我的程序履历仅供参考 （2）编写程序主界面、各Include和选择屏幕事件 3.设置展示的结构（1）本次我们使用 SE11中的 YSFLIGHT表作为展示结构，该表的原型是SE11 中的 SFLIGHT （2）在名字为YTEST_0614_CYH_TOP的Include中创建如下结构 对该结构说明如下： 开头的常量含有一些单个字符例如‘X’ ‘S’ ‘E’等，这些是为了防止Hard Code而设置的。包括下面的一些字段名常量； GV_MESSAGE该变量是一个标记字段，用来设置当程序出现异常时的标记变量； GV_SAVEOK和OK_CODE该变量是用来设置接收屏幕Function Code的变量，用来判断你在屏幕上点击了哪个按钮； 结构体，一般此处用来设置自定义在OOALV 中展示的结构或字段； 内表，类似于上面的结构体，用来存放在ALV上展示的数据，但除此之外还有一些用于其他用途的内表，例如GT_FIELDCATALOG，该内表用来存放字段目录中的内容； 对象，用来设置屏幕容器或ALV GRID对象或事件对象等。 4.设置选择屏幕（1）根据需求定义，一般情况下都是涉及的表的主键 以本例为例子，在表YSFLIGHT中的主键有三个，分别是CARRID、CONNID和FLDATE，所以本次就是用这三个字段作为选择屏幕的字段。 （2）选择屏幕的代码一般放在名字带有SCR的Include中 一般为了保持选择屏幕的整洁、可读性一般会使用SELECTION-SCREEN BEGIN OF BLOCK …等语句，将选择屏幕中相关的字段包在一起。 详细的选择屏幕设置详见报表程序篇。 注：此处变量的名字（S_CARRID）不可以超过8个字符，否则会报错。 设置好选择屏幕字段后还需要设置其在选择屏幕上的显示的名字选择GUI 窗口上方的 Goto –&gt; Text Elements –&gt; Selecyion Texts 注：若是进入后没有能设置的字段，有可能是你的程序没有激活，激活后可见 运行后，选择屏幕的展示效果如下 5.创建屏幕和设置屏幕属性（1）点击Display Object List按钮，或按快捷键C +S + F5 （2）之后左边会出现一个工具栏，整体结构和SE80的结构是一致的，之后再程序名称处右键，选择Create –&gt; Screen （3）选择好按钮之后，会有一个弹框要求你输入屏幕号 注：此处不能使用屏幕号1000，因为该屏幕号有特殊含义，指的是选择屏幕。 （4）设置屏幕的描述和Element List列表中的内容 设置OK_CODE，有关OK_CODE的相关概念请参考上方的 设置展示的结构 中的内容 6.创建容器和ALV Grid对象（1）在主程序界面的End-Of-Selection.事件下方调用我们创建好的屏幕0100 （2）双击上方代码中的屏幕号0100，或在左侧的工具栏中点开Screen文件夹，选择0100屏幕。进入屏幕逻辑流界面 （3）在Process Before Output（后简称为PBO）事件下方新建一个MODULE 在程序中填写下面的代码 123MODULE INITIAL_0100 OUTPUT. PERFORM INITIAL_0100.ENDMODULE. 注：之所以要在此处编写一个PERFORM，是因为在MODULE中定义的所有的变量全部都是全局变量，但是将这些变量放在PERFORM中则会变为局部变量。并且在开发规范中也是要求不允许在MODULE中去定义变量的。 双击该PERFORE的方法名称，创建该PERFORM的FORM到名字带有F01的Include中。然后编写下面的代码。 CREATE_CONTAINER_ALV：用来创建屏幕容器和ALV GRID对象的Perform； GET_FIELDCAT：通过传入的展示画面的结构体获取展示结构属性的Perform； SET_FIELDCAT：自定义展示结构的一些属性，例如修改间距，列标题名等； REGISTRATION_EVENTS：OOALV事件类注册事件的Perform； CALL_ALV_GRID：设置ALV Grid样式、布局、变式和默认展示的按钮以及调用ALV Grid的Perform； REFRESH_ALV：刷新ALV Grid的Perform，当每次有变更时，则需要刷新ALV Grid，使变更的内容更新到界面上。 （4）PERFORM CREATE_CONTAINER_ALV 7.设置ALV Grid对象的属性（1）获取字段目录——GET_FIELDCAT （2）自定义字段目录，用来设置列名、列宽和布局样式（居左、居中和居右）——SET_FIELDCAT （3）注册事件类中的事件，本次因为暂不涉及事件类，所以跳过改内容——REGISTRATION_EVENTS （4）设置ALV GRID对象的布局、变式、默认按钮和调用——CALL_ALV_GRID 设置布局和变式——SET_VARIANT_LAYOUT 设置ALV Grid默认按钮 8.设置GUI Status和GUI Title（1）和创建屏幕的操作类似，创建GUI Status实际就是创建屏幕的功能按钮 在左侧的工具栏出右键程序名，按照 Create –&gt; GUI Status，创建GUI Status 然后会弹出一个框，设置该GUI Status的名称、描述和类型。名称一般建议以G开头，后跟使用该GUI Status的屏幕号 点击完对勾后，或弹出设置GUI Status的页面，设置GUI Status其实就是设置页面上的按钮，详见下图 固定的按钮设置是最下面的设置退出按钮的一栏，可参考下面的图片内容进行设置 注：三个按钮都需要设置为“E”类型，代表是退出按钮。设置成该类型是因为当我们在屏幕中设置了必输字段后，必输字段的校验不会影响E类型退出屏幕的按钮逻辑。若不设置为“E”类型按钮，则这三个按钮与普通的逻辑按钮为同一优先级，当存在必输字段时，屏幕会要求先输入完必输字段和其他的校验逻辑后，参允许点击其他的按钮。这样一来与退出按钮的实际应用不相符，所以需要将这三个退出按钮设置为“E”类型。 设置完成后激活，可以在左侧的工具栏中看到新增了一个GUI Status的文件夹。 （2）同上，创建好的GUI Title其实就是在该页面开头展示的标题内容 点击GUI Title按钮后，会弹出设置GUI Title名称和显示的Title内容的弹框，如下所示 点击绿色的对勾按钮，可以在左侧的工具栏中看到多了一个GUI Title的文件夹 （3）将GUI Status和GUI Title与屏幕绑定 打开“100”屏幕的逻辑流界面，在左侧工具栏展开Screen的文件夹，双击0100屏幕号。将该Module前面的“*”号删除，然后双击该Module的名称，创建该Module到PBO Include中。 该Module创建好后，会有系统生成好两行设置GUI Status和GUI Title的代码。将我们刚刚设置好的GUI Status和GUI Title的名字填充在这，完成绑定。 9.设置屏幕初始化内容详细的初始化内容在上面的第6和7项已经讲过了，此处补充以下，当屏幕的容器和ALV Grid对象创建好后，调用的REFRESH_ALV Perform的内容在此处展示。这段刷新方法也是固定的写法，可以用作模板。 （1）REFRESH_ALV 10.设置退出屏幕的逻辑同上面开始操作一样，打开0100屏幕的逻辑流界面，在 PROCESS AFTER INPUT. 下面创建一个Module。 双击该Module 的名字 EXIT。将该Module 创建在PAI中。 Perfrom中的内容如下。该Perfrom也是固定写法，可用作模板。 11.展示屏幕效果 在主程序界面（左侧工具栏双击程序名）的START-OF-SELECTION 事件下编写获取数据的逻辑。 展示效果如下：","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"OOALV","slug":"OOALV","permalink":"https://www.yemaojun.top/categories/OOALV/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"SAP 二代增强","slug":"ABAP/SAP 增强/SAP 二代增强/SAP二代增强","date":"2023-02-23T13:15:18.000Z","updated":"2023-05-20T13:02:48.823Z","comments":true,"path":"2023/02/23/ABAP/SAP 增强/SAP 二代增强/SAP二代增强/","link":"","permalink":"https://www.yemaojun.top/2023/02/23/ABAP/SAP%20%E5%A2%9E%E5%BC%BA/SAP%20%E4%BA%8C%E4%BB%A3%E5%A2%9E%E5%BC%BA/SAP%E4%BA%8C%E4%BB%A3%E5%A2%9E%E5%BC%BA/","excerpt":"之前面试被人问到了增强相关的内容，后面了解了其中的一种二代增强。其余的几代等后面有空了补齐吧。","text":"之前面试被人问到了增强相关的内容，后面了解了其中的一种二代增强。其余的几代等后面有空了补齐吧。 SAP 二代增强 一、二代增强类型 Ehancement exits：出口增强以Exit_打头，可以在SE37中查看，也可以在数据字典TFDIR(函数表)中查询Exit_打头的函数。 GUI Codes：GUI增强，用于区域菜单和工具菜单栏的增强 Subscreens：屏幕增强，用于子屏幕设计增强 Include Structure增强：用于表结构增强。 二、查找增强的方法1.SAP增强出口检查函数 MODX_ALL_ACTIVE_MENUENTRIES：菜单增强 MODX_FUNCTION_AVTIVE_CHECK：出口函数增强 MODX_MENUENTRY_ACTIVE_CHECK：MENU菜单增强 MODX_SUBSCREEN_ACTIVE_CHECK：屏幕增强 2.查找增强步骤（1）在检查函数打断点 （2）执行需要检查的T&#x2F;C以CV12为例 （3）取得函数名存在多个增强，所以会循环执行多次。可以看见下方的L_FUNCNAME的值为：EXIT_SAPLCSDI_002。 （4）查询MODSAP表通过上面获取到的Function名，到MODSAP表中查询扩展名：PCSD0002。 （5）SMOD（查看增强）&#x2F; CMOD（实施增强）通过事务代码SMOD可以查看并修改该出口对象。 单击工具栏中的“组件”按钮，可以查看该出口对象所包含的组件清单 单击工具栏的执行按钮可以输入出口对象所包含的函数清单，并可以查看该出口对象目前的状态，若该出口对象未被激活，其输出清单将会由红色的图标来表示，否则会显示绿色的图标，可以通过工具栏按钮来激活该对象，可以被激活的对象才可以在程序执行的时候被调用，如下图所示，打勾的部分为已实施的对象。 三、逆向查找函数函数增强的命名方式有其固定的格式： 前四个字母是固定的EXIT 第二部分为程序名 第三个部分为3位数字的序列号 基于函数的出口在程序中通过引用代码“CALL CUSTOMER-FUNCTION &lt;3位数字&gt;”来调用，以VA01的主程序SAPMV45A为例，在程序中查找包含“CALL CUSTOMER-FUNCTION”的字符串，可以找到例如代码“call customer-function ‘003’”，如下图所示： 根据以上命名原则可以判断出该增强出口函数名称为“EXIT_SAPMV45A_003”，通过SE37查询该Function，可以看到该函数中指定了一个预留的程序，名称为“ZXVVAU05”。 程序名“ZXVVAU05”为SAP的预留程序名，以Z开头的程序可以在SAP中直接创建和维护。在代码中双击该程序名，若程序没有被创建，系统将提示在系统中按该名称进行创建新的程序。 四、二代增强实施案例通过CMOD实现销售订单控制实例。 1.创建项目对象使用TCODE：CMOD，进入项目管理维护工具。创建一个对象。 点击创建按钮后进入维护界面，编写描述、选择保存的包和语言等信息。 在属性页面上可以看到在工具栏上有三个按钮。 编辑：在编辑与显示状态中切换 增强分配（Enhancement assignments）：分配增强的组件对象 组件（Parts）：列出组件中所对应的功能函数 2.增强分配进行完上面的操作之后，点击保存按钮。之后点击增强分配按钮，系统进入组件对象维护页面，可以在一个项目中同时输入多个增强组件对象，需要注意的是，一个组件对象只能被引用一次，若在本CMOD项目中被引用了，那么这个组件就不可能在其他的CMOD中输入。 组件对象以“V45A0003”为例。 3.组件列表界面在上述的界面中点击组件按钮，系统将会进入到组件列表界面。该界面将会列出组件包含的功能函数，如组件对象“V45A0003”中维护的功能函数。若同时维护了多个组件对象，则会在该页面中将所有函数对象按照顺序列出来。 从页面中也可以看到组件对象的状态，在组建所对应的列表表头，会有一个只是图标来表示该对象的状态。组件对象必须激活才能使用，若未激活，将会显示一个红色的指示图标。激活后则是一个绿色的图标。在函数一栏，也会有一个图标指示该函数的Include程序是否被激活，具体如上图所示。 4.维护函数以第一个函数“EXIT_SAPMV45A_003”为例，双击该函数名称进入到函数维护界面。双击该函数中预留的程序“ZXVVAU05”。若未创建则创建之。 5.编写增强代码上述Function使用方法与普通Function使用方法相同。 （1）Importing参数： XVBAK：用于保存订单的表头数据。 XVBUK：于保存订单抬头的状态等数据。 XKOMK：用户保存订单中行项目的定价等信息。 （2）Tables参数 XVBKD：保存表头相关凭证信息。 XVBFA：保存行项目凭证流信息。 XVBUP：保存订单行项目物料相关信息。 XVBUP：保存行项目的状态信息。 编写增强逻辑： 123456789DATA LS_XVBKD LIKE LINE OF XVBKD.IF XVBAK-AUART = &#x27;AA&#x27;. LOOP AT XVBKD INTO LS_XVBKD. IF LS_XVBKD-BSTKD IS INITIAL. MESSAGE E000(ZHQ) WITH &#x27;必须输入采购订单编号&#x27;. LVF_SUBRC = &#x27;2&#x27;. ENDIF. ENDLOOP.ENDIF. 变更完成之后需要激活新建的CMOD项目，不然增强内容无法识别。测试结果如下： 五、参考资料SAP ABAP 基于函数的出口CMOD SAP增强的查找方法","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"SAP增强","slug":"SAP增强","permalink":"https://www.yemaojun.top/categories/SAP%E5%A2%9E%E5%BC%BA/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"ABAP中常用函数与系统变量","slug":"ABAP/ABAP杂项记录/ABAP中常用函数与系统变量/ABAP中常用函数与系统变量","date":"2021-03-21T16:12:35.000Z","updated":"2023-05-20T13:00:45.902Z","comments":true,"path":"2021/03/22/ABAP/ABAP杂项记录/ABAP中常用函数与系统变量/ABAP中常用函数与系统变量/","link":"","permalink":"https://www.yemaojun.top/2021/03/22/ABAP/ABAP%E6%9D%82%E9%A1%B9%E8%AE%B0%E5%BD%95/ABAP%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/ABAP%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/","excerpt":"本文档记录了ABAP后续开发中可能常用的函数以及系统变量。仅供参考。","text":"本文档记录了ABAP后续开发中可能常用的函数以及系统变量。仅供参考。 一、常用系统变量（1）SY-PAGNO 当前页号（2）SY-DATUM 当前时间（3）SY-LINSZ 当前报表宽度（4）SY-LINCT 当前报表长度（5）SPACE 空字符（6）SY-SUBRC 执行状态为0表示成功（7）SY-UNAME 用户名（8）SY-UZEIT 当前时间（9）SY-TCODE 当前的事务代码（10）SY-LSIND 列表索引页（11）SY-LISTI 上一个列表的索引（12）SY-LILLT 绝对列表中选定行的行号（13）SY-CUROW 屏幕上的行（14）SY-CUCOL 光标列（15）SY-CPAGE 列表的当前显示页（16）SY-STARO 真实行号（17）SY-LISEL 选择行的内容，长度为255（18）SY-LINNO 当前行（19）SY-INDEX 做无条件循环时的次数值（20）SY-FDPOS 子字符串在源串中的位置 二、常用函数WS_DOWNLOAD :下载表格到本地文件可能没有类的方法高效 RP_LAST_DAY_OF_MONTHS：取月的最后一天 UNIT_CONVERSION_SIMPLE：单位换算 WS_FILENAME_GET：呼叫open dialog的方式 C14B_ADD_TIME：加时间到某年某日 BAPI_CURRENCY_CONV_TO_INTERNAL：将货币转成内部存储值 BAPI_CURRENCY_CONV_TO_EXTERNAL：将货币转成外部储存值 CONVERSION_EXIT_ALPHA_OUTPUT：将数字前的0都去除 NUMERIC_CHECK：判断是否为数字 SPELL_AMOUNT ：将数字转化成文字 TMP_GUI_FILE_OPEN_DIALOG：调用选择文件对话框 ALSM_EXCEL_TO_INTERNAL_TABLE Excel：数据到内部表 CATS_NUMERIC_INPUT_CHECK：数值检查","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"ABAP基础","slug":"ABAP基础","permalink":"https://www.yemaojun.top/categories/ABAP%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"第二章 数据类型","slug":"ABAP/ABAP基础/第二章 ABAP数据类型/第二章ABAP数据类型","date":"2021-03-16T16:16:18.000Z","updated":"2023-05-20T13:01:30.872Z","comments":true,"path":"2021/03/17/ABAP/ABAP基础/第二章 ABAP数据类型/第二章ABAP数据类型/","link":"","permalink":"https://www.yemaojun.top/2021/03/17/ABAP/ABAP%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20ABAP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%AC%E4%BA%8C%E7%AB%A0ABAP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"第二章ABAP数据类型学习！","text":"第二章ABAP数据类型学习！ 第二章 数据类型 2.1 概要 数据类型（Data Type）：定义程序中可以使用的数据类型。 数据变量（Data Variable）参照数据类型定义的、可以存储值的变量。 数据类型与数据变量的定义实例： 1234[Data TYPE]TYPES dtype[TYPE type | LIKE dobj][Data Variable]DATA var [TYPE type | LIKE dobj] 2.1.1数据类型​ 数据类型在ABAP程序中用于定义变量类型。数据类型和数据对象是单独声明的，数据对象则参照数据类型定义。在程序中利用TYPES语句声明数据类型，这种数据类型只能在该程序中使用，因此也称为本地数据类型。 ​ 本地数据类型参照已有的第二章ABAP数据类型进行声明。从数据类型层面考虑，ABAP程序的特点是可以参照ABAP数据字典自身的数据类型定义变量，这种特征便于开发者编程。 2.1.2数据变量​ 数据变量（Data Variable）是在程序中参照数据类型（Data Type）定义的值。在ABAP程序中最常用的方法是用Data语句定义变量。 ​ 数据对象：只有在程序执行期间占用内存物理地址，ABAP语句首先利用数据对象名称确认地址，然后根据参照数据类型的字段长度及小数位等信息解析内容。数据对象里存在没有固定名称的类型，如（WRITE‘ABCDE’）、Text Symbol、（WRITE text-001）、Variable（DATA，STATICS，CLASS-DATA，PARAMETERS）、Constants等类型。 2.1.3数据类型的种类 1.ABAP基本数据类型 ABAP基本数据类型是系统内部定义的数据类型； 同C、Java语言中的c、d、f、i、n类型一样，是系统内部一定义的数据类型。 类型 最大长度 默认长度 初始值 类型 说明 C 1~262143个字符 1字符 空格 字符类型 如果未在DATA语句中指定参数&lt;length&gt;和&lt;type&gt;，则创建长度为1的字符。 N 1~262143个字符 1字符 “0” 数字字符类型 0到9之间字符组成的数字字符串 D 8个字符 &#x2F; “00000000” 日期类型 日期格式必须为 YYYYMMDD T 6个字符 &#x2F; “000000” 时间类型 格式为 24-hour的 HHMMSS I 4bytes 1 0 整数类型 取值范围为：-21477483648~+2147483647。如果运算出现非整型的结果（如小数）则进行四舍五入，而不是截断 F 8bytes &#x2F; 0 浮点类型 小数位最大可以到17位，即可精确到小数点后17位；如果要求高精度，则不应该使用类型 F 数据。而应代之以类型 P 数据；如果值是小数，则要将值使用引号引起来。 P 1~16bytes 8bytes 0 包类型 该类型主要用于商务标准值，如：价格；若小数部分超过长度，则自动按四舍五入将多余的小数除掉；如果整数部分超过长度，则系统运行出错 X 1~524287 bytes 1 byte 十六进制的00 十六进制 类型X是十六进制类型，可表示内存字节实际内容，使用两个十六制字符表示一个字节中所存储的内容。但直接打印输出时，输出的还是赋值时字面意义上的值，而不是Unicode解码后的字符。如果值是字母，则一定要大写，否则赋值不进。 参考链接：1、2 2.局部数据类型（存在于程序内部） 在ABAP程序中用ABAP基本数据类型定义局部数据类型。另外，还可以定义包含多个ABAP基本数据类型的结构体（structure）类型。 1TYPES dtype[TYPE type|LIKE dobj]... 3.全局数据类型（存在于数据字典中） 全局数据类型是指所有程序都可以使用的数据类型。 可以用TYPE语句参照ABAP数据字典里的数据类型定义变量。即SE11创建的ABAP数据字典的对象都可以用于定义数据变量。 2.2 数据类型的声明代码实例1、参考基本数据类型定义变量 1234567DATA:gv_num TYPE i, gv_deci TYPE f, gv_data TYPE d, gv_time TYPE t, gv_text1 TYPE c, gv_text2(2) TYPE c, gv_longtext TYPE string. 2、参考局部数据类型定义变量 将程序中常用的数据及结构声明为一个数据类型，定义变量时可以参照此数据类型定义（C语言中的结构体、java语言中的类只不过没有基本的方法）。此数据类型只能在该程序内部使用 123456789 TYPES:BEGIN OF t_struct,&quot;!t_struct为结构体名字 co11 TYPE c, col2 TYPE i, col3 TYPE d, END OF t_struct.&quot;!以上为声明局部变量（结构体）的过程&quot;！下面为定义数据类型为t_struct的变量的过程 DATA:gs_struct TYPE t_struct, gv var LIKE gs struct-col1. 3、参照全局数据类型定义变量 参照全局数据类型定义变量是指利用ABAP数据字典（表、结构体、数据元素等）定义变量的方法，此数据类型在所有程序中都可以使用。 1234 DATA:gv_carrid TYPE s_carr_id, gv_connid TYPE sflight-carrid, gv_matnr TYPE mara-matnr.&quot;!右边的TYPE类型为全局数据类型 2.3 DATA语句DATA数据类型用于定义数据变量。变量名包括”_“，最长可以定义30位。 1、TYPE type定义数据类型的类型。 1DATA:gv_num TYPE i. 冒号”：“使一个命令从逗号”，“开始执行，遇到句号”.“结束。多次执行相同命令时使用冒号”：“可以避免反复使用相同命令的现象。如声明变量。 2、LIKE num定义与前一个变量相同类型的变量时使用该语句，num可以是任何一种数据类型的变量（字段、参数、结构体、系统变量等）。 1DATA:gv_num1 LIKE gv_num2.&quot;!定义与gv_num1相同数据类型的变量名位gv_num2的变量 3、VALUE int该语句用于定义变量的初始值，若未赋初始值则会使用声明的数据类型的默认初始值（见2.1概要）。 1234DATA:gv_num1 TYPE i VALUE 123, gv_flag VALUE &#x27;X&#x27;, gv_val VALUE IS INITIAL,&quot;!同变量的默认初始值 gv_idx LIKE sy-tabix VALUE 45. 4、LENGTH n用于指定字段长度，但只适用于C（字符类型）、N（数字字符类型）、P（包类型）、X（十六进制）类型。 1DATA:gv_num TYPE n LENGTH 2. 5、DECIMALS n用于指定1~14位小数，只适用于数据类型P。 1DATA:gv_num TYPE p DECIMALS 3. 2.4 ABAP基本语法（注释） ABAP程序使用句号”.“表示一个语句的结束。 代码的注释有两种 符号”*“为行注释。如：*This line is comment 符号” “ “为右注释。如：WRITE gv_val.”Part of line is comment. 字符串使用单引号’ ‘显示。如gv_val &#x3D; ‘Enjoy ABAP’. 命令要使用空格分开。 12gv_val=&#x27;Enjoy ABAP&#x27;. =&gt;错误写法，=与‘之间没有写空格gv_val = &#x27;Enjoy ABAP&#x27;. =&gt;正确写法 2.5 ABAP命名规则（1）SAP规定创建ABAP数据字典的程序及数据对象后命名时，要以Z或Y开头且不能使用如INSERT&#x2F;APPEND等关键字。 （2）ABAP程序中允许定义的变量名最大长度为30位，其中包含“_”符号。 1、定义全局变量 全局变量是指在一个程序或函数内可以访问的数据类型。在程序内部的所有领域都可以参照并修改，因此没有局域性。在程序激活状态下全局变量一直占用着内存地址。定义全局变量时以G开头。 数据类型 前缀 使用实例 程序 字段 V或D GV_CARRID或GD_CARRID DATA GV_SFLGIHT TYPE S_CARR_ID或DATA GD_SFLGIHT TYPE S_CARR_ID 结构体 S GS_SFLIGHT DATA GS_SFLIGHT TYPE SFLIGHT 常量 C GC_RATE CONSTANTS GC_RATE TYPE I VALUE ‘3.14’ 内表 T GT_SFLIGHT DATA GT_SFLIGHT TYPE TABLE OF SFLIGHT 类 O GO_ALVGRID DATA GO_ALVGIRD TYPE REF TO CL_SALV_TABLE RANGE（范围） R GR_CARRID RANGES GR_CARRID FOR SFLIGHT-CARRID 参照变量 F GF_OBJ DATA GF_OBJ TYPE REF TO OBJECT 若需要细分命名规则，则可以把前缀长度设为3位。 前缀1 -&gt; 范围，前缀2 -&gt; 数据类型，前缀3 -&gt; 数据类型 例：GVF_CARRID中G——全局、V——字段、F——浮点型。 2、局部变量 局部变量是指在程序中模块（函数、子程序等为了实现单位功能集合成块的代码）内部有效的变量。 数据类型 前缀 使用实例 程序 字段 V或D LV_CARRID或LD_CARRID DATA LV_SFLGIHT TYPE S_CARR_ID或DATA LD_SFLGIHT TYPE S_CARR_ID 结构体 S LS_SFLIGHT DATA LS_SFLIGHT TYPE SFLIGHT 常量 C LC_RATE CONSTANTS LC_RATE TYPE I VALUE ‘3.14’ 内表 T LT_SFLIGHT DATA LT_SFLIGHT TYPE TABLE OF SFLIGHT 类 O LO_ALVGRID DATA LO_ALVGIRD TYPE REF TO CL_SALV_TABLE RANGE（范围） R LR_CARRID RANGES LR_CARRID FOR SFLIGHT-CARRID 参照变量 F LF_OBJ DATA LF_OBJ TYPE REF TO OBJECT 2.6 ABAP基本数据类型ABAP基本数据类型时ABAP Kernel层次中定义的数据类型，在所有ABAP程序中都可以使用。在程序中定义局部数据类型时可以使用基本数据类型。 1、固定长度的ABAP基本数据类型数字型 初始长度 可变长度 初始值 意义 I 4 4 0 整型（自然数） F 8 8 0 浮点型 P 8 1~~16 0 Packed number 字符型 初始长度 可变长度 初始值 意义 C 1 1~65535 ‘ ’ 文本字段 D 8 8 ‘00000000’ 日期字段（样式：YYYYMMDD） N 1 1~65535 ‘0’ 数字文本字段（数字型字符串） T 6 6 ‘000000’ 样式：HHMMSS 初始长度 可变长度 初始值 意义 X 1 1~65535 X‘0’ 十六进制字段 注意事项： 数据类型D、F、I已经定义了技术属性，因此不用在程序中定义即可直接使用。 要使用数据类型C、N、X时要指定其长度。 数据类型P不指定DECIMALS就无法识别小数位。 2、数字型ABAP&#x2F;4有3种数字类型（数字型）。数字类型的输出方式为靠右对齐。 （1）整数型I 值范围为-2^31（-2147483648）~2^31-1（2147483647）. 只支持整数类型。 非整数型数据会进行四舍五入（Round）。 用于计算行数、条目数、索引值等。 （2）小数型 Packed number of type P 允许有小数位。 可用长度为1~16B，小数位最大长度为14位。 常使用于精度比较高的数据。 计算类型P时，由于涉及软件因素，因此比类型I、F要慢。 可使用关键词LENGTH、DECIMALS进行补充，但值得注意的是P类型在声明时必须使用DECIMALS指定小数位个数。 可变长度一般是指变量名称之后可指定变量长度（1~16）. 1DATA gv_p(16) TYPE p 若不指定长度则默认长度为8B。 1DATA gv_p TYPE p 程序属性设置如下图所示，应选择Fixed point arithmetic。若不选择，类型P就没有意义，与整数类型相同。 注意事项：若在创建程序时不选择上图所示的选框则运行如下代码时会得到结果“231”。 1234567DATA gv_1 TYPE p DECIMALS 1 VALUE &#x27;1.1&#x27;.DATA gv_2 TYPE p DECIMALS 1 VALUE &#x27;2.1&#x27;.DATA gv_3 TYPE p.gv_3 = gv_1 * gv_2.WRITE gv_3.&quot;!实际正确结果为2.31，但由于没有设置上面的属性所以小数点消失了 （3）浮点型F 值范围为1*10^-307~1*10^308。 用于定义指数（exponent），因此需要调用“FLTP_CHAR_CONVERSION”函数把其类型转换成其他数据类型后才可以输出。 类型F转换成二进制时会发生进位误差。 若要显示高精度的数据，则应该使用P类型。 数值较大或者不需要进行四舍五入时可以适用类型F（因为在取近似值时使用，因此使用时需注意）。 因为类型F是以指数形式显示，因此要调用函数“FLTP_CHAR_CONVERSION”把类型转换为其他数据类型后才能输出。 1234567891011121314151617&quot;!输出F类型的举例DATA:gv_float1 TYPE f VALUE &#x27;1.337&#x27;.DATA:gv_float2 TYPE f VALUE &#x27;2.7&#x27;.DATA:gv_fresult TYPE f.DATA:gv_cresult TYPE c LENGTH 16.gv_fresult = gv_float1 * gv_float2.WRITE:/&#x27;5:&#x27;,gv_fresult.CALL FUNCTION &#x27;FLTP_CHAR_CONVERSION&#x27;EXPORTING DECIM = 2 INPUT = gv_fresultIMPORTING FLSTR = gv_cresult. WRITE:/&#x27;6:&#x27;,gv_cresult.“！/代表换行 3、字符类型字符类型总共有4种类型，输出时是居左对齐。 （1）字符类型C 用于定义文字、数字和特殊文字。 定义C类型数据时需要指定其字段长度。如果未指定则默认为1位。 可变的长度为1~65535。 指定C类型长度时可以使用关键字LENGTH或在变量后使用符号”（）“，例：DATA：G_char(3) TYPE c. 若系统只声明了变量单位声明变量类型则默认使用C类型，长度为1位。 1234567891011121314151617181920212223242526272829303132DATA gv_f0.“！此处的gv_f0变量与下面的gv_f1、gv_f2格式等同。DATA gv_f1 TYPE c.DATA gv_f2(1) TYPE c.DATA gv_f3(2) TYPE c.DATA gv_f4 TYPE c LENGTH 2.DATA gv_f5(5).DATA gv_len TYPE i.MOVE:&#x27;CHINA&#x27; TO gv_f0, &#x27;CHINA&#x27; TO gv_f1, &#x27;CHINA&#x27; TO gv_f2, &#x27;CHINA&#x27; TO gv_f3, &#x27;CHINA&#x27; TO gv_f4, &#x27;CHINA&#x27; TO gv_f5. WRITE:/gv_f0, /gv_f1, /gv_f2, /gv_f3, /gv_f4. gv_len = STRLEN(gv_f5).&quot;!获取当前字符串的字符个数。WRITR /gv_len.&quot;!输出结果：”！C”！C”！C”！CH”！CH”！CHINA”！ 5 （2）数字型字符串N 该类型用于显示C类型数字，以字符串形式显示整数。 可变长度为：1~65535。 定义N类型时，当变量长度不足时，加前导零不足位数的形式输出且以字符串形式显示数值。 12345678DATA:gv_num1 TYPE i.DATA:gv_num2 TYPE n LENGTH 4.gv_num1 = 89.WRITE:/gv_num1.&quot;!输出结果：89gv_num2 = 89.WRITE:/gv_num2.&quot;!输出结果：0089 （3）日期类型D和时间类型T 日期类型D默认长度为8位，格式为”YYYYMMDD“。 时间类型T默认长度为6位，格式为”HHMMSS“。 以上两种类型均可直接用来计算。 123456789101112131415*日期类型计算DATA:gv_date TYPE d.gvdate = sy-datum.WRITE:/gv_date.&quot;!20210316gv_date = gv_date + 5.WRITE:/gv_date.&quot;!20210321*时间类型计算DATA:gv_time TYPE t.gv_time = sy-uzeit.WRITE:/gv_time.&quot;!233354gv_time = gv_time - 60.WRITE:/gv_time.&quot;!233254 2.7数学运算符1、基本运算符（演算子） 数字类型I、F、P在数据计算中使用的基本符号及关键字如下表所示。 符号 说明 使用语法 与符号相同的关键字 + 加法 &lt;p&gt; &#x3D; &lt;n&gt; + &lt;m&gt; ADD &lt;n&gt; TO &lt;m&gt; - 减法 &lt;p&gt; &#x3D; &lt;n&gt; - &lt;m&gt; SUBTRACT &lt;n&gt; FROM &lt;m&gt; * 乘法 &lt;p&gt; &#x3D; &lt;m&gt; * &lt;n&gt; MULTIPLY &lt;m&gt; BY &lt;n&gt; &#x2F; 除法 &lt;p&gt; &#x3D; &lt;m&gt; &#x2F; &lt;n&gt; DIVDE &lt;m&gt; BY &lt;n&gt; DIV 取整 &lt;p&gt; &#x3D; &lt;m&gt; DIV &lt;n&gt; MOD 取余 &lt;p&gt; &#x3D; &lt;m&gt; MOD &lt;n&gt; ** 乘幂 &lt;p&gt; &#x3D; &lt;m&gt; ** &lt;n&gt; 2、数字运算用函数 函数 说明 使用例 ABS 返回绝对值 ABS(-100)返回100 SIGN 返回符号 负数返回“-1”，0返回“0”，正数返回“+” CEIL 返回不小于该值的最小整数 ceil(1.3)，ceil(1.7)返回2 FLOOR 返回不大于该值的最大整数 floor(1.3)，floor(1.7)返回1 TRUNC 取得整数部分 trunc(1.3)，trunc(1.7)返回1 FRAC 取得小数部分 frac(‘2.9’)返回0.9 3、Floating-Point函数 函数 功能 ACOS、ASIN、ATAN；COS、SIN、TAN 三角函数 COSH、SINH、TANH 双曲线函数 EXP 指数函数（e&#x3D;2.71828） LOG 自然对数函数 LOG10 常用对数函数（以10为底） SQRT 平方根函数 2.8不定长ABAP基本数据类型在ABAP中不定长的类型是STRING类型。此类型与C类型相似，且定义非常长的字符串时使用。string类型与基本数据类型C的不同之处是当程序执行时生成动态内存。 string类型的属性： 初始长度为0，赋值后长度由复制内容的长度决定。 与java中的string不同，ABAP中的string可随时赋值并修改，相应的长度也会改变。 使用SHIFT（移动）时结果或与C类型不同（先右后左），主要原因就是因为string是不定长的。 字符串相关的常用函数 函数名称 语法规则 说明 FIND FIND p IN text. 查找text变量中是否存在’p’字符，存在sy-subrc返回0，反之返回4 REPLACE REPLACE g IN f WITH INTO p. 将’f’中的内容替换成’p’中的内容，g为f中的内容 TRNSLATE TRNSLTATE c TO LOWER&#x2F;UPPER CASE. 将’c’中的字母进行大小写转换LOWER（小写） SHIFT SHIFT g LEFT&#x2F;RIHGHT. 对’g’中的内容进行左移或右移 CONDENSE CONDENSE c [NO-GAPS]. 去掉空格并向左对齐，选择”NO-GAPS”去掉内容中的所有空格。不选则只去掉内容开头的空格。 OVERLAY OVERLAY c1 WITH c2. 将c1中的空格使用c2中的内容按照对应位置的内容进行填充 CONCATENATE CONCATENATE f1 f2 … fn INTO g. 将f1,f2,…,fn字段按先后顺序拼接在一起存入g变量。 SPLIT SPLIT f AT g INTO h1 h2 … hn 将f中的内容按照g的分割点进行分割后依次存入h1,h2,h3中。 使用实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455DATA:gv_str TYPE string, gv_chr(4) TYPE c. &quot;!FIND查找gv_str = &#x27;ABAP&#x27;.gv_chr = &#x27;B&#x27;.FIND gv_chr IN gv_str.WRITE sy-subrc.&quot;!0WRITE:/.&quot;!IF sy-subrc EQ 0.&quot;! WRITE &#x27;B found&#x27;.&quot;!ENDIF. &quot;!REPLACE替换 gv_str = &#x27;ABAP&#x27;. gv_chr = &#x27;BBAP&#x27;. REPLACE &#x27;ABAP&#x27; IN gv_str WITH INTO gv_chr. WRITE /gv_str.&quot;!BBAP &quot;!TRANSLATE大小写转换 gv_str = &#x27;ABAP&#x27;. TRANSLATE gv_str TO LOWER CASE. WRITE /gv_str.&quot;!abap &quot;!SHIFT移动 gv_str = &#x27;ABAP&#x27; SHIFT gv_str. SHIFT gv_str RIGHT. WRITE /gv_str.&quot;! BAP &quot;!CONDENSE去除空格 gv_str = &#x27; AB AP&#x27;. CONDENSE gv_str. WRITE /gv_str.&quot;!AB AP gv_str = &#x27; AB AP&#x27;. CONDENSE gv_str NO-GAPS. WRITE /gv_str.&quot;!ABAP &quot;!OVERLAY替换填充 gv_str = &#x27; B P&#x27;. gv_chr = &#x27;AAAA&#x27;. OVERLAY gv_str WITH gv_chr. WRITE /gv_str.&quot;!ABAP &quot;!CONCATENATE字符串拼接 gv_str = &#x27;AB&#x27;. gv_chr = &#x27;AP&#x27;. CONCATENATE gv_str gv_chr INTO gv_str. WRITE /gv_str.&quot;!ABAP &quot;!SPLIT分割 gv_str = &#x27;AB,AP&#x27;. SPLIT gv_str AT &#x27;,&#x27; INTO gv_str gv_chr. WRITE:/gv_str,&quot;!AB /gv_chr.&quot;!AP 2.9 Hexadecimal类型Hexadecimal（十六进制）类型是指将1B由2个码位显示的类型。十六进制是为了满足二进制编码形式无法表现的数字而出现的类型。ABAP程序中十六进制主要用于印刷及图片处理部分。 3.0 数字运算符1、基本运算法则 符号 说明 使用例 与符号相同的关键字 + 加法 &lt;p&gt; &#x3D; &lt;n&gt; + &lt;m&gt; ADD &lt;n&gt; TO &lt;m&gt;. - 减法 &lt;p&gt; &#x3D; &lt;n&gt; - &lt;m&gt; SUBTRACT &lt;n&gt; FROM &lt;m&gt;. * 乘法 &lt;p&gt; &#x3D; &lt;n&gt; * &lt;m&gt; MULTIPLY &lt;n&gt; BY &lt;m&gt;. &#x2F; 除法 &lt;p&gt; &#x3D; &lt;n&gt; &#x2F; &lt;m&gt; DIVIDE &lt;m&gt; BY &lt;n&gt;. DIV 取整 &lt;p&gt; &#x3D; &lt;n&gt; DIV &lt;m&gt; MOD 取余 &lt;p&gt; &#x3D; &lt;n&gt; MOD &lt;m&gt; ** 乘幂 &lt;p&gt; &#x3D; &lt;n&gt; ** &lt;m&gt; 部分运算符举例 12345678910111213141516171819202122232425262728293031323334353637383940DATA: gv_int1 TYPE i VALUE 2, gv_int2 TYPE i VALUE 3, gv_iresult TYPE i. *加法 gv_iresult = gv_int1 + gv_int2. WRITE: / gv_iresult. ADD 1 TO gv_result. WRITE: / gv_iresult.&quot;!结果的存储变量为后一个变量 *除法 DATA: gv_pack1 TYPE p DECIMALS 2 VALUE &#x27;2.17&#x27;, gv_pack2 TYPE p DECIMALS 2 VALUE &#x27;5.43&#x27;, gv_presult TYPE p DECIMALS 2. gv_presult = gv_pack2 / gv_pack2. WRITE: / gv_presult. MULTIPLY gv_presult BY gv_pack2. WRITE: / gv_presult.&quot;!结果的存储对象为第一个变量 *乘法 DATA: gv_float1 TYPE f VALUE &#x27;1.337&#x27;, gv_float2 TYPE f VALUE &#x27;2.7&#x27;, gv_fresult TYPE f, gv_cresult TYPE c LENGTH 16. gv_fresult = gv_float2 * gv_float1. WRITE: / gv_fresult. *将F类型的结果转化为C类型进行输出 CALL FUNCTION &#x27;FLTP_CHAR_CONVERSION&#x27; EXPORTING DECIM = 2 INPUT = gv_fresult IMPORTING FLSTR = gv_cresult. WRITE: / gv_cresult. 2、数字运算用函数 函数 说明 使用例 ABS 返回绝对值 ABS(-100)返回100 SIGN 返回符号 负数 -&gt; -1，0 -&gt; 0，正数 -&gt; + CEIL 返回不小于该值的最小整数 ceil(1.3),ceil(1.7)返回2 FLOOR 与CEIL相反 floor(1.3),floor(1.7)返回1 TRUNC 取得整数部分 trunc(1.3),trunc(1.7)返回1 FRAC 取得小数部分 frac(‘2.9’)返回0.9 部分运用函数举例 123456789*ABS绝对值DATA: gv_abs(n) TYPE n VALUE &#x27;-0079&#x27;.gv_abs = ABS(gv_abs).WRITE: / g_abs.&quot;!使用ABS时数字会先转换成I类型，最后以I类型显示*SIGN返回符号DATA: gv_sign TYPE i VALUE 00.gv_sign = SIGN(gv_sign).WRITE: / gv_sign. 参考链接：abap 算术运算函数 3、Floating-Point 函数 函数 功能 ACOS、ASIN、ATAN；COS、SIN、TAN 三角函数（Trigonmetric functions） COSH、SINH、TANH 双曲线函数（Hyperbolic functions） EXP 指数函数（Exponential functions，e &#x3D; 2.7182818285） LOG 自然对数函数（以E为底） LOG10 常用对数函数（以10为底） SQRT 平方根函数（Square root） 4.0 局部数据类型1、声明类型在程序中声明的数据类型视为局部数据类型，利用关键字TYPES声明。 1TYPES dtype [TYPE type|LIKE dobj]... 2、定义结构体类型利用如下语法结构，可以定义由多个字段组成的结构体类型。 12345TYPES BEGIN OF struc_type. ... &#123;TYPES dtype&#125;|&#123;include &#123;TYPE|STRUCTURE&#125;&#125;. ...TYPES END OF struc_type. 以员工信息的结构体举例如下 1234567891011121314151617*声明结构体类型TYPES: BEGIN OF t_ren, name TYPE c LENGTH 20, country TYPE c LENGTH 15, city TYPE c LENGTH 10,END OF t_ten.*定义结构体变量DATA gs_people TYPE t_ren.gs_people-name = &#x27;JANG JONG SUK&#x27;.gs_people-country = &#x27;CHINA&#x27;.gs_people-city = &#x27;Beijing&#x27;.WRITE: / gs_people-name,gs_people-country,gs_people-city.&quot;!输出结果&quot;!JANG JONG SUK CHINA Beijing INCLUDE 关键字 利用 INCLUDE TYPE 语句可以定义嵌套结构体类型（可以理解成JAVA中的继承的概念）。 1234567891011121314151617181920212223242526272829*声明结构体类型TYPES: BEGIN OF t_ren, name TYPE c LENGTH 20, country TYPE c LENGTH 10,END OF t_ten.*定义嵌套结构体类型TYPES: BEGIN OF t_info. INCLUDE TYPE t_ren AS ren.&quot;!此处的AS同数据库的别名，方便区分是继承的结构体字段还是自身定义的结构体字段TYPES: phone TYPE c LENGTH 10,END OF t_info.*下面的定义方式与上面的定义方式意义相同TYPES: BEGIN OF t_info, phone TYPE c LENGTH 10, INCLUDE TYPE t_ren AS ren,END OF t_info.*定义结构体对象DATA gs_people TYPE t_info.gs_people-ren-name = &#x27;JANG JONG SUK&#x27;.gs_people-ren-country = &#x27;CHINA&#x27;.gs_people-ren-cite = &#x27;Beijing&#x27;.gs_people-phone = &#x27;123456789&#x27;.WRITE: / gs_people-ren-name,gs_people-ren-country,gs_people-ren-cite,gs_people-phone.&quot;!输出结果为：&quot;!JANG JONG SUK CHINA Beijing 123456789 注意事项：使用嵌套结构体中的变量时以结构体-结构体-字段名的形式显示。 利用 INCLUDE STRUCTRER 语句，可以把DATA语句定义的结构体或者ABAP数据字典存在的结构体包含到嵌套结构体中。 12345678910111213141516171819DATA: BEGIN OF gs_ren, name TYPE c LENGTH 20, country TYPE c LENGTH 15, city TYPE c LENGTH 10,END OF gs_ren. DATA: BEGIN OF gs_people. INCLUDE STRUCTURE gs_ren AS ren. DATA: phone TYPE c LENGTH 10, END OF gs_people. gs_people-ren-name = &#x27;JANG JONG SUK&#x27;. gs_people-ren-country = &#x27;CHINA&#x27;. gs_people-ren-city = &#x27;Beijing&#x27;. gs_people-phone = &#x27;123456879&#x27;. WRITE: / gs_people-ren-name,gs_people-ren-country,gs_people-ren-cite,gs_people-phone.&quot;!输出结果为：&quot;!JANG JONG SUK CHINA Beijing 123456789 注意事项：使用嵌套结构时，如果不适用AS起别名则在上面的例子中赋值语句与输出语句如下： 12345678gs_people-name = &#x27;JANG JONG SUK&#x27;. gs_people-country = &#x27;CHINA&#x27;. gs_people-city = &#x27;Beijing&#x27;. gs_people-phone = &#x27;123456879&#x27;. WRITE: / gs_people-name,gs_people-country,gs_people-cite,gs_people-phone.&quot;!输出结果为：&quot;!JANG JONG SUK CHINA Beijing 123456789 同样可以输出并使用，但在代码规范上并不规范。 5.0 ABAP数据字典数据类型ABAP数据字典中的数据类型为全局数据类型。ABAP数据字典（表、结构体、数据元素）是在所有程序中都可以用来声明变量的因素。 ABAP数据字典类型大致分为下列3种形式： 表及视图：…TYPE dbtab,…TYPE dbtab-comp 数据类型：数据元素（Data Element）、结构体、表类型 类型组（Type Groups） 可以通过SE11创建、修改及查询ABAP数据字典。 1、参照表、试图声明数据类型可以参照数据库表和视图定义结构体及内表。另外，还可以直接参照表里的字段定义变量。 1234567DATA: gs_sflight TYPE sflight.SELECT SINGLE * FROM sflight INTO gs_sflight WHERE CARRID = &#x27;AA&#x27;.&quot;!从数据库表SFLIGHT中取得编号为AA的数据WRITE: / gs_sflight-CARRID,gs_sflight-CONNID,gs_sflight-FLDATE,gs_sflight-PRICE,gs_sflight-CURRENCY,gs_sflight-PLANETYPE.*输出结果*AA 0017 2011.05.15 1.00 USD America 参照数据库表及视图定义个别字段。 12345678910DATA: GV_CARRID TYPE SFLIGHT-CARRID, GV_CONNID TYPE SFLIGHT-CONNID, GV_FLDATE TYPE SFLIGHT-FLDATE. GV_CARRID = &#x27;AA&#x27;.GV_CONNID = &#x27;0017&#x27;.GV_FLDATE = SY-DATUM.&quot;!当前系统日期WRITE: / GV_CARRID,GV_CONNID,GV_FLDATE.&quot;!输出结果：AA 0017 2011.05.09 2、参照基本数据类型定义变量（1）数据元素（Data Element）ABAP数据字典中用数据元素（Data Element）定义个别字段。数据元素类型是参照域二定义的（可以在数据元素级别上直接定义类型）。一个域可以在多个数据元素中使用，且一个数据元素可以在多个数据表中使用。 12345*利用数据元素定义变量DATA gs_carrid TYPE s_carr_id.gs_carrid = &#x27;AA&#x27;.WRITE: &#x27;Carrid:&#x27;,gs_carrid.&quot;!Carrid:AA （2）利用结构体的TYPE定义需要结合多个表里的字段一并使用时，用结构体定义变量。 1TYPE &lt;dtyoe&gt; TYPE &lt;structure&gt;. （3）利用类型组的TYPE定义类型组是以 INCLUDE 技术为基础的，因此在SAP 4.5A版本以后才开始使用此概念。组合多种数据类型进行声明时使用类型组，它可以在所有程序中使用。 1TYPE-POOLS name. （4）ABAP数据字典类型与ABAP基本数据类型ABAP语言中除了基本数据类型，还存在ABAP数据字典类型。所谓ABAP数据字典类型是指在ABAP数据字典中将经常使用的数据类型事先定义的实例。从开发者角度而言此类型与基本数据类型没有区别。因为在程序执行过程中ABAP解释程序会自动解析。 123*以下两句话都是定义长度为10的字符类型的代码DATA gv_f1(10) TYPE c.DATA gv_f2 TYPE char10. 程序中经常使用的ABAP数据字典类型见下： 6.0 赋值1、给变量赋值在ABAP中定义变量时可以通过VALUE语句赋值初始值，实际处理数据的程序中使用MOVE或WRITE TO 语句给变量赋值。 123456789101112131415*定义变量时赋初始值DATA gv_f1 TYPE i VALUE 10.DATA gv_f2 TYPE i.*使用“=”号赋值gv_f2 = gv_f1.*使用MOVE TO语句赋值MOVE gv_f1 TO gv_f2.*使用MOVE-CORRESPONDING TO 赋值，这种方式可以给结构体变量、内表以及字符串字段值之间赋值MOVE-CORRESPONDING &lt;STRING1&gt; TO &lt;STRING2&gt;.*使用WRITE TO 语句赋值WRITE gv_f1 TO gv_f2[&lt;option&gt;]. （1）MOVE语句① MOVE TO 语句与&lt;f2&gt; &#x3D; &lt;f1&gt;中的Equal（&#x3D;）语句相同。 ② MOVE语句还可以用于类型转换，即&lt;f1&gt;的数据类型会转换成&lt;f2&gt;类型。 ③ 当字段名及顺序不同的结构体之间相互赋值时，如果用MOVE语句，则会按顺序进行赋值。 ④ 在ABAP语言中除了类型D（Date）与类型T（Time）外都可以相互转换类型，一共由64种形态的类型可以相互转换。 （2）MOVE-CORRESPONDING语句① 赋值字符串字段值时可以使用MOVE-CORRESPONDING语句。这时&lt;string1&gt;和&lt;string2&gt;的字段名可以不相同。 ② MOVE-CORRESPONDING语句还经常用于不同结构体之间的赋值，其特点是找到相同的字段名进行赋值。 123456789101112131415DATA: BEGIN OF gs_ren, name(20) VALUE &#x27;Kim Sung Joon&#x27;, country(10) VALUE &#x27;CHINA&#x27;, city(20) VALUE &#x27;Beijing&#x27;,END OF gs_ren.DATA: BEGIN OF gs_info, name(20), city(20), phone(10) VALUE &#x27;1521001234&#x27;,END OF gs_info.MOVE-CORRESPONDING gs_ren TO gs_info.WRITE: / gs_info-name,gs_info-city,gs_info-phone.&quot;!Kim Sung Joon Beijing 1521001234 （3）WRITE TO 语句① 该语句的两种用法是： 输出报表 变量赋值 ② 变量赋值时一般用WRITE TO 语句，将数据对象&lt;f1&gt;转换成C类型后赋值给&lt;f2&gt;（&lt;f1&gt;的类型要能转换成C类型，不然会发生Syntax或runtime error的错误）。 ③ 后面的&lt;option&gt;里可以使用除了UNDER和NO-GAP以外的所有编辑格式选项。 2、offset 赋值语法格式如下： 1MOVE &lt;f1&gt;[+&lt;p1&gt;][&lt;l1&gt;] TO &lt;f2&gt;[+&lt;p2&gt;][&lt;l2&gt;]. 该句式是指从f1字段的p1 + 1位开始截取长度为l1的字符串赋给f2的字段从p2 + 1位开始截取长度为l2的字符串写法。 123456789101112131415161718DATA: f1(8) VALUE &#x27;ABCDEFGH&#x27;, f2(8).MOVE f1+2(3) TO f2.*下面这种语法结构的作用同上f2 = f1+2(3).DATA(f2) = f1+2(3).&quot;!变量声明时使用&quot;!输出结果为：CDEDATA: gv_f1(8) VALUE &#x27;ABCDEFGH&#x27;, gv_f2.DATA: gv_start TYPE i VALUE 2, gv_length TYPE i VALUE 4.CLEAR:gv_f2.&quot;!初始化变量MOVE gv_f1+gv_start(gv_length) TO gv_f2.WRITE: / gv_f2.&quot;!结果为CDEF 3、结构体之间的计算操作结构体之间赋值用MOVE-CORRESPONDING语句，利用下面所示语句可以进行结构体之间的计算操作。 1234ADD-CORRESPONDING &quot;!结构体之间相同字段名的字段进行加法运算SUBTRACT-CORRESPONDING &quot;!结构体之间相同字段名的字段进行减法运算MULTIPLY-CORRESPONDING &quot;!结构体之间相同字段名的字段进行乘法运算DIVIDE-CORRESPONDING &quot;!结构体之间相同字段名的字段进行除法运算 7.0 定义其他变量1、常量程序中经常会使用的值可以定义为常量（constant）。定义常量后在程序内不可以进行修改。 常量一般分为一般常量与结构体常量两种类型。 1234567&quot;! 1.一般常量CONSTANTS c ... VALUE [val|IS INITIAL].&quot;! 2.结构体常量CONSTANTS: BEGIN OF crec, ...END OF crec. 实际代码演示 1234567CONSTANTS: c_company(10) VALUE &#x27;LG CNS&#x27;.CONSTANTS: BEGIN OF c_people, name(20) VALUE &#x27;Zhou Wen Woo&#x27;, country VALUE &#x27;China&#x27;,END OF c_people.WRITE: c_company,c_people-name,c_people-country.&quot;!LG CNS Zhou Wen Woo China 2、静态常量在子程序块（ FORM,FUNCTION）中要持续保存局部变量值时定义为静态常量（STATICS）。即在FROM语句中内用STATICS定义的局部变量值可以保持到程序结束。 1234567&quot;!静态变量STATICS f.&quot;!静态结构体变量STATICS: BEGIN OF struc, ...END OF struc. 接下来用代码来演示静态常量关键字STATICS与普通变量的区别 1234567891011121314151617*静态常量由于可以将值保存到程序结束，所以每次调用函数结束后不会被内存销毁DO 3 TIMES.&quot;!循环 PERFORM call_subr.&quot;!调用函数ENDDO.FORM call_subr. STATICS lv_val TYPE i. lv_val = lv_val + 1. WRITE: / &#x27;STATICS Variable:&#x27;,lv_val.ENDFORM.&quot;!运行结果如下：&quot;!STATICS Variable: 1&quot;!STATICS Variable: 2&quot;!STATICS Variable: 3 123456789101112131415161718*普通常量，每次函数调用结束后都会被消灭初始化DATA: gv_result TYPE i.DO 3 TIMES. PERFORM call_subr.ENDDO.FORM call_subr. DATA lv_val TYPE i . lv_val = lv_val + 1. WRITE: / &#x27;Local Variable:&#x27;,lv_val.ENDFORM.&quot;!运行结果如下：&quot;!Local Variable: 1&quot;!Local Variable: 1&quot;!Local Variable: 1 3、TABLES使用TABLES语句定义ABAP数据字典中的数据表、视图、结构体，会生成与ABAP数据字典具有相同结构的数据对象。 1TABLES &lt;dbtab&gt;. 123456789101112TABLES: scarr.SELECT * FROM scarr. WRITE: / scarr-carrid,scarr-carrname.ENDSELECT.&quot;!运行结果如下：&quot;!AA American Airlines&quot;!AB Air Berlin&quot;!AC Air Canada&quot;!AF Air France&quot;!AZ Alitalia 本代码实例中查询语句SELECT * FROM SCARR INTO SCARR中表与结构体名称相同，因此可以省略INTO SCARR语句。","categories":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"ABAP基础","slug":"ABAP基础","permalink":"https://www.yemaojun.top/categories/ABAP%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"}]},{"title":"JVM初始","slug":"JVM/JVM初始","date":"2020-11-22T08:06:04.000Z","updated":"2020-11-23T02:05:00.108Z","comments":true,"path":"2020/11/22/JVM/JVM初始/","link":"","permalink":"https://www.yemaojun.top/2020/11/22/JVM/JVM%E5%88%9D%E5%A7%8B/","excerpt":"本章是学JVM基本概念所记笔记。","text":"本章是学JVM基本概念所记笔记。 一、JVM初始1、基本概念JVM（java虚拟机）是可运行java代码的虚拟计算机，包括一套字节码指令集，一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接的交互。所以java代码在执行时的速度相较于C语言要慢一些。 2、运行过程java的源文件先通过编译器，编译成相应的字节码文件（.class）文件。而字节码文件又通过Java虚拟机中的解释器被编译成特定机器上的机器码。 简化说明： java源代码——&gt;编译器——&gt;字节码文件 字节码文件——&gt;解释器——&gt;相应平台的机器码文件 3、java跨平台的原因每一种平台的解释器是不同的，但实现的虚拟机是相同的，所以java就通过不同的解释器将编译器编译好的字节码文件再编译成相应平台的机器码文件，如此就可以实现跨平台的能力。 当一个程序开始运行，这是虚拟机就开始实例化，多个线程启动就会存在多个多个虚拟机实例。程序退出或者关闭则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。 4、线程线程指在执行过程中的一个线程实体。JVM允许一个应用并发执行多个线程。 Hotspot JVM中的Java线程与原生操作系统有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好之后就会创建一个操作系统原生线程。 Java线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的CPU上。当原生线程初始化完毕就会调用java线程的run（）方法。当线程结束时，会释放原生线程和Java线程的所有资源。 Hotspot JVM后台运行的系统线程主要有以下几个： 虚拟机线程 这个线程等待JVM到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要JVM位于安全点。这些操作的类型有：stop-the-world垃圾回收、线程栈dump、线程暂停、线程偏向锁解除。 周期性任务线程 这些线程负责定时器事件（中断），用来调度周期性操作的执行 GC线程 这些线程支持JVM中不同的垃圾回收活动 编译器线程 这些线程在运行时将字节码动态编译成本地平台相关的机器码。 信号分发线程 这些线程接收发送到JVM的信号并调用适当的JVM方法处理 二、JVM内存区域1、分类 线程私有区域：程序计数器、虚拟机栈、本地方法区 线程共享区：Java堆、方法区 直接内存 2、线程私有区域线程私有数据区域生命周期与线程相同，依赖用户线程的启动&#x2F;结束而创建&#x2F;销毁在Hotspot VM（虚拟机栈）内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存&#x2F;否跟随本地线程的生&#x2F;死对应。 3、线程共享区域线程共享区域随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁。 4、直接内存直接内存并不是JVM运行时数据区的一部分，但也会被频繁的使用。在JDK1.4引入的NIO提供了基于Channel与Buffer的 IO方式，它可以使用Native函数库直接分配堆外内存，然后使用DierctByteBuffer对象作为这块内存的引用进行操作，这样可以避免在java堆和Native堆中来回复制数据，因此在一些场景中可以显著提高性能。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://www.yemaojun.top/categories/JVM/"}],"tags":[]},{"title":"MySQL语法学习","slug":"MySQL语法学习","date":"2020-09-24T14:24:26.000Z","updated":"2021-02-07T03:01:48.544Z","comments":true,"path":"2020/09/24/MySQL语法学习/","link":"","permalink":"https://www.yemaojun.top/2020/09/24/MySQL%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"本章复习MySQL与其基本概念","text":"本章复习MySQL与其基本概念 SQL基础 一、SQL基本概念1、定义：结构化查询语言（Structred Query Language）其实就是定义了操作所有关系型数据库的规则。 二、SQL通用语法1、SQL语句可以单行或多行书写，以分号结尾； 2、可使用空格和缩进来增强语句的可读性； 3、MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。 4、3中注释 ​ （1）单行注释： – 注释内容或#注释内容 ​ （2）多行注释： &#x2F;* 注释 *&#x2F; 三、SQL分类1、DDL（Data Definition Language）：数据库定义语言 用来定义数据库、表和列等。关键字：create drop alter 2、DML（Data Manipulation Language）：数据库操作语言 用来对数据库中表的数据进行增删改。关键字：insert updata delete 3、DQL（Data Query Language）：数据库查询语言 用来对数据库表中的数据进行查询。关键字：select where 4、DCL（Data Control Language）：数据库控制语言 用来定义数据库的访问权限和安全级别及创建用户。关键字：GRANT REVOKE等。 DDL（操作数据库、表和列） 四、DDL（操作数据库、表和列）1、C（create）：创建 create database if not exists 数据库；character set 编码格式（utf-8）； 2、R（Retrieve）：查询 show database：查询所有的数据库 show create database 数据库名称：查询具体数据库； 3、U（Updata）：修改 alter database 数据库名称 character set 字符集名称：修改字符集； 4、D（Delete）：删除 drop database if exists 数据库名称：如果存在就删除数据库； 5、使用数据库：select database()：查询当前正在使用的数据库名称 use 数据库名称：使用指定的数据库。 五、操作表1、查询表（1）查询某个数据库中所有表的数据：show tables：需要提前使用一个数据库。 （2）查询表结构：desc 表名； 2、创建表（1）语法： ​ create table 表名（ ​ 列名1 数据结构1， ​ 列名2 数据结构2， ​ 列名3 数据结构3 ​ ……… ​ 列名n 数据结构n ​ ） 3、数据类型① 整数类型：int ② 小数类型：double ③ 日期，只包含年月日（yyyy-MM-dd）：date ④ 日期包含年月日时分秒（yyyy-MM-dd HH:mm:ss）：datetime ⑤ 时间戳类型，包含内容与④一致：timestamp （若将来不给该字段赋值或赋值为null，则默认使用当前系统时间来自动赋值） ⑥ 字符串：varchar 姓名最大20个字符 zhangsan 8个字符 张三 2个字符 三种事件类型的区别： data：正如字面意思，只标识日期 datatime：在原来日期的基础上加上了时间（time），所以在原来显示日期的基础上再加上了时间。 timestamp：时间戳 4、删除表（1）删除表：drop table 表名； （2）如果存在就删除表：drop table if exists 表名； 5、修改表（1）修改表名：alter table 表名 rename to 新的表名； （2）修改表的字符集：alter table 表名 character set 字符集名称； （3）添加一列：alter table 表名 add 列名 数据结构； （4）修改列名称 类型：alter table 表名 change 列名 新列名 新数据类型； ​ alter table 表名 modify 列名 新数据类型； 6、删除列alter table 表名 drop 列名； DML（增删改表中的数据） 一、添加数据1、语法：insert into 表名（列名1，列名2，…，列名n） values（数据1，数据2，…，数据n）； 2、注意事项 （1）列名和值要一一对应； （2）如果表名后，不定义列名，则默认给所有列添加值； （3）除了数字类型（整数、小数）其它类型需要使用引号（单双都可以）引起来。 二、删除数据1、语法：delete from 表名 [where条件] 1delete from xuexi where id = 1;--删除xuexi表中id为1的行。 注：若不添加条件则默认删除掉所有记录 三、三种删除表的方式比较（drop、truncate、delete）1、drop（删除表）：删除内容和定义，释放空间。将整个表完全删除，想要再添加数据是不可能的，除非新添加一个表。 drop语句将会删除该表的结构被依赖的约束（constrain）、触发器（trigger）、索引（index）；依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为invalid（无效的）。 2、truncate（清空表中的数据）：删除内容、释放空间但不删除定义（保留表的数据结构）。该语句知识清除表中的所有数据。 truncate table 表名； 3、delete（删除表中的数据）：delete用于删除表中的行。delete语句执行删除的过程是每次从表中删除一行，并且将该行的删除操作作为事务记录在日志中保存，以便进行回滚操作。 注意事项：truncate与不带where的delete只删除表中的数据而不删除表的结构（定义）。 4、truncate table 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用delete。（标识计数值？） 5、对于由foreign key（外键）约束引用的表，不能使用truncate table，而应该使用不带where字句的delete语句。由于truncate table记录在日志中，所以它不能激活触发器。 6、执行速度：drop &gt; truncate &gt; delete 7、delete语句是DML（数据库操作语言），这个操作会放到rollback segement中，事务提交之后才生效；如果有相应的trigger（触发器），执行时将被激发。drop和truncate是DDL（数据库定义语言），操作立即生效，原数据不放到rollback segement中，不能回滚，操作不触发tirgger。 四、rollback segment1、定义：是数据库中的一些存储空间。它用来保存数据库数据发生改变时的先前值。 2、主要目的： （1）如果因为某种原因或其他用户想要通过ROLLCACK来取消一个人的数据操作，数据就会复原到改变时的值。这种情况只在transaction（交易）的过程中有效，如果用户执行了COMMIT（事务提交）命令，那么ROLLBACK SEGMENT里面的值就会标识为失效的，数据改变就将永久化。 （2）另一个目的是当有并发的session访问了一个数据值改变但事务还没有提交的表。如果一个SELECT语句开始读取一个表同时一个事务也在修改这个表的值，那么修改前的值就会保存到ROLLBACK SERMENT里面，SELETC也是从ROLLBACK SEGMENT里面读取表的值。 五、修改数据1、语法：uodate 表名 set 列名1 &#x3D; 值1，列名2 &#x3D; 值2 ，…，[where条件] 1update xuexi set age = 19 where id = 3;--修改xuexi表中id为3的age为19. 2、注意事项：若不添加任何where条件则修改表中所有age的值为19。 DQL（数据库查询语言） 一、基础查询1、基础语法：​ SELECT 字段列表（聚合函数、列名） ​ FROM 表名列表 ​ WHERE 条件列表 ​ GROUP BY 分组字段 ​ HAVING 分组之后的条件 ​ ORDER BY 排序 ​ LIMIT 分页限定 2、基础查询（1）多个字段的查询 ① 语法：select 字段1，字段2….. from 表名 ② 注意：若要查询所有字段，则可以使用*来替代字段列表 （2）去除重复查询结果 ① 关键字：distinct ② 例：select distinct 列名 from 表名 （3）计算列 ① 一般可以使用四则运算计算一些列的值。（一般只会进行数值型计算，且null参与的计算，计算结果为null） ② ifnull（表达式1，表达式2）： ​ 表达式1：那个字段需要判断是否为null ​ 表达式2：如果该字段为null后的替换值 （4）起别名 ① 关键字：as 也可以由空格代替 ② 例：select 列名1 as 别名，列名2 + 列名3 （我是空格） 别名 from 表名; 3、条件查询（where）（1）where字句后跟条件 （2）运算符 ​ ① &gt;，&lt;，&lt;&#x3D;，&gt;&#x3D;，&#x3D;，&lt;&gt;（不等于） 例：select * from 表名 where age &lt;&gt; 20;查询表中所有年龄不等于20的行 ​ ② BETWEEN …… AND …… 表示某个条件在某个范围内 例：select * from 表名 where age between 20 and 30;查询年龄在20到30之间的行 ​ ③ IN（集合）：表示多个值，使用逗号分隔 例：select * from 表名 where age in(22,18,25);查询年龄为22，18，25的数据 ​ ④ LIKE‘ ‘：模糊查询 ​ ⑤ is null：查询某一列为null的值 例：select * from 表名 where 列名 is null； ​ ⑥ is not null：查询某一列不为null的值。 ​ ⑦ 逻辑运算符 **and或&amp;&amp;**：与 **or或||**：或 not或！：非 （3）模糊查询 ① 占位符： ​ **_**：单个任意字段 ​ **%**：任意多个字段 ② 例 12345查询姓马的人： select * from 表名 where name like’马%‘；查询姓名第二个字为化的人： select * from 表名 where name like’_马%‘;查询姓名为三个字的人： select * from 列名 where name like’_ _ _‘； 二、排序查询1、语法：order by 排序字段1 排序方式1，排序字段2 排序方式2… 先按照字段1进行排序，若1结果相同则按照2进行排序 2、排序方式（1）升序：ASC（默认） （2）降序：DESC 3、注意事项：如果有多个排序条件，则当前边条件值一样时，才会判断第二条件 三、聚合函数1、定义将一列数据作为一个整体，进行纵向的计算 2、分类（1）count：计算个数 例：select conut(列名) from 表名;计算表中这列的总数 （2）max：计算最大值 （3）min：计算最小值 （4）sum：计算和 （5）avg：计算平均值 3、注意事项聚合函数是排除null值的，即统计的列中如果有一条数据为null则不会统计这一列。可以使用ifnull(表达式1，表达式2)解决 count(*)表示只要有一列数据不为null都是要统计的。 四、分组查询1、语法select 聚合函数 from 表名 group by 列名 例：按照性别分组，分别查询男女同学的平均分和人数 select sex，avg(math),count(id) from 表名 group by sex； 2、注意事项分组之后查询字段：分组字段，聚合函数 3、where和having的区别（1）where在分组之前进行限定，如果不满足条件，则不参与分组 （2）having在分组之后进行限定，如果不满足结果，则不会被查询出来 （3）where后不可以跟聚合函数，having可以进行聚合函数的判断 例：按照性别分组，分别查询男、女的平均分、人数。要求分数低于70的人不参与分组。分组之后，人数要大于2个人 select sex,avg(math),count(id) from 表名 where math &gt; 70 having count(id) &gt; 2; 三、分页查询1、语法select 列名 from 表名 limit 开始索引,每页查询的条数; 例：每页显示3条记录 select * from student limit 0,3;–第一页 select * from student limit 3,3;–第二页 2、公式开始的索引 &#x3D; （当前页码 - 1） * 每页显示的条数 limit是mysql的“方言”。 约束 一、约束（概念）1、定义：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 2、分类（1）主键约束：primary key （2）非空约束：not null （3）唯一约束：unique （4）外键约束：forgin key 二、非空约束（not null）12345678910--1、创建表时添加约束create table abc(a1 int not null)--2、创建完表之后添加非空约束alter table 表名 modify 列名 数据类型 not null;--3、删除非空约束alter table 表名 modify 列名 数据类型 三、唯一约束（unique）12345678910--1、创建表时添加约束create table abc(a1 varchar(20) unique)--2、创建完表后，添加唯一约束alter table 表名 modify 列名 数据类型 unique--3、删除唯一约束alter table 表名 drop index 列名; 注意事项： mysql中唯一约束限定的列的值可以有多个null（可以通过添加非空约束解决） 当要添加唯一约束的列中有重复元素时，约束会添加失败 四、主键约束（primary key）1、注意事项（1）含义：非空且唯一 （2）一张表只能有一个字段为主键 （3）主键就是该表中记录的唯一标识 2、约束添加方式12345678910--1、在创建表时添加create table abc(a1 varchar(20) primary key)--2、创建完表后设置主键alter table 表名 modify 列名 数据类型 primary key;--3、删除主键alter table 表名 drop primary key; 3、自动增长（1）概念：如果某一列是数值类型的，使用auto_inrement可以来完成值的自动增长 （2）添加方式： 1234567--1、创建表的时候添加--2、添加自动增长alter table 表名 modify 列名 数据结构 auto_increment;--3、删除自动增长alter table 表名 modify 列名 数据结构; 五、外键约束（foreign key）1、约束添加方式1234567--1、建表时添加create table 表名( 外键列 constraint 外键名称 foreign key 外键列名称 references 主键名称（主键名称）)--2、创建表后添加外键约束table 表名 add constraint 外键名称 foreign key 外键列名称 references 主键名称(主键名称) 2、级联操作（1）当对一个外键的主表中的数据进行修改时，关联的外键的值也会相应的修改 （2）添加级联操作 ① 语法： 123alter table 表名 add constraint 外键名称foreign key(外键字段名称) references 主表名称（主表列名称）on update cascade on delete cascade; （3）分类 ① 级联更新： 1on update cascade ② 级联删除 1on delete cascade 数据库的设计 二、多表之间的关系","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.yemaojun.top/categories/MySQL/"}],"tags":[]},{"title":"计算机操作系统（一）","slug":"计算机操作系统/计算机操作系统（一）","date":"2020-09-15T12:58:39.000Z","updated":"2020-09-15T15:10:46.901Z","comments":true,"path":"2020/09/15/计算机操作系统/计算机操作系统（一）/","link":"","permalink":"https://www.yemaojun.top/2020/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"本章主要记录了分时操作系统","text":"本章主要记录了分时操作系统 一、中断技术1、中断技术CPU在接收到外部信号（中断信号）后，停止当前工作，转去处理该外部事件，处理完毕之后回到原来的工作中断处（断点）继续原来的工作。 2、通道技术专门处理外设与内存之间的数据传输的处理机。 二、分时技术1、概念主机以很短的“时间片”为单位，把CPU轮流分配给每个终端使用，直到全部作业被运行完。 由于时间片很短，在终端数量不多的情况下，每个终端都能很快重新获得CPU，使得每个终端都能得到及时响应。 等待周期 &#x3D; 时间片 x 终端数量 2、特点 多路调制性 多用户联机使用同一台计算机 独占性 用户感觉独占计算机 交互性 及时响应用户的请求 三、操作系统的基本组成1、操作系统的基本功能（1）进程管理：其主要工作是进程调度，在单用户任务的情况下，处理器仅为一个用户的一个人物所独占，进程管理的工作十分简单。但在多道程序或多用户的情况下，组织多个作业时，就要解决处理器的调度、分配和回收等问题。 （2）存储管理分为几种功能：存储分配、存储共享、存储保护 、存储扩张。 （3）设备管理分有以下功能：设备分配、设备传输控制 、设备独立性。 （4）文件管理：文件存储空间的管理、目录管理 、文件操作管理、文件保护。 （5）作业管理是负责处理用户提交的任何要求。 2、操作系统的功能分类（1）实时系统：指系统可以快速的对外部命令进行响应，在对应的时间里处理问题，协调系统工作。 （2）批处理系统：批处理系统能够提高资源的利用率和系统的吞吐量。 （3）分时系统：可以实现用户的人机交互需要，多个用户共同使用一个主机，很大程度上节约了资源成本。 分时系统具有多路性、独立性、交互性、可靠性的优点，能够将用户-系统-终端任务实现。 （4）网络操作系统等：是一种能代替操作系统的软件程序，是网络的心脏和灵魂，是向网络计算机提供服务的特殊的操作系统。借由网络达到互相传递数据与各种消息，分为服务器及客户端。而服务器的主要功能是管理服务器和网络上的各种资源和网络设备的共用，加以统合并控管流量，避免有瘫痪的可能性，而客户端就是有着能接收服务器所传递的数据来运用的功能，好让客户端可以清楚的搜索所需的资源。 3、主要操作系统体系结构（1）简单体系结构 （2）单体内核结构 （3）层次结构 （4）微内核结构 （5）外核结构 4、操作系统的组成部分（1）驱动程序：最底层、直接控制和监视各类硬件的部分，它们的职责时隐藏硬件的具体细节，并向其他部分提供一个抽象的、通用的接口。 （2）内核：操作系统之最内核部分，通常运行在最高特权级，负责提供基础、结构性的功能。 （3）接口库：是一系列特殊的程序库，它们的职责在于把系统提供的基本服务包装成应用程序所能够使用的编程接口（API），是最靠近应用程序的部分。例如：GNU C运行期库就属于此类，它把各种操作系统的内部编程接口包装成ANSI C和POSIX编程接口的形式。 （4）外围：所谓外围，是指操作系统中除以上三类以外的所有其它部分，通常是用于提供特定高级服务的部件。例如：在微内核结构中，大部分系统服务，以及UNIX&#x2F;Linux中各种守护进程都通常被划归此列。","categories":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://www.yemaojun.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"IDEA快捷键总结","slug":"IDEA快捷键总结","date":"2020-09-05T07:41:25.000Z","updated":"2020-09-05T07:44:06.750Z","comments":true,"path":"2020/09/05/IDEA快捷键总结/","link":"","permalink":"https://www.yemaojun.top/2020/09/05/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/","excerpt":"编程过程中有很多十分繁琐的操作，但通过快捷键可以简化操作。本篇主要收集自己的IDEA的快捷键。","text":"编程过程中有很多十分繁琐的操作，但通过快捷键可以简化操作。本篇主要收集自己的IDEA的快捷键。 一、源码阅读快捷键总结1234567891011121314151617* Java 单继承, 多实现 ！！！* idea 快捷键：* 查询类或接口中的所有方法： Alt + 7* 查询类或接口中的所有方法： Ctrl + F12 (按两次可以看见所有直接能够调用的方法)* 查询所有继承过或者实现过的该类的所有类： Ctrl + H* 查询该类继承过的所有类： Ctrl + H* 查询该接口被继承和实现类的关系图： Ctrl + H* 查询所有实现或继承过该类的接口或类： Ctrl + Alt + B* 查询该项目存在的字符串： Ctrl + Shift + F* 查询该页面存在的字符串： Ctrl + F* 替换本项目所有字符串： Ctrl + Shift + R* 替换该页面存在的字符串： Ctrl + R* 最常用的快捷键(联想类,实现类等)： Alt + Enter* 查看该类的所有方法： Ctrl + O* 复制一行或者复制选中内容： Ctrl + D* 剪切一行或者剪切选中内容： Ctrl + X* 移动一行或者移动选中内容： Shift + Alt + 上下方向箭头 参考资料：idea 查看源码及编程常用快捷键 (自己总结)","categories":[{"name":"IDEA快捷键","slug":"IDEA快捷键","permalink":"https://www.yemaojun.top/categories/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"tags":[]},{"title":"校招Java 面试总结（一）","slug":"面试总结/校招Java面试/面试总结（一）","date":"2020-08-29T01:42:56.000Z","updated":"2023-03-05T23:03:20.954Z","comments":true,"path":"2020/08/29/面试总结/校招Java面试/面试总结（一）/","link":"","permalink":"https://www.yemaojun.top/2020/08/29/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E6%A0%A1%E6%8B%9BJava%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"主要用来记录面试过程中遇到的问题。","text":"主要用来记录面试过程中遇到的问题。 一、java语言的缺点1、运行速度慢Java的运行依赖于java虚拟机（JVM），所以相比于（汇编、C、C++）再电脑上的运行速度慢，因为它不是直接执行机器码。 2、无法操作操作系统的底层由于java要考虑跨平台特性。所以java不能像汇编语言、C语言那样更加接近操作系统。也就不能和操作系统的底层打交道。但可以通过java的JNI（即java的本地接口。也就是利用java语言调用，当前系统上其他程序语言“汇编语言或C语言”等所编写的程序）技术，解决这一问题，但也只是解决了一部分问题。 二、数据结构的排序算法中，哪些是稳定的排序算法快速排序、希尔排序、堆排序、直接选择排序不是稳定的排序算法。 基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。 首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai &#x3D; Aj, Ai原来在位置前，排序后Ai还是要在Aj位置前。 其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。 1冒泡排序冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 2选择排序选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 3插入排序插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。 4快速排序快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;&#x3D; a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;&#x3D; j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。 5归并排序归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个元素(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。 6基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。 7希尔排序(shell)希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 8堆排序我们知道堆的结构是节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n&#x2F;2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n &#x2F;2-1, n&#x2F;2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n&#x2F;2个父节点交换把后面一个元素交换过去了，而第n&#x2F;2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。 以上内容摘自：百度百科 三、解决哈希冲突的方法1、拉链法（链地址法）（1）拉链法解决Hash冲突的方法拉链法解决Hash冲突的做法是：将所有关键字为同义词的节点链接在同一个单链表中。若选定的散列列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组T[0….m-1]。凡是散列地址为i的节点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于一，但一般均取α ≤ 1. （2）拉链法的优点与开放地址法相比，拉链法的优点 （1）拉链发处理冲突简单，且无堆积现象，即非同义词绝不会发生冲突，因此平均查找长度较短； （2）由于拉链法中各链表上的节点空间是动态申请的，所以它更适合于造表之前无法确定表长的情况； （3）开放地址法为减少冲突，要求装填因子α较小，所以当节点规模较大时会浪费很多空间。而拉链法中可取α ≥ 1，且节点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； （4）在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 （3）拉链法的缺点指针需要额外的空间，所以当节点规模较小时，开放地址法更加的节省空间。 2、开放地址法（1）开放地址法解决哈希冲突的方法当冲突发生时，使用某种探查（亦称探测）技术在散列表中形成一个探查序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开发的地址（即该地址的单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的地址则表明表中无待查的关键字，即查找失败。 注意事项： 用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。 空单元的表示与具体的应用相关。 （2）开放地址法分类① 线性探查法(Linear Probing) 基本思想： 将散列表T[0…m-1]看成是一个循环向量，若依次探查的地址为d（即h(key) &#x3D; d），则最长的探查序列为： d、d + 1、d + 2、…、m - 1、0、1、…、d - 1 即探查时从地址d开始，首先探查T[d]，然后依次探查T[d + 1]，…，直到T[m - 1]，此后又次循环到T[0]，T[1]，…，直到探查到T[d - 1]为止。探测终止于以下三种情况： 若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）； 若探查的单元中含有key，则查找成功，但对于插入意味着失败； 若探查到T[d - 1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败（此时表满）。 利用开放地址法的一般形式，线性探查法的探查序列为： hi=(h(key)+i)％m 0≤i≤m-1 //即di=i 线性探查法缺点： 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。 ② 线性补偿探测法 线性补偿探测法的基本思想： 将线性探测的步长从 1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为： j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。 【例】 PDP-11 小型计算机中的汇编程序所用的符合表，就采用此方法来解决冲突，所用表长 m ＝ 1321 ，选用 Q ＝ 25 。 ③随机探测 随机探测的基本思想： 将线性探测的步长从常数改为随机数，即令： j ＝ (j ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。 四、Spring和SpringBoot的区别SpringBoot：简述SpringBoot和Spring的区别 Spring和SpringBoot比较，解惑区别 Spring Boot只是Spring本身的扩展，使开发，测试和部署更加方便。 五、类与接口的区别1、成员不同类中的成员可分为：成员变量、成员常量、成员方法（可以有抽象方法、静态方法、普通的方法） 接口中的成员可分为：只有常量（由public static final）和抽象方法（由public abstract static修饰） 注意事项：接口中没有构造器，但类中可以由构造器 2、类与接口之间的关系不同类与类的关系：单继承与多层继承（extends） 类与接口的关系：类可以实现接口（implements） 接口与接口的关系：单继承与多层继承 3、设计理念的区别抽象类：对类的抽象，包括属性和行为 接口：对行为的抽象，主要是行为 六、面向对象的六大原则1、单一原则一个类应该有且只有一个变化的原因。单一职责原则将不同的职责分离到单独的类，每一个职责都是一个变化的中心。需求变化时，将通过更改职责相关的类来体现。如果一个类拥有多于一个的职责，则多个职责耦合在一起，会有多于一个原因来导致这个类发生变化。一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，影响复用性。 2、里氏替换原则就是要求继承是严格的is-a关系。所有引用基类的地方必须能透明地使用其子类的对象。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。 3、依赖倒置原则（1）高层模块不应该依赖底层模块。两者都应该依赖抽象。 （2）抽象不应该依赖细节，细节应该依赖抽象。 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。低层模块尽量都要有抽象类或接口，或者两者都有。变量的声明类型尽量是抽象类或接口。 4、接口隔离原则一个类对于另外一个类的依赖应该建立在最小的接口上。 一个类对另一个类的依赖应该建立在最小的接口上,通俗的讲就是需要什么就提供什么，不需要的就不要提供。接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。 5、迪米特原则（最小知识原则）最少知识原则又称为迪米特原则英文全称为Law of Demeter，简称LOD，虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 6、开闭原则开闭原则是指：一个软件、一套系统在开发完成后，当有增加或修改需求时，应该对拓展代码打开，对修改原有代码关闭。 对修改关闭，对扩展开放。在软件的生命周期内，因为变化，升级和维护等原因需要对软件原有代码进行修改，可能会给旧代码引入错误，也有可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现。不过这要求，我们要对需求的变更有前瞻性和预见性。其实只要遵循前面5中设计模式，设计出来的软件就是符合开闭原则的。 七、死锁的原因1、竞争资源引起进程死锁当系统中供多个进程共享的资源如打印机、公用队列的等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。 2、可剥夺资源和不可剥夺资源系统中的资源可以分为两类，一类是可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。例如，优先权高的进程可以剥夺优先权低的进程的处理机。又如，内存区可由存储器管理程序，把一个进程从一个存储区移到另一个存储区，此即剥夺了该进程原来占有的存储区，甚至可将一进程从内存调到外存上，可见，CPU和主存均属于可剥夺性资源。另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。 3、竞争不可剥夺资源在系统中所配置的不可剥夺资源，由于它们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷于僵局。例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。假定PI已占用了打印机R1，P2已占用了磁带机R2，若P2继续要求打印机R1，P2将阻塞；P1若又要求磁带机，P1也将阻塞。于是，在P1和P2之间就形成了僵局，两个进程都在等待对方释放自己所需要的资源，但是它们又都因不能继续获得自己所需要的资源而不能继续推进，从而也不能释放自己所占有的资源，以致进入死锁状态。 4、竞争临时资源上面所说的打印机资源属于可顺序重复使用型资源，称为永久资源。还有一种所谓的临时资源，这是指由一个进程产生，被另一个进程使用，短时间后便无用的资源，故也称为消耗性资源，如硬件中断、信号、消息、缓冲区内的消息等，它也可能引起死锁。例如，SI，S2，S3是临时性资源，进程P1产生消息S1，又要求从P3接收消息S3；进程P3产生消息S3，又要求从进程P2处接收消息S2；进程P2产生消息S2，又要求从P1处接收产生的消息S1。 八、死锁的产生条件和排除方法1、产生条件（1）互斥条件指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 （2）请求和保持条件指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 （3）不剥夺条件指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 （4）环路等待条件指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 2、排除方法 撤消陷于死锁的全部进程 逐个撤消陷于死锁的进程，直到死锁不存在 从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失 从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态 九、java类和对象的生命周期1、java对象的生命周期在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。上面的这7个阶段，构成了 JVM中对象的完整的生命周期。 2、类的生命周期java类的生命周期就是指一个class文件从加载到卸载的全过程。 类的完整生命周期包括7个部分：加载——验证——准备——解析——初始化——使用——卸载，如下图所示 其中，验证——准备——解析 称为连接阶段，除了解析外，其他阶段是顺序发生的，而解析可以与这些阶段交叉进行，因为Java支持动态绑定（晚期绑定），需要运行时才能确定具体类型；在使用阶段实例化对象。 参考资料：解决哈希（HASH）冲突的主要方法","categories":[{"name":"面试","slug":"面试","permalink":"https://www.yemaojun.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"笔试知识总结（网络基础、java）","slug":"笔试知识总结/笔试知识总结（一）","date":"2020-08-28T14:06:49.000Z","updated":"2020-08-29T06:41:44.380Z","comments":true,"path":"2020/08/28/笔试知识总结/笔试知识总结（一）/","link":"","permalink":"https://www.yemaojun.top/2020/08/28/%E7%AC%94%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E7%AC%94%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"全双工、DNS、Ping与ICMP、香农定理、Qos服务质量、PPP信息帧格式、集合框架、java线程状态转换、垃圾回收标准、HashMap与HashTable的区别、布尔类型在if语句中的赋值使用、优化Hibernate所鼓励的7大措施、类加载器、处理流与节点流。","text":"全双工、DNS、Ping与ICMP、香农定理、Qos服务质量、PPP信息帧格式、集合框架、java线程状态转换、垃圾回收标准、HashMap与HashTable的区别、布尔类型在if语句中的赋值使用、优化Hibernate所鼓励的7大措施、类加载器、处理流与节点流。 一、单工模式、半双工模式、全双工模式1、单工模式A发送请求，B接收请求，但B并不能发送请求。 2、半双工模式A发送请求过程中B不可以发送请求，当B发送请求时，A不能发送请求。 3、全双工模式A和B可以同时发送请求，同时接受请求。 二、DNS的作用1、作用（1）将主机名翻译到指定的IP地址； （2）将IP地址反解成主机名； （3）解析特定类型的服务的地址，如MX，NS； 2、补充知识（1）DNS是域名解析协议； （2）IP地址转为MAC地址是ARP协议的作用，RARP协议的作用刚好相反； （3）DNS解析域名到IP地址为双向的，此外还可以解析特定类型的服务的地址； （4）DNS查询是双向，递归，迭代，多功能的有直接IP解析，别名解析，记录解析等等。 三、Ping与ICMPping用来测试网络可达性。 主机A通过ping建立一个固定格式的ICMP请求包逐层包装传递给主机B，主机B收到数据帧处理后构建一个ICMP发送给主机A。 ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网络的连线情况，也能确保连线的准确性。其ICMP类型中包含各种代码以及对应的响应报告（Ping通以及Ping不同的差错报告）。 四、香农定理C &#x3D; Blb（1 + S &#x2F; N） 其中：C是信道支持的最大速度或者叫信道容量；B是信道的带宽；S是平均信号功率；N是平均噪声功率；S&#x2F;N即信噪比。 信噪比越高，数据传输率也越高。 五、QoS服务质量QoS（Quality of Service），中文名为“服务质量”。它是指网络提供更高优先服务的一种能力，包括专用带宽、抖动控制和延迟（用于实时和交互式流量情形）、丢包率的改进以及不同WAN、LAN和MAN技术下的指定网络流量等，同时确保为每种流量提供的优先权不会阻碍其它流量的进程只要涉及到带宽分配和对业务服务质量有要求的地方，就会有QoS设计。QoS技术多应用于广域网络和语音、视频等媒体业务系统。 六、PPP信息帧格式A： 信息字段的长度是可变的，不超过1500字节； B、PPP帧的首部和尾部分别为四个字段和两个字段 ；首部：标志字段F、地址字段A、控制字段C、协议字段 尾部：帧校验序列 FCS、标志字段 F； C、D: 首部第一个字段和尾部第二个字段都是标志字段F 规定为0x7E 标志字段表示一个帧的开始或结束。因此标志字段就是PPP帧的定界符。首部的地址字段A规定为0xFF,控制字段C规定为0x03 这两个字段实际上并没有携带PPP帧的信息。 D：PPP首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报 当协议字段为0xC021，则信息字段是PPP链路控制协议LCP的数据，而0x8021表示网络层的控制数据。 七、集合框架 八、java线程状态的转换 九、垃圾回收器收集的标准java中，判断一块内存空间是否符合垃圾收集器收集标准的标准为： 1、给对象赋值为null，以下没有调用过； 2、给对象赋了新的值，重新分配了内存空间。 十、类、接口与.class文件的关系 一个.java文件中定义多个类： 注意一下几点： (1) public权限类只能有一个（也可以一个都没有，但最多只有一个）； (2)这个.java文件名只能是public 权限的类的类名； (3)倘若这个文件中没有public 类，则它的.java文件的名字是随便的一个类名； (4)当用javac命令生成编译这个.java 文件的时候，则会针对每一个类生成一个.class文件。 十一、字符串创建对象 十二、布尔类型在if语句中的赋值运算 注意的是上面的if语句中是赋值语句，if的语句比较，除boolean外的其他类型都不能使用赋值语句，否则会提示无法转成布尔值。 十三、线程安全的map集合讲解 HashMap,TreeMap 未进行同步考虑，是线程不安全的。 HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。 Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如， List list &#x3D; Collections.synchronizedList(new ArrayList()); Set set &#x3D; Collections.synchronizedSet(new HashSet()); 十四、java中的数组 数组是一种引用数据类型，那么他肯定是继承Object类的，所以里面有equals() 方法，但是肯定没有重写过， 因为他并不是比较数组内的内容。使用Arrays.equals() 是比较两个数组中的内容。 十五、HashTable和HashMap区别1、继承不同12public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map 2、线程安全性不同Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 3、Hashtable中，key和value都不允许出现null值在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 4、两个遍历方式的内部实现上不同Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 5、哈希值的使用不同HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 6、Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 十六、接口中的成员 接口，比抽象类还要抽象的类。 接口中每一个方法也是隐式抽象的,接口中的方***被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误。） 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 注： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。public 十七、优化Hibernate所鼓励的7大措施1、尽量使用many-to-one，避免使用单项one-to-many； 2、灵活使用单向one-to-many； 3、不用一对一，使用多对一代替一对一； 4、配置对象缓存，不使用集合缓存； 5、一对多使用Bag，多对一使用Set； 6、继承使用显示多态 HQL:from object polymorphism&#x3D;”exlicit” 避免查处所有对象； 7、消除大表，使用二级缓存。 十八、io流 java采用的uincode编码，两个字节表示一个字符，因此 char型在java中占两个字节，而int型占四个字节，故总共占六个字节。 补充： byte 1个字节 short 2个字节 int 4个字节 long 8个字节 float 4个字节 double 8个字节 char 2个字节 boolean 1个字节或4个字节，在java规范2中，如果boolean用于声明一个基本类型变量时占4个字节，如果声明一个数组类型的时候，那么数组中的每个元素占1个字节 十九、类加载器 类的加载是由类加载器完成的，类加载器包括：根加载器（ BootStrap ）、扩展加载器（ Extension ）、系统加载器（ System ）和用户自定义类加载器（ java.lang.ClassLoader 的子类）。从 Java 2 （ JDK 1.2 ）开始，类加载过程采取了父亲委托机制（ PDM ）。 PDM 更好的保证了 Java 平台的安全性，在该机制中， JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。 JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明： Bootstrap ：一般用本地代码实现，负责加载 JVM 基础核心类库（ rt.jar ）； Extension ：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap ； system class loader ：又叫应用类加载器，其父类是 Extension 。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。 用户自定义类加载器： java.lang.ClassLoader 的子类 父类委托机制是可以修改的，有些服务器就是自定义类加载器优先的。 二十、处理流与节点流 按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。 节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader. 处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。 JAVA常用的节点流： 文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。 字符串 StringReader StringWriter 对字符串进行处理的节点流。 数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。 管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。 常用处理流（关闭处理流使用关闭里面的节点流） 缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。 转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。 数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来. 流的关闭顺序 一般情况下是：先打开的后关闭，后打开的先关闭 另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b 可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。 简单来说，处理流就是需要传入节点流对节点流进行封装的流。","categories":[{"name":"笔试","slug":"笔试","permalink":"https://www.yemaojun.top/categories/%E7%AC%94%E8%AF%95/"}],"tags":[]},{"title":"数据结构（四）前缀、中缀、后缀表达式（逆波兰表达式）","slug":"数据结构/数据结构（四）","date":"2020-08-25T15:18:51.000Z","updated":"2020-10-16T16:09:04.095Z","comments":true,"path":"2020/08/25/数据结构/数据结构（四）/","link":"","permalink":"https://www.yemaojun.top/2020/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"前缀、中缀、后缀表达式（逆波兰表达式）","text":"前缀、中缀、后缀表达式（逆波兰表达式） 前缀表达式（波兰表达式） 一、基本概念（1）前缀表达式又称为波兰表达式，前缀表达式的运算符位于操作数之前； （2）举例说明：（3+4）* 5 - 6对应的前缀表达式就是 - * + 3 4 5 6。 二、前缀表达式的计算机求值​ 从右向左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时没弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。 例如：（3+4）*5-6对应的前缀表达式就是 - * + 3 4 5 6，针对前缀表达式求值步骤如下： （1）从右至左扫描，将6、5、4、3压入堆栈； （2）遇到+运算符，因此弹出3和4，计算得到结果7，将结果压入栈； （3）接下来是*运算符，因此弹出7和5，计算得到35，将结果入栈； （4）最后是-运算符，计算35 - 6 &#x3D; 29的结果，此时29就是表达式的最后结果。 中缀表达式 一、基本概念（1）中缀表达式就是常见的运算表达式，如（3+4）*5-6； （2）中缀表达式的求值是人所最熟悉的，但是对于计算机却不好操作，因此在计算结果时，往往会将中缀表达式转成其它表达式来操作（一般转为后缀表达式）。 二、中缀表达式转后缀表达式思路（1）初始化两个栈：运算符栈s1和存储中间结果的栈s2； （2）从左至右扫描中缀表达式； （3）遇到操作数时，将其压入s2； （4）遇到操作符时，比较其与s1栈顶运算符的优先级： 如果s1为空或栈顶运算符为左括号”（“，则直接将此运算符入栈； 否则，若优先级比栈顶的优先级高，也将运算符压入栈s1； 否则将s1栈顶的运算符弹出并压入到s2中，再次转到第一步与s1中新的栈顶运算符相比较。 （5）遇到括号时： 如果是左括号”（“，则直接压入s1 如果是右括号”）“，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。 （6）重复步骤2至5，直到表达式的最右边 （7）将s1中剩余的运算符依次弹出并压入s2； （8）依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。 后缀表达式（逆波兰表达式） 一、基本概念（1）后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后； （2）举例说明：（3+4）* 5 - 6对应的后缀表达式就是3 4 + 5 * 6 - 。 正常的表达式 逆波兰表达式 a + b a b + a + ( b - c ) a b c - + a + ( b - c ) * d a b c - d * + a + d * ( b - c ) a d b c - * + a &#x3D; 1 + 3 a 1 3 + &#x3D; 二、后缀表达式的计算机求值从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈；重复上述过程知道表达式最右端，最后运算得出的值即为表达式的结果 例如：（3+4）* 5 - 6对应的前缀表达式就是3 4 + 5 * 6 -，针对后缀表达式求值步骤如下： （1）从左至右扫描，将3和4压入堆栈； （2）遇到+运算符，因此弹出3和4，计算得到3+4的结果，再将7入栈； （3）将5入栈； （4）接下来是*运算符，因此弹出5和7计算出结果并将结果入栈； （5）将6入栈； （6）最后是-运算符，计算35 - 6的结果，此时最后的结果是29。 三、逆波兰计算器1、需求 输入一个逆波兰表达式（后缀表达式），使用栈（Stack），计算其结果 支持小括号和多位数整数","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.yemaojun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"SpringMVC框架学习（一）(Spring与Web环境集成、SpringMVC的简介、SpringMVC的组件解析)","slug":"SpringMVC框架学习/SpringMVC框架学习（一）","date":"2020-08-16T04:07:39.000Z","updated":"2020-08-17T15:11:13.728Z","comments":true,"path":"2020/08/16/SpringMVC框架学习/SpringMVC框架学习（一）/","link":"","permalink":"https://www.yemaojun.top/2020/08/16/SpringMVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/SpringMVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"今天开始SpringMVC框架的学习。主要的内容有Spring与Web环境集成、SpringMVC的简介、SpringMVC的组件解析","text":"今天开始SpringMVC框架的学习。主要的内容有Spring与Web环境集成、SpringMVC的简介、SpringMVC的组件解析 Spring与Web环境集成 一、SpringMVC的概述1、Spring为展现层提供的基于MVC设计理念的优秀的web框架，是目前最主流的MVC框架之一； 2、Spring3.0后全面超越Struts2，成为最优秀的MVC框架； 3、SpringMVC通过一套MVC注解，让POJO（原始的java对象）成为处理请求的控制器，而无需实现任何接口； 4、支持REST风格的URL请求； 5、采用了松散耦合可插拨组件节后，比其他MVC框架更具扩展性和灵活性。","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.yemaojun.top/categories/SpringMVC/"}],"tags":[]},{"title":"Spring框架学习（四）(Spring JdbcTemplate基本使用、编程式事务控制相关对象、基于XML与注解的声明式事务控制)","slug":"Spring框架/Spring框架学习（四）","date":"2020-08-12T05:45:06.000Z","updated":"2020-08-16T04:05:47.388Z","comments":true,"path":"2020/08/12/Spring框架/Spring框架学习（四）/","link":"","permalink":"https://www.yemaojun.top/2020/08/12/Spring%E6%A1%86%E6%9E%B6/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"Spring JdbcTemplate基本使用、编程式事务控制相关对象、基于XML与注解的声明式事务控制。","text":"Spring JdbcTemplate基本使用、编程式事务控制相关对象、基于XML与注解的声明式事务控制。 Spring JdbcTemplate基本使用 一、JdbcTemplate概述它是Spring框架中提供的一个对象，是对原始繁琐的 Jdbc API对象的简单封装。spring框架为我们提供了很多操作模板类。例如：操作关系型数据库的Jdbc Template和Hibernate Template ，操作nosql数据库的Redis Template，操作消息队列的Jms Template等等。 二、JdbcTemplate开发步骤1、导入spring-jdbc和spring-tx坐标； 2、创建数据库表和实体； 3、创建JdbcTemplate对象； 4、执行数据库操作。 三、Spring产生模板对象我们可以使用JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring（注入依赖）。 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置外部文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 配置连接对象 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置JdbcTemplate --&gt; &lt;bean id=&quot;template&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt;&lt;!-- jdbc.properties文件内容 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_jdbc jdbc.username=root jdbc.password=root--&gt; 四、CRUD操作 五、知识要点1、导入spring-jdbc和spring-tx坐标； 2、创建数据库表和实体； 3、创建JdbcTemplate对象 12JdbcTemplate template = new JdbcTemplate();template.setDataSource(dataSource); 4、执行数据库操作 更新操作：template.update(sql,params) 查询操作：template.query(sql,Mapper,params) ​ template.queryForObject(sql,Mapper,params) 编程式事务控制相关控制对象 一、PlatformTransactionMangerPlatformTransactionManger接口是Spring的事务管理器，它里面提供了我们常用的操作事务的方法 方法 说明 TransactionStatus getTransaction（TransactionDefination defination） 获取事务的状态信息 void commit（TransactionStatus status） 提交事务 void rollback（TransactionStatus status） 回滚事务 注意事项：PlatformTransactionManger是接口类型，不同的Dao层技术则有不同的实现类。 例如：Dao层技术是jdbc或mybatis时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5,HibernateTransactionManager 二、TransactionDefinitionTransactionDefinition是事务的定义信息对象，里面有如下方法： 方法 说明 int getIsolationLevel() 获得事务的隔离级别 int getPropogationBehavior() 获得事务的传播行为 int getTimeout() 获得超时时间 boolean isReadOnly 是否只读 1、事务隔离级别设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和而虚读（幻读） ISOLATION_DEFAULT：默认 ISOLATION_READ_UNCOMMITTED：读未提交 ISOLATION_READ_COMMITTED：读已提交（解决脏读问题） ISOLATION_REPEATABLE_READ：可重复读（解决不可重复读） ISOLATION_SERIALIZABLE：串行化（可以解决全部问题） 2、事务的传播行为事务传播行为的主要作用是为了解决业务方法在调用业务方法时的统一性。 REQUIRED：如果当前没有事务，就新建一个事务，如果当前已经存在一个事务中，加入到当前这个事务中，一般的选择（默认值）。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）。 MANDATORY：使用当前的事务，如果当前没有事务就抛出异常。 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以事务方式执行操作，如果当前存在事务，就把当前事务挂起。 NEVER：以非事务方式运行，如果当前存在事务，抛出异常。 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作。 超时时间：默认值时-1，没有超时限制。如果有，以秒为单位进行设置。 是否只读：建议查询时设置为只读。 三、TransactionStatusTransactionStatus接口提供的是事务具体的运行状态，方法介绍如下。 方法 说明 boolean hasSavepoint() 是否存储回滚点 boolean isCompleted() 事务是否完成 boolean isNewTransaction() 是否是新事务 boolean isRollbackOnly() 事务是否回滚 TransactionDefinition + PlatformTransactionManger &#x3D; TransactionStatus 四、知识要点编程事务控制三大对象： PlatformTransactionManger ：平台参数 TransactionDefinition ：隔离级别 TransactionStatus：运行状态 基于XML的声明式事务控制 一、什么是声明式事务控制Spring的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在Spring配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用： 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可。 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来及其方便。 注意事项：Spring声明式事务控制底层就是AOP。 二、代码演示1、环境配置（1）创建数据库表 （2）配置坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、创建数据库表的实体类123456789101112131415161718192021222324252627282930package cn.domain;public class Account &#123; private String name; private Double money; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 3、编写Spring的配置文件1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 加载jdbc.properties --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置c3p0的DataSource --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置JdbcTemplate(目标对象) --&gt; &lt;bean id=&quot;template&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置组件扫描 --&gt; &lt;context:component-scan base-package=&quot;cn&quot;/&gt;&lt;/beans&gt; 4、编写Dao层（持久层）123456789101112131415161718192021222324252627282930@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate template; public int insertAccount(Account account) &#123; String sql = &quot;insert into account(name,money) values(?,?) &quot;; return template.update(sql,account.getName(),account.getMoney()); &#125; public int deleteAccpunt(String name) &#123; String sql = &quot;delete from account where name = ?&quot;; return template.update(sql,name); &#125; public int updateAccount(Account account) &#123; String sql = &quot;update account set money = ? where name = ?&quot;; return template.update(sql,account.getMoney(),account.getName()); &#125; public Account selectByName(String name) &#123; String sql = &quot;select * from account where name = ?&quot;; return template.queryForObject(sql,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),name); &#125; public List&lt;Account&gt; selectAll() &#123; String sql = &quot;select * from account&quot;; return template.query(sql,new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); &#125;&#125; 5、编写Service层123456789101112131415161718192021222324252627@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; /** * 转账方法，用户name1向name2转账money元 * @param name1 转账的用户主键 * @param name2 被转帐的用户主键（即受到钱的用户） * @param money * @return */ public int zhuanzhang(String name1, String name2, Double money) &#123; Account account1 = accountDao.selectByName(name1); Account account2 = accountDao.selectByName(name2); Double money1 = account1.getMoney(); Double money2 = account2.getMoney(); account1.setMoney(money1 - money); account2.setMoney(money2 + money); int i1 = accountDao.updateAccount(account1); int i = 1 / 0;//此处时故意出错为了检测事务控制是否生效 int i2 = accountDao.updateAccount(account2); return i1 + i2; &#125;&#125; 6、编写测试类123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class ServiceTest &#123; @Autowired private AccountService accountService; @Test public void zhuanzhang()&#123; int zhuanzhang = accountService.zhuan(&quot;zhangsan&quot;, &quot;tom&quot;, 500.0); System.out.println(zhuanzhang); &#125;&#125; 此时没有使用xml配置事务控制运行之后的数据库结果为： 可以发现用户“zhangsan”向用户“tom”转账500元，但zhangsan转账之后，张三的账户确实少了500元，但tom的账户并没有多出500元。以致于zhangsan的500元凭空消失了。 此时修改xml配置文件如下（加入事务控制）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 加载jdbc.properties --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置c3p0的DataSource --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置JdbcTemplate(目标对象) --&gt; &lt;bean id=&quot;template&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置平台事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 通知 事务的增强 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 设置事务的属性信息 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务的aop织入 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.Service.Impl.AccountServiceImpl.zhuanzhang(..))&quot;/&gt; &lt;/aop:config&gt; &lt;!-- 配置组件扫描 --&gt; &lt;context:component-scan base-package=&quot;cn&quot;/&gt;&lt;/beans&gt; 此时再次将双方账户急呢回复后运行结果依然报错，但此时再查看数据库的数据为： 由于发生了错误，所以事务回滚了。 三、事务控制知识要点1、声明事务控制的配置要点（1）平台事务管理器配置； 1234&lt;!-- 配置平台事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; （2）事务通知的配置； 1234567&lt;!-- 通知 事务的增强 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 设置事务的属性信息 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;tx:method&gt;标签的属性： 属性名称 说明 默认值 name 方法的名称 \\ isolation 隔离级别 DEFAULT propagetion 传播行为 REQUIRED timeout 最长等待时长 -1 read-only 是否只读 false （3）事务AOP织入的配置。 1234&lt;!-- 配置事务的aop织入 --&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.Service.Impl.AccountServiceImpl.zhuanzhang(..))&quot;/&gt;&lt;/aop:config&gt; 基于注解的声明式事务控制 一、事务注解配置代码演示1、配置xml配置文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 加载jdbc.properties --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置c3p0的DataSource --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置JdbcTemplate(目标对象) --&gt; &lt;bean id=&quot;template&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置平台事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置组件扫描 --&gt; &lt;context:component-scan base-package=&quot;cn&quot;/&gt; &lt;!-- 开启事务的注解驱动 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; 2、配置Service层123456789101112131415161718192021222324252627282930313233343536373839404142package cn.Service.Impl;import cn.Service.AccountService;import cn.dao.AccountDao;import cn.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service@Transactionalpublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; /** * 转账方法，用户name1向name2转账money元 * @param name1 转账的用户主键 * @param name2 被转帐的用户主键（即受到钱的用户） * @param money * @return */ @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public int zhuan(String name1, String name2, Double money) &#123; Account account1 = accountDao.selectByName(name1); Account account2 = accountDao.selectByName(name2); Double money1 = account1.getMoney(); Double money2 = account2.getMoney(); account1.setMoney(money1 - money); account2.setMoney(money2 + money); int i1 = accountDao.updateAccount(account1);// int i = 1 / 0; int i2 = accountDao.updateAccount(account2); return i1 + i2; &#125;&#125; 注意事项：当类和方法都添加了@Transactional时，采用就近原则。使用方法上面的注解配置。 二、知识点1、注解配置声明式事务控制解析（1）使用@Transaction在需要进行事务控制的类或是方法上修饰，注解可用的属性同xml配置方式，例如：隔离级别、传播行为等。 （2）注解使用在类上，那么该类下的所有方法都是用同一套注解参数配置。 （3）使用在方法上，不同的方法可以采用不同的事务参数配置。 （4）Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven transaction-manager&#x3D;”transactionManager”&#x2F;&gt; 2、注解配置事务控制要点（1）平台事务管理器配置（xml方式） （2）事务通知配置（@Transaction注解配置） （3）事务注解驱动的配置&lt;tx:annotation-driven transaction-manager&#x3D;”transactionManager”&#x2F;&gt; 参考资料：2020年 最新版 传智黑马Java SSM 阶段 采用IDEA教学","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yemaojun.top/categories/Spring/"}],"tags":[]},{"title":"Spring框架学习（三）(Spring的AOP介绍、基于XML的AOP开发、基于注解的AOP开发)","slug":"Spring框架/Spring框架学习（三）","date":"2020-08-11T03:07:01.000Z","updated":"2020-08-13T09:30:51.705Z","comments":true,"path":"2020/08/11/Spring框架/Spring框架学习（三）/","link":"","permalink":"https://www.yemaojun.top/2020/08/11/Spring%E6%A1%86%E6%9E%B6/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"主要学习Spring的AOP介绍、基于XML的AOP开发、基于注解的AOP开发。","text":"主要学习Spring的AOP介绍、基于XML的AOP开发、基于注解的AOP开发。 Spring AOP的简介 一、AOP的基本概念1、定义AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 动态代理： 优点：在不修改源码的基础上对目标方法进行相应的增强。 作用：完成程序功能间的松耦合。 2、AOP的作用与优势（1）作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强。 （2）优势：减少重复代码，提高开发效率，并且便于维护。 3、AOP的底层实现实际上，AOP的底层是通过Spring提供的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能介入，在去调用目标对象的方法，从而完成功能的增强。 常用的动态代理技术： JDK代理：基于接口的动态代理技术 cglib代理：基于父类的动态代理技术 4、JDK的代理实现（1）创建目标接口和目标类 1234567891011//目标接口public interface TargetInterface &#123; void save();&#125;//目标类public class Target implements TargetInterface &#123; public void save() &#123; System.out.println(&quot;save...&quot;); &#125;&#125; （2）创建增强类 123456789public class Advice &#123; public void before()&#123; System.out.println(&quot;前置增强...&quot;); &#125; public void afterReturning()&#123; System.out.println(&quot;后置增强...&quot;); &#125;&#125; （3）编写测试增强方法 12345678910111213141516171819202122232425262728293031323334public class ProxyTest &#123; public static void main(String[] args) &#123; //目标对象 final Target target = new Target(); //增强对象 final Advice advice = new Advice(); //返回值就是动态生成的代理对象 //但是由于生成的代理对象与被代理的对象的是兄弟类型的所以无法使用Target类型转换 TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(),//目标对象类加载器 target.getClass().getInterfaces(),//目标对象相同的接口字节码对象数组 new InvocationHandler() &#123; //调用代理对象的任何方法 实质执行的都是invoke方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; advice.before();//前置增强方法 Object invoke = method.invoke(target, args);//执行目标方法 advice.afterReturning();//后置增强方法 return invoke; &#125; &#125; ); //调用代理对象的方法 proxy.save(); &#125;&#125;/* 运行结果： 前置增强... save... 后置增强...*/ 5、cglib代理实现（1）创建代理对象 12345public class Target &#123; public void save() &#123; System.out.println(&quot;save...&quot;); &#125;&#125; （2）创建增强类 123456789public class Advice &#123; public void before()&#123; System.out.println(&quot;前置增强...&quot;); &#125; public void afterReturning()&#123; System.out.println(&quot;后置增强...&quot;); &#125;&#125; （3）创建测试增强方法 12345678910111213141516171819202122232425262728293031323334public class ProxyTest &#123; public static void main(String[] args) &#123; //目标对象 final Target target = new Target(); //增强对象 final Advice advice = new Advice(); //返回值就是动态生成的代理对象 基于cglib //1、创建增强器 Enhancer enhancer = new Enhancer(); //2、设置父类（目标） enhancer.setSuperclass(Target.class); //3、设置回调 enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; advice.before();//前置增强 Object invoke = method.invoke(target, objects);//执行目标 advice.afterReturning();//后置增强 return invoke; &#125; &#125;); //4、创建代理对象 Target proxy = (Target) enhancer.create(); proxy.save(); &#125;&#125;/* 运行结果： 前置增强... save... 后置增强...*/ 二、AOP的相关术语Spring的AOP实现底层就是对上面的动态代理的代码进行了封装，feng’zhuang’zhi’ho我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在AOP操作之前，需要先了解AOP的常用术语，常用相关术语如下： Target（目标对象）：代理的目标对象 Proxy（代理）：一个类被AOP织入增强后，就会产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点（可以理解为可以被增强的方法） Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义（可以理解为实际被增强的方法） Advice（通知&#x2F;增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知（增强的逻辑&#x2F;过程） Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而Aspectj采用编译期织入和类装载期织入（将切点和增强结合的过程即为织入的过程） 三、AOP开发明确的事项1、需要编写的内容（1）编写核心业务代码（目标类的目标方法） （2）编写切面类，切面类中有通知（增强功能方法） （3）在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 2、AOP技术实现的内容Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 3、AOP底层使用哪种代理方式在Spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 四、知识要点（1）AOP：面向切面编程 （2）AOP底层实现：基于JDK的动态代理和基于Cglib的动态代理 （3）AOP的中带你概念： ​ Pointcut（切入点：）被增强的方法 ​ Advice（通知&#x2F;增强）：封装增强业务逻辑的方法 ​ Aspect（切面）：切点 + 通知 ​ Weaving（织入）：将切点与通知结合的过程 （4）开发明确事项： ​ 谁是切点（切点表达式配置） ​ 谁是通知（切面类中的增强方法） ​ 将切点和通知进行织入配置 基于XML的AOP开发 一、基于XML开发的快速入门1、导入AOP相关坐标； 2、创建目标接口和目标类（内部有切点）； 3、创建切面类（内部有增强方法）； 4、将目标类和切面类的对象创建权交给Spring 5、在applicationContext.xml中配置织入关系 6、测试代码 二、基于XML开发的代码实现1、配置接口和目标类1234567891011//接口public interface TargetInterface &#123; void save();&#125;//目标类public class Target implements TargetInterface &#123; public void save() &#123; System.out.println(&quot;save...&quot;); &#125;&#125; 2、配置（通知&#x2F;增强）12345public class MyAspect &#123; public void before()&#123; System.out.println(&quot;前置增强...&quot;); &#125;&#125; 3、配置xml文件12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--目标对象--&gt; &lt;bean id=&quot;target&quot; class=&quot;aop.Target&quot;/&gt; &lt;!--切面对象--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;aop.MyAspect&quot;/&gt; &lt;!--配置织入：告诉Spring框架 哪些方法（切点）需要进行哪些增强（前置、后置...）--&gt; &lt;aop:config&gt; &lt;!--声明切面--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--切面：切点 + 通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void aop.Target.save())&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4、配置测试类12345678910111213141516@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Autowired private TargetInterface targetInterface; @Test public void aopTest()&#123; targetInterface.save(); &#125;&#125;/* 运行结果： 前置增强... save...*/ 三、切点表达式的写法1、全通配写法* * ..*.*(..) 返回值可以使用通配符，表示任意返回值 * aop.Target.save() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. 例如：假设上面的save()方法前面有四个包就需要写成： * *.*.*.*.Target.save() 但包名还可以简写为..表示当前包及其子包 * *..*.Target.save() 类名和方法名都可以使用*来实现通配 即：* *..*.*.*() 参数列表可以使用..来通配，但也可以直接使用数据类型 基本数据类型直接写名称 应用类型写包名.类名的方式 2、实际开发中切入点表达式的通常写法切到业务层表现类下的所有方法 例： * aop.*.*(..) 3、切点表达式的抽取在配置文件的过程中，切点表达式会有很多重复的部分，所以可以将重复的部分抽取出来，便于维护。 在增强中使用pointcut-ref属性代替pointcut属性来引用抽取后的切点表达式。 12345678910111213&lt;aop:config&gt; &lt;!--声明切面--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--抽取切点表达式--&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* aop.*.*(..))&quot;/&gt; &lt;!--切面：切点 + 通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:after-returning method=&quot;afterRunning&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 四、AOP的通知种类1、通知的类型通知的配置语法： 1&lt;aop:通知类型 method=&quot;切面类中方法名&quot; pointcut=&quot;切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 &lt;aop:before&gt; 用于配置前置通知，指定增强的方法在切入点方法之前执行 后置通知 &lt;aop:after-returning&gt; 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 &lt;aop:around&gt; 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 &lt;aop:throwing&gt; 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 &lt;aop:after&gt; 用于配置最终通知。无论增强方式执行是否有异常都会执行 2、代码演示（1）配置增强类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyAspect &#123; /** 前置增强 * 在切入点方法执行之前执行的方法 */ public void before()&#123; System.out.println(&quot;前置增强...&quot;); &#125; /** 后置增强 * 在切入点方法执行之后执行 */ public void afterRunning()&#123; System.out.println(&quot;后置增强...&quot;); &#125; /** 环绕增强 * 在切入点之前和之后都执行的方法 * @param pjp * @return * @throws Throwable */ //ProceedingJoinPoint：正在执行的连接点（切点） public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;环绕前增强...&quot;); //切点方法 Object proceed = pjp.proceed(); System.out.println(&quot;环绕后增强...&quot;); return proceed; &#125; /** 异常抛出增强 * 抛出异常时执行 */ public void afterThrowing()&#123; System.out.println(&quot;异常抛出增强...&quot;); &#125; /** 最终增强 * 不管怎么样都一定会执行 */ public void after()&#123; System.out.println(&quot;最终增强...&quot;); &#125;&#125; （2）配置目标类 123456public class Target implements TargetInterface &#123; public void save() &#123;// int i = 1 / 0; System.out.println(&quot;save...&quot;); &#125;&#125; （3）配置xml文件 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--目标对象--&gt; &lt;bean id=&quot;target&quot; class=&quot;aop.Target&quot;/&gt; &lt;!--切面对象--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;aop.MyAspect&quot;/&gt; &lt;!--配置织入：告诉Spring框架 哪些方法（切点）需要进行哪些增强（前置、后置...）--&gt; &lt;aop:config&gt; &lt;!--声明切面--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--切面：切点 + 通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* aop.*.*(..))&quot;/&gt; &lt;aop:after-returning method=&quot;afterRunning&quot; pointcut=&quot;execution(* aop.*.*(..))&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* aop.*.*(..))&quot;/&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut=&quot;execution(* aop.*.*(..))&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut=&quot;execution(* aop.*.*(..))&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; （4）编写测试类 1234567891011121314151617181920212223242526@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Autowired private TargetInterface targetInterface; @Test public void aopTest()&#123; targetInterface.save(); &#125;&#125;/* 运行结果（未抛异常时）： 前置增强... 环绕前增强... save... 最终增强... 环绕后增强... 后置增强... 运行结果（抛异常时）： 前置增强... 环绕前增强... 最终增强... 异常抛出增强...*/ 五、知识要点、1、AOP织入的配置12345&lt;aop:config&gt; &lt;aop:aspect ref=&quot;切面类&quot;&gt; &lt;aop:before method=&quot;通知方法名称&quot; pointcut=&quot;切点表达式&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2、通知的类型前置通知、后置通知、环绕通知、异常抛出通知、最终通知 3、切点表达式的写法1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 基于注解的AOP开发 一、基于注解的AOP开发快速入门1、基于注解的AOP开发的步骤（1）创建目标接口和目标类（内部有切点） （2）创建切面类（内部有增强方法） （3）将目标类和切面类的对象创建权交给Spring （4）在切面类中使用注解配置织入关系 （5）在配置文件中开启组件扫描和AOP的自动代理 （6）测试 2、基于注解的AOP开发的代码演示（1）创建目标接口和目标类（内部有切点）123456789101112//接口public interface TargetInterface &#123; void save();&#125;//目标类@Component(&quot;target&quot;)public class Target implements TargetInterface &#123; public void save() &#123; System.out.println(&quot;save...&quot;); &#125;&#125; （2）创建切面类（内部有增强方法）1234567891011@Component(&quot;myAspect&quot;)@Aspect//当前的MyAspect是一个切面类public class MyAspect &#123; /** 前置增强 * 在切入点方法执行之前执行的方法 */ @Before(&quot;execution(* anno.*.*(..))&quot;) public void before()&#123; System.out.println(&quot;前置增强...&quot;); &#125;&#125; （3）编写测试类123456789101112131415161718192021222324252627282930//主要的配置类@Configuration//用于指定当前类是Spring配置类，当创建容器时会从该类上加载注解@ComponentScan(&quot;com.itheima&quot;)//用于指定Spring初始化容器时要扫描的包。相当于加载组件@Import(&#123;DataSourceConfiguration.class&#125;)//传入的为数组类型public class SpringConfiguration &#123;&#125;//被导入的类@PropertySource(&quot;jdbc.properties&quot;)//用于指定.properties数据源public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String user; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;)//Spring会将当前方法的返回值以指定名称存入容器 public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(user); dataSource.setPassword(password); return dataSource; &#125;&#125; （4）测试1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService; @Autowired private UserDao userDao; @Test public void test2()&#123;userDao.save();&#125; @Test public void test1()&#123; userService.save(); &#125;&#125; 二、注解配置AOP的类型通知的配置语法：@通知注解（”切点表达式“） 名称 注解 说明 前置通知 @Before 用于配置前置通知，指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知，指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知，指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用于配置异常抛出通知，指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知，无论增强方式执行是否有异常都会执行 三、切点表达式的抽取和XMl配置AOP一样，可以将切点表达式抽取，抽取方式实在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后再在增强注解中进行引用。 12345678910111213141516@Component(&quot;myAspect&quot;)@Aspect//当前的MyAspect是一个切面类public class MyAspect &#123; //抽取切点表达式 @Pointcut(&quot;execution(* anno.*.*(..))&quot;) public void myPoint()&#123;&#125; /** 前置增强 * 在切入点方法执行之前执行的方法 */// @Before(&quot;MyAspect.myPoint()&quot;) @Before(&quot;myPoint()&quot;) public void before()&#123; System.out.println(&quot;前置增强...&quot;); &#125;&#125; 四、基于注解开发的知识要点1、注解AOP开发步骤（1）使用**@Aspect**标注切面类 （2）使用**@通知注解**标注通知方法 （3）在配置文件中配置组件扫描和AOP自动代理 123&lt;aop:aspectj-autoproxy/&gt;&lt;!--@EnableAspectJAutoProxy--&gt;&lt;!-- 以下这种方式是使用配置类的方式创建的AOP代理 --&gt;&lt;!-- @ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) --&gt; 参考资料：2020年 最新版 传智黑马Java SSM 阶段 采用IDEA教学","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yemaojun.top/categories/Spring/"}],"tags":[]},{"title":"Spring框架学习（ExceptionInInitializerError异常原因与处理）","slug":"问题收集/Spring框架学习（ExceptionInInitializerError异常原因与处理）","date":"2020-08-11T02:24:13.000Z","updated":"2020-08-11T02:36:34.849Z","comments":true,"path":"2020/08/11/问题收集/Spring框架学习（ExceptionInInitializerError异常原因与处理）/","link":"","permalink":"https://www.yemaojun.top/2020/08/11/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88ExceptionInInitializerError%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0%E4%B8%8E%E5%A4%84%E7%90%86%EF%BC%89/","excerpt":"在学习Spring的过程中，为了方便后面的测试，所以在尝试集成junit。结果在此过程中报了一个ExceptionInInitializerError异常。现将该异常的出现原因与解决办法记录如下。","text":"在学习Spring的过程中，为了方便后面的测试，所以在尝试集成junit。结果在此过程中报了一个ExceptionInInitializerError异常。现将该异常的出现原因与解决办法记录如下。 ExceptionInInitializerError异常 一、异常的详情 异常的意思是异常初始化错误（ExceptionInInitializerError）。而后我在网上浏览了一些对该错误的描述信息，现摘要如下： 12345678当在静态初始化块中出现异常的时候,JVM会抛出java.lang.ExceptionInInitializerError异常;且任何异常都能引发这种情况,有时候在没有静态块的情况下也会抛出这种异常,因为java默认会将静态变量的初始化房子啊一个默认的静态初始化块中,然后按他们在源文件中的生命进行初始化; 在初始化失败之后,抛出此异常,dev会得到一个java.lang.NoClassDefFoundError异常,而且是在使用这个类,类加载失败的时候才会出现. 需要记住以下几点： 1. &quot;Exception in thread &quot;main&quot; java.lang.ExceptionInInitializerError&quot;意味着异常出现在主线程，并且是LinkageError的一个子类java.lang.ExceptionInInitializerError，这是JVM类加载失败时才抛出的，原因是静态初始化代码中出现了诸如IndexOutOfBoundsException或者NullPointerException这样的RuntimeException。 2. 记住JVM会将所有的静态变量的初始化按它们在源文件中的出现顺序放到一个静态初始化块中。因此，不要觉得没有看到静态初始块就认为不会出现这个异常。事实上，你得确保静态变量的正确顺序，比如说，如果 一个变量初始化的时候用到了另一个变量，你得确保这个变量在前面已经初始化过了。 3. 如果别的代码想要使用这个类，则会抛出ExceptionInInitializerError异常，而它又会导致ClassNotFoundException或者NoClassDefFoundError。为什么？因为这个类加载失败了，并没有加载到JVM的内存中。因此如果你在解决类不存在之类的异常时，先看看你的日志文件中有没有这个异常。 4. 记住静态初始化代码块会抛出RuntimeException而不是已检查异常，而后者需要有对应的catch块来进行处理。 需要谨记的是这个异常的一个副作用是NoClassDefFoundError，而Java程序抛出这个异常的位置可能会离java.lang.ExceptionInInitializerError很远，这取决于你的客户端代码何时引用到这个类。因此，在查看类路径解决NoClassDefFoundError异常之前，最好先看看日志有没有出现ExceptionInInitializerError。 二、该异常的出现原因但经过排查，发现真正的异常原因如下： 是由于我在一开始导入Junit坐标的时候导入的版本是4.10版本的，而他要求Junit的版本最低是4.12或更高。在更改了junit的版本之后异常解决了。 参考资料; Java中的ExceptionInInitializerError异常及解决方法","categories":[{"name":"问题收集","slug":"问题收集","permalink":"https://www.yemaojun.top/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/"}],"tags":[]},{"title":"Spring框架学习（二）(Spring配置数据源、Spring注解开发、Spring整合Junit)","slug":"Spring框架/Spring框架学习（二）","date":"2020-08-10T07:35:49.000Z","updated":"2020-08-11T03:06:10.410Z","comments":true,"path":"2020/08/10/Spring框架/Spring框架学习（二）/","link":"","permalink":"https://www.yemaojun.top/2020/08/10/Spring%E6%A1%86%E6%9E%B6/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"Spring配置数据源、Spring注解开发、Spring整合Junit","text":"Spring配置数据源、Spring注解开发、Spring整合Junit Spring 配置数据源 一、数据源（连接池）的作用1、数据源（连接池）是为了提高程序性能才出现的 2、事先实例化数据源，初始化部分连接资源 3、使用连接资源时从数据源中获取 4、使用完毕后将连接资源归还给数据源 常见的数据源：DBCP、C3P0、BoneCP、Druid等。 二、手动创建数据源1、手动创建C3P0数据源1234567891011121314/** * 测试手动创建 c3p0 数据源 */@Testpublic void test1() throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close();&#125; 2、手动创建Druid数据源1234567891011121314/** * 测试手动创建 druid 数据源 */@Testpublic void test2() throws Exception &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close();&#125; 3、配置文件创建C3P0数据源（1）现在resources目录下新建一个jdbc.properties数据库配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root （2）使用数据库配置文件加载 123456789101112131415161718192021/** * 测试手动创建 c3p0 数据源(加载properties配置文件) */@Testpublic void test3() throws Exception &#123; //读取配置文件 ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); String driver = rb.getString(&quot;jdbc.driver&quot;); String url = rb.getString(&quot;jdbc.url&quot;); String username = rb.getString(&quot;jdbc.username&quot;); String password = rb.getString(&quot;jdbc.password&quot;); //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close();&#125; 三、Spring配置数据源导入Spring所需要的坐标之后，配置Spring的核心配置文件。在核心文件内部配置标签 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 编写测试类，测试运行结果 123456789101112131415 /** * 测试Spring容器产生数据源对象 */ @Test public void test() throws Exception &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ComboPooledDataSource dataSource = (ComboPooledDataSource) app.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;/* 运行结果： com.mchange.v2.c3p0.impl.NewProxyConnection@6b53e23f*/ 四、抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context&#x3D;”hhtp:&#x2F;&#x2F;www.springframework.org/schema/context“ 约束路径：http://www.springframework.org/schema/context ​ http://www.springframework.org/schema/context//spring-context.xsd 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 加载外部的properties文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 编写测试类 123456789101112131415 /** * 测试Spring容器产生数据源对象 */ @Test public void test() throws Exception &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ComboPooledDataSource dataSource = (ComboPooledDataSource) app.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;/* 运行结果： com.mchange.v2.c3p0.impl.NewProxyConnection@25a65b77*/ Spring 注解开发 一、Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在Web层类上用于实例化Bean @Service 使用在Service层类上用于实例化Bean @Repository 使用在Dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired + @Qualifier，按照名称注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意事项：使用注解开发时，需要在applicationContext.xml中配置组件扫描，作用时指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!-- 注解的组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 当出现NoSuchBeanDefinitionException异常时则说明是没有配置上面的组件扫描或配置有误！ 二、代码演示注解开发1、配置UserDaoImpl实体类注解1234567//&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.Impl.UserDaoImpl&quot;/&gt;@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;save running...&quot;); &#125;&#125; 2、配置UserServiceImpl带注入依赖的注解配置1234567891011121314151617181920212223242526272829303132//&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.Impl.UserServiceImpl&quot;&gt;@Service(&quot;userService&quot;)//@Scope(&quot;prototype&quot;)@Scope(&quot;singleton&quot;)public class UserServiceImpl implements UserService &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; //@Autowired//当只有这一个标签时，按照数据类型从Spring容器中进行匹配，但当有多个Bean时会报错 //@Qualifier(&quot;userDao&quot;)//是按照id值从容器中进行匹配的，但是主要此处@Qualifier结合@Autowired一起使用 @Resource(name = &quot;userDao&quot;)//@Resource相当于@Qualifier + @Autowired private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save() &#123; System.out.println(driver); userDao.save(); &#125; @PostConstruct public void init()&#123; System.out.println(&quot;Service对象的初始化方法&quot;); &#125; @PreDestroy public void dextory()&#123; System.out.println(&quot;Service对象的销毁方法&quot;); &#125;&#125; 3、配置组件扫描1&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; 4、编写测试类12345678910111213 public static void main(String[] args) &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = app.getBean(UserService.class); userService.save(); ((ClassPathXmlApplicationContext) app).close(); &#125;/* 运行结果： Service对象的初始化方法 com.mysql.jdbc.Driver save running... Service对象的销毁方法*/ 三、Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置： 加载properties文件的配置：context:property-placeholder 组件扫描的配置：context:component-scan 引入其他文件： 注解 说明 @Configuration 用于指定当前类是Spring配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定Spring初始化容器时要扫描的包。作用同Spring的xml文件中的 &lt;context:component-scan base-package&#x3D;”com.itheima”&#x2F;&gt; @Bean 标注在方法上，标注将该方法的返回值存储到Spring容器中 @PropertySource 用于加载.properties文件中的配置 @Import 用于导入其他配置类 使用类的方式替代文件，注解替代标签。 1、创建Spring框架的配置类——使用类替代文件123456789101112131415161718192021222324252627282930//主要核心配置类@Configuration//用于指定当前类是Spring配置类，当创建容器时会从该类上加载注解@ComponentScan(&quot;com.itheima&quot;)//用于指定Spring初始化容器时要扫描的包。相当于加载组件@Import(&#123;DataSourceConfiguration.class&#125;)//传入的为数组类型public class SpringConfiguration &#123;&#125;//数据源配置类@PropertySource(&quot;jdbc.properties&quot;)//用于指定.properties数据源public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String user; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;)//Spring会将当前方法的返回值以指定名称存入容器 public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(user); dataSource.setPassword(password); return dataSource; &#125;&#125; 2、编写测试类12345678910111213141516 /** * 新注解测试 * @throws Exception */ @Test public void test4() &#123;// ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); userService.save(); &#125;/* 运行结果： com.mysql.jdbc.Driver save running...*/ Spring集成junit开发 一、Spring集成junit-集成简介和开发步骤1、Spring测试的问题在测试类中，每个测试方法都有如下两行代码 12ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ComboPooledDataSource dataSource = (ComboPooledDataSource) app.getBean(&quot;dataSource&quot;); 这两行代码的作用是获取容器对象，不写的话会报空指针异常。 2、解决思路（1）让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它； （2）将需要进行测试的类直接在测试类中注入。 3、Spring集成Junit的步骤（1）导入Spring集成junit的坐标 （2）使用@Runwith注解替换原来的运行期 （3）使用@ContextConfiguration指定配置文件 （4）使用@Autowired注入需要测试的对象 （5）创建测试方法进行测试。 4、代码演示（1）导入Spring集成Junit的坐标12345678910 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 注意事项：此处的junit的版本必须是4.12或更高的版本才可以，不然在编写测试类时会报ExceptionInInitializerError异常。关于该异常的信息可在分类选项中的问题收集标签中找到相关信息。 （2）配置测试类1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)//配置文件的方式@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)//配置类的方式public class SpringJunitTest &#123; @Autowired private UserService userService; @Autowired private UserDao userDao; @Test public void test2()&#123; userDao.save();//save running... &#125; @Test public void test1()&#123; userService.save(); /* com.mysql.jdbc.Driver save running... */ &#125;&#125; 参考资料：2020年 最新版 传智黑马Java SSM 阶段 采用IDEA教学","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yemaojun.top/categories/Spring/"}],"tags":[]},{"title":"Spring框架学习（一）(Spring框架的简介、快速入门、配置文件以及API)","slug":"Spring框架/Spring框架学习（一）","date":"2020-08-09T03:22:32.000Z","updated":"2020-08-12T03:39:52.182Z","comments":true,"path":"2020/08/09/Spring框架/Spring框架学习（一）/","link":"","permalink":"https://www.yemaojun.top/2020/08/09/Spring%E6%A1%86%E6%9E%B6/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"今天开始Spring框架的学习，主要内容为Spring框架的简介、快速入门、配置文件以及API","text":"今天开始Spring框架的学习，主要内容为Spring框架的简介、快速入门、配置文件以及API Spring 框架简介 一、Spring的基本概念Spring是分层的Java SE&#x2F;EE应用 full-stack 轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 二、Spring的优势1、方便解耦，简化开发通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 2、AOP编程的支持通过Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP实现的功能可以通过AOP轻松实现。值得注意的是AOP是一种思想。只不过是Spring将这种思想实现了。 3、声明式事务支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。 4、方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情（Spring集成了junit）。 5、方便集成各种优秀框架Spring对各种优秀框架（Struts、Hibemate、Hessian、Quartz等）的支持。 6、降低JavaEE API的使用难度Spring对JavaEE API（如JDCBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 7、Java源码是经典学习范例Spring的源码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。他的源代码无疑是Java技术的最佳实践范例。 三、AOP（面向切面编程）与OOP（面向对象编程）的区别以下内容摘自百度百科。 1、区分AOP、OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。 而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。 上面的陈述可能过于理论化，举个简单的例子，对于“雇员”这样一个业务实体进行封装，自然是OOP&#x2F;OOD的任务，我们可以为其建立一个“Employee”类，并将“雇员”相关的属性和行为封装其中。而用AOP设计思想对“雇员”进行封装将无从谈起。 同样，对于“权限检查”这一动作片断进行划分，则是AOP的目标领域。而通过OOD&#x2F;OOP对一个动作进行封装，则有点不伦不类。 换而言之，OOD&#x2F;OOP面向名词领域，AOP面向动词领域。 2、关系很多人在初次接触 AOP 的时候可能会说，AOP 能做到的，一个定义良好的 OOP 的接口也一样能够做到，我想这个观点是值得商榷的。AOP和定义良好的 OOP 的接口可以说都是用来解决并且实现需求中的横切问题的方法。但是对于 OOP 中的接口来说，它仍然需要我们在相应的模块中去调用该接口中相关的方法，这是 OOP 所无法避免的，并且一旦接口不得不进行修改的时候，所有事情会变得一团糟；AOP 则不会这样，你只需要修改相应的 Aspect，再重新编织（weave）即可。 当然，AOP 也绝对不会代替 OOP。核心的需求仍然会由 OOP 来加以实现，而 AOP 将会和 OOP 整合起来，以此之长，补彼之短。 四、Spring的体系结构 Test层：可以对上面的所有内容进行测试。 Core Container层：核心容器，上层的功能如果要运行必须要借助核心容器。 Beans：用于产生Bean对象的容器 Core：核心 Context：Spring的上下文 SpEL：Spring的表达式 Data Access&#x2F;Integeation：数据访问层 Web：页面 Spring 程序开发入门 一、Spring程序开发步骤1、Spring开发步骤图示 图解说明： 第一步：通过Dao层配置xml文件，在内部编写Bean的id标识。 第二步：service层通过Spring客户端.getBean(id标识)中的id标识向Spring框架申请Bean的对象。 第三步：Spring读取解析xml文件中的配置 第四步：根据从Service层传来的id标识搜索全限定类名路径，然后根据反射创建申请的Bean对象。 第五步：将根据反射创建的Bean对象返回给Service层。 2、Spring开发步骤（1）导入Spring开发的基本包坐标 （2）编写Dao接口和实体类 （3）创建Spring核心配置文件 （4）在Spring配置文件中配置UserDaoImpl （5）使用Spring的API获得Bean实例 二、代码实现1、导入Spring开发的基本包坐标1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、编写Dao接口和实现类123456789101112//Dao接口public interface UserDao &#123; void save();&#125;//实现类public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;Spring 学习&quot;); &#125;&#125; 3、创建Spring核心配置文件12345678910&lt;!-- 在resources文件下新建一个Spring Config文件 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置Dao接口中的id标识 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.Impl.UserDaoImpl&quot;/&gt;&lt;/beans&gt; 4、使用Spring的API获得Bean实例12345678910111213141516package com.itheima;import com.itheima.dao.UserDao;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserDaoTest &#123; public static void main(String[] args) &#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); //测试是否为相应的对象 userDao.save();//运行结果：Spring 学习 &#125;&#125; Spring 配置文件 一、Bean标签的基本配置1、作用用于配置对象交由Spring来创建 默认情况下他调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功 2、基本属性 id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3、范围配置scope：指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的，容器中只有一个对象，每次取出的是同一个对象 prototype 多例的，容器中存在多个对象每次取出的不是同一个对象 request WEB项目中，Spring创建一个Bean对象，将对象存入到request域中 session WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中 global session WEB项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession相当于session 注意事项：singleton和prototype在创建对象的时机是不一样的 singleton： Bean实例化个数：1个 Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 prototype： Bean实例化个数：多个 Bean的实例化时机：当调用getBean()方法时实例化Bean Bean的生命周期： 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被Java的垃圾回收器回收了 4、代码演示123456789101112131415161718192021222324252627282930313233//&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.Impl.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt; /** * 测试scope属性[value = singleton] * 默认值，单例的 */ @Test public void saveTest1()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao1 = (UserDao) app.getBean(&quot;userDao&quot;); UserDao userDao2 = (UserDao) app.getBean(&quot;userDao&quot;); System.out.println(userDao1);//com.itheima.dao.Impl.UserDaoImpl@4232c52b System.out.println(userDao2);//com.itheima.dao.Impl.UserDaoImpl@4232c52b &#125;//&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.Impl.UserDaoImpl&quot; scope=&quot;prototype&quot;/&gt; /** * 测试scope属性[value = prototype] * 多例的 */ @Test public void saveTest2()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao1 = (UserDao) app.getBean(&quot;userDao&quot;); UserDao userDao2 = (UserDao) app.getBean(&quot;userDao&quot;); System.out.println(userDao1);//com.itheima.dao.Impl.UserDaoImpl@536aaa8d System.out.println(userDao2);//com.itheima.dao.Impl.UserDaoImpl@e320068 &#125; 5、生命周期配置属性： init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 代码演示： 1234567891011121314151617181920212223242526272829303132333435//先在UserDaoImpl类中新建如下方法 public UserDaoImpl() &#123; System.out.println(&quot;UserDaoImpl被创建了...&quot;); &#125; public void init()&#123; System.out.println(&quot;初始化了...&quot;); &#125; public void destroy()&#123; System.out.println(&quot;销毁了...&quot;); &#125;//再修改Spring框架的核心配置文件如下，值得注意的是此时scope的值为默认值singleton//&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.Impl.UserDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;//再编写测试方法 @Test public void saveTest()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); System.out.println(userDao); //此处为手动关闭容器，否则无法看见销毁方法被调用执行的结果 ((ClassPathXmlApplicationContext) app).close(); &#125;//运行结果为：/* UserDaoImpl被创建了... 初始化了... com.itheima.dao.Impl.UserDaoImpl@458c1321 销毁了...*/ 6、Bean实例化的三种方式（1）分类 无参构造方法实例化 工厂静态方法实例化 工厂实例方法实例化 （2）工厂静态方法实例化演示①先创建一个Factory包在java目录下，并创建一个静态工厂类 12345678910package com.itheima.factory;import com.itheima.dao.Impl.UserDaoImpl;import com.itheima.dao.UserDao;public class StaticFactory &#123; public static UserDao getUserDao()&#123; return new UserDaoImpl(); &#125;&#125; ②修改Spring的核心配置文件 12 &lt;!-- 静态工厂创建Bean对象 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getUserDao&quot;/&gt; ③编写测试类 12345678910111213 @Test public void saveTest()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); System.out.println(userDao); &#125;/*运行结果： UserDaoImpl被创建了... com.itheima.dao.Impl.UserDaoImpl@2f943d71*/ （3）工厂实例方法实例化演示①同上创建一个动态的工厂类 12345678910package com.itheima.factory;import com.itheima.dao.Impl.UserDaoImpl;import com.itheima.dao.UserDao;public class DynamicFactory &#123; public UserDao getUserDao()&#123; return new UserDaoImpl(); &#125;&#125; ②修改Spring的核心配置文件 1234&lt;!-- 动态工厂创建Bean对象 --&gt;&lt;!-- 先创建动态工厂的对象，在通过工厂对象创建UserDao对象 --&gt;&lt;bean id=&quot;factory&quot; class=&quot;com.itheima.factory.DynamicFactory&quot;/&gt;&lt;bean id=&quot;userDao&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getUserDao&quot;/&gt; ③编写测试类 12345678910111213 @Test public void saveTest()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); System.out.println(userDao); &#125;/*运行结果： UserDaoImpl被创建了... com.itheima.dao.Impl.UserDaoImpl@2f943d71*/ 7、依赖注入（1）分析每次在使用Service时需要从Spring容器中获取Dao实例，能不能将Dao实例和Service实例融合在一起，使Service在创建时，Dao也一起被创建。 （2）概念依赖注入（Dependency Injection）：它是Spring框架核心IOC的体现。 在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍然会调用持久层的方法。 这种业务层和持久层的依赖关系，在使用Spring之后就由Spring来维护了。简单地说，就是等框架把持久层传入业务层，而不用我们自己去获取了。 （3）方式分类： 构造方法（有参构造方法） set方法 ① set方法演示：①创建一个Service包并创建接口和实现类 1234567891011121314151617181920212223//接口public interface UserService &#123; void save();&#125;//实现类public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; System.out.println(&quot;UserServiceIml被创建了...&quot;); getUserDao(); &#125;&#125; ②修改Spring的核心配置文件 1234&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.Impl.UserServiceImpl&quot;&gt; &lt;!-- 将UserDao依赖注入 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; ③编写测试类 1234567891011 @Test public void webTest()&#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService) app.getBean(&quot;userService&quot;); userService.save(); &#125;/* 运行结果 UserDaoImpl被创建了... UserServiceIml被创建了...*/ 注意事项：只有当service对象是通过容器获取的时，才会创建dao的对象。 ② set依赖注入的简便方式P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加简便，主要体现在配置文件中，如下： 首先引入P命名空间 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 在上述的位置添加完命名空间之后，再修改注入方式即可，注入如下： 1&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.Impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt; ③ 有参构造方法演示①在service实体类内部创建无参构造和有参构造 123456public UserServiceImpl() &#123;&#125;public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao;&#125; ②修改Spring的核心配置文件 1234&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.Impl.UserServiceImpl&quot;&gt; &lt;!-- name：实体类中的变量 ref：引用的bean标签id --&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; ③编写测试类 1234567891011 @Test public void webTest()&#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService) app.getBean(&quot;userService&quot;); userService.save(); &#125;/* 运行结果 UserDaoImpl被创建了... UserServiceIml被创建了...*/ （4）数据类型上面的操作都是通过bean标签注入了对象，而除了对象也可以注入普通数据类型、集合等。 分类： 普通数据类型； 引用数据类型； 集合数据类型。 普通数据类型演示： ①在dao实体类内部创建两个基本数据类型的变量并创建set方法 12345678910private String username;private int age;public void setUsername(String username) &#123; this.username = username;&#125;public void setAge(int age) &#123; this.age = age;&#125; ②修改Spring的核心配置文件 12345&lt;!-- 配置Dao接口中的id标识 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.Impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; ③编写测试类 12345678910111213 @Test public void saveTest()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); userDao.save(); &#125;/* 运行结果: zhangsan --- 20 save...*/ 集合数据类型演示： ①在dao实体类内部创建集合数据类型的变量并创建set方法 12345678910111213141516171819 private List&lt;String&gt; stringList; private Map&lt;String, User&gt; map; private Properties properties; public void setStringList(List&lt;String&gt; stringList) &#123; this.stringList = stringList; &#125; public void setMap(Map&lt;String, User&gt; map) &#123; this.map = map; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125;//创建一个User对象，内部属性为 private String username; private int age; ②修改Spring的核心配置文件 123456789101112131415161718192021222324252627282930313233 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.Impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;stringList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;value&gt;ddd&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;u1&quot; value-ref=&quot;user1&quot;/&gt; &lt;entry key=&quot;u2&quot; value-ref=&quot;user2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;ppp1&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;ppp2&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;ppp3&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建User对象 --&gt; &lt;bean id=&quot;user1&quot; class=&quot;com.itheima.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.itheima.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;李四&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; ③编写测试类 12345678910111213141516 @Test public void saveTest()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象 UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); userDao.save(); &#125;/* 运行结果： [aaa, bbb, ccc, ddd] &#123;u1=User&#123;username=&#x27;张三&#x27;, age=20&#125;, u2=User&#123;username=&#x27;李四&#x27;, age=18&#125;&#125; &#123;p3=ppp3, p2=ppp2, p1=ppp1&#125; save...*/ 8、总结12345678910111213&lt;bean&gt; id属性：在容器中Bean标签的唯一标识，不允许重复 class属性：要实例化的Bean的全限定名 scope属性：Bean的作用范围，常用的是Singleton（默认）和prototype &lt;property&gt;标签：属性注入 name属性：属性名称（在实体类中的变量名） value属性：注入的普通属性值 ref属性：注入的对象引用值 &lt;list&gt;标签 &lt;map&gt;标签 &lt;properties&gt;标签 &lt;constructor-arg&gt;标签：构造方法形式 &lt;import&gt;标签：导入其他的Spring分文件 二、引入其他配置文件（分模块开发）实际开发过程中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积庞大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 1&lt;import reosurce=&quot;applicationContext-xxx.xml&quot;/&gt; Spring 相关API 一、ApplicationContext继承体系ApplicationContext：接口类型，代表应用上下文，可以通过实例获得Spring容器中的Bean对象。 ApplicationContext的实现类： ClassPathXmlApplicationContext：它是从类路径下加载配置文件推荐使用这种 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置 AnnotationConfigApplicationContext：当使用注解配置容器对象时，需要使用此类来创建Spring容器，他用来解读注解 二、getBean()方法使用1、源码分析1234567891011 //方式一：传入配置id的值public Object getBean(String name) throws BeansException &#123; this.assertBeanFactoryActive(); return this.getBeanFactory().getBean(name); &#125;//方式二：传入配置实体类的class public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123; this.assertBeanFactoryActive(); return this.getBeanFactory().getBean(requiredType); &#125; 2、测试代码1234567891011121314151617 @Test public void saveTest()&#123; //读取xml配置文件 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //相当于service层通过id标识申请Spring框架创建Bean对象// UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); UserDao userDao = app.getBean(UserDao.class); userDao.save(); &#125;/* 运行结果： [aaa, bbb, ccc, ddd] &#123;u1=User&#123;username=&#x27;张三&#x27;, age=20&#125;, u2=User&#123;username=&#x27;李四&#x27;, age=18&#125;&#125; &#123;p3=ppp3, p2=ppp2, p1=ppp1&#125; save...*/ 注意事项：当配置文件中有多个UserDao实体类配置时不可以使用这种方式创建对象，不然会报错。当存在多个相同实体类的配置对象时，使用第一种方式最好。 参考资料：2020年 最新版 传智黑马Java SSM 阶段 采用IDEA教学","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yemaojun.top/categories/Spring/"}],"tags":[]},{"title":"MyBatis框架学习（四）","slug":"MyBatis框架/MyBatis框架学习（四）","date":"2020-08-07T01:05:59.000Z","updated":"2020-08-08T11:02:18.451Z","comments":true,"path":"2020/08/07/MyBatis框架/MyBatis框架学习（四）/","link":"","permalink":"https://www.yemaojun.top/2020/08/07/MyBatis%E6%A1%86%E6%9E%B6/MyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"MyBatis框架的延迟加载、MyBatis缓存、MyBatis注解开发。","text":"MyBatis框架的延迟加载、MyBatis缓存、MyBatis注解开发。 MyBatis延迟加载策略 一、延迟加载的基本概念1、延迟加载延迟加载是指在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称为懒加载（按需加载）。 2、优点先从单表查询，需要时再从关联表查询，大大提高了数据库性能，因为查询单表要比关联查询多张表速度要快。 3、缺点因为只有当用到数据库时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 4、立即加载不管使用不使用，只要一调用方法，马上发起查询。 5、延迟加载和立即加载的使用时机在一对多、多对多、多对一、一对一的四种表关系中可将其分为具体的两类进行分析： 一对多和多对多：通常在这种情况下都是使用延迟加载的形式进行查询操作。 多对一和一对一：通常在这种情况下都是使用立即加载的形式进行查询操作。 延迟加载指得其实是先查询一张表，然后根据从这张表里获取的数据再去另外一张表进行查询。以前的查询方式是先将两张关联表查询出来，然后通过相互关联的外键和主键再进行查询，这样十分浪费资源。而延迟查询却可以少查一张表，只查询表中的一部分数据。 二、使用assocation实现延迟加载1、编写账户表和用户表的Dao接口12345678910111213//账户表的dao接口 /** * 查询所有账户信息 * @return */ List&lt;Account&gt; findAll();//用户表的dao接口 /** * 根据id查询用户 * @return */ User findById(int id); 2、编写账户表的持久层映射文件12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IAccountDao&quot;&gt; &lt;!-- 定义封装了Account和User的resultMap --&gt; &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射：配置封装user的内容 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;user&quot; select=&quot;com.itheima.dao.IUserDao.findById&quot; column=&quot;uid&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt; select * from account &lt;/select&gt; &lt;!-- 根据id查询账户信息 --&gt; &lt;select id=&quot;findById&quot; resultType=&quot;com.itheima.domain.Account&quot; parameterType=&quot;int&quot;&gt; select * from account where uid = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; association标签： select属性：内容为关联表的全限定dao接口名和方法名组。 colum属性：内容为传递给select方法的参数。 3、开启MyBatis延迟加载策略在SqlMapConfig.xml中添加延迟加载配置 12345&lt;!-- 开启延迟加载的支持 --&gt; &lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; 4、编写测试类进行测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354`package com.itheima.test;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class IAccountDaoTest &#123; private InputStream in = null; private SqlSession session = null; private IAccountDao accountDao; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(true); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） accountDao = session.getMapper(IAccountDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交// session.commit(); //释放资源 session.close(); in.close(); &#125; /** * 查询所有 */ @Test public void findByAllTest()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account: accounts) &#123; System.out.println(&quot;---------------------------&quot;); System.out.println(account); System.out.println(account.getUser()); &#125; &#125;&#125; 运行结果： 三、使用Collection实现延迟加载1、配置编写User实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itheima.domain;import java.util.Date;import java.util.List;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; //一对多关系映射：主表的关系映射应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; public User() &#123; &#125; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 2、编写账户表和用户表的Dao接口1234567891011121314//账户表的Dao接口 /** * 根据用户id查找账户表信息 * @param id 账户表id * @return */ List&lt;Account&gt; findById(int uid);//用户表的Dao接口 /** * 查询所有用户，同时获取到用户下的所有账户信息 * @return */ List&lt;User&gt; findByAll(); 3、编写用户表的持久层映射文件1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 定义User的resultMap --&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; select=&quot;com.itheima.dao.IAccountDao.findById&quot; column=&quot;id&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findByAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据id查询User对象 --&gt; &lt;select id=&quot;findById&quot; resultType=&quot;com.itheima.domain.User&quot; parameterType=&quot;int&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 4、编写测试类进行测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class IUserDaoTest &#123; private InputStream in = null; private SqlSession session = null; private IUserDao userDao; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(true); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交// session.commit(); //释放资源 session.close(); in.close(); &#125; /** * 查询所有 */ @Test public void findAllTest()&#123; List&lt;User&gt; users = userDao.findByAll(); for (User user: users) &#123; System.out.println(&quot;----------------------&quot;); System.out.println(user); System.out.println(user.getAccounts()); &#125; &#125; /** * 根据id查询用户信息 */ @Test public void findByIdTest()&#123; User user = userDao.findById(45); System.out.println(user); &#125;&#125; 运行结果： 执行的语句 MyBatis缓存 一、MyBatis的一级缓存1、缓存的概念缓存是指存在于内存中的临时数据 2、缓存的优点减少和数据库的交互次数，提高执行效率。 3、缓存数据限制（1）适用于缓存的数据 经常查询并且不经常改变的数据。 数据的正确与否对最终结果影响不大的数据。 （2）不适用于缓存的数据 经常改变的数据。 数据的正确与否对最终结果影响很大的数据。 例如：商品的库存（常变）、银行的汇率（对结果影响较大）、股市的牌价。 4、一级缓存一级缓存指的是MyBatis中SqlSession对象的缓存。 当我们执行查询之后，查询的结果会同时存入到SqlSession提供的一块区域。 该区域是一个Map。当我们再次查询同样的数据，MyBatis会先去SqlSession中查询是否有，有的话直接拿来使用。 值得注意的是当SqlSession对象消失时，NyBatis的一级缓存也就消失了。 5、一级缓存的证明（1）编写User实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.itheima.domain;import java.util.Date;import java.util.List;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public User() &#123; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; （2）编写持久层Dao接口12345678910111213141516171819package com.itheima.dao;import com.itheima.domain.User;import java.util.List;public interface IUserDao &#123; /** * 查询所有用户，同时获取到用户下的所有账户信息 * @return */ List&lt;User&gt; findByAll(); /** * 根据id查询用户 * @return */ User findById(int id);&#125; （3）编写持久层Dao的映射文件12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findByAll&quot; resultType=&quot;user&quot;&gt; select * from user u left outer join account a on u.id = a.uid &lt;/select&gt; &lt;!-- 根据id查询User对象 --&gt; &lt;select id=&quot;findById&quot; resultType=&quot;com.itheima.domain.User&quot; parameterType=&quot;int&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; （4）编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class IUserDaoTest &#123; private InputStream in = null; private SqlSession sqlSession = null; private IUserDao userDao; private SqlSessionFactory factory; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 sqlSession = factory.openSession(true); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） userDao = sqlSession.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交// session.commit(); //释放资源 sqlSession.close(); in.close(); &#125; /** * 查询所有 */ @Test public void findByAll()&#123; List&lt;User&gt; users = userDao.findByAll(); for (User user: users) &#123; System.out.println(&quot;----------------------&quot;); System.out.println(user); &#125; &#125; /** * 测试一级缓存 */ @Test public void testFirstLevelCache()&#123; User user1 = userDao.findById(41); User user2 = userDao.findById(41); System.out.println(user1 == user2); &#125;&#125; 运行结果 由上图可知只执行了一次Sql查询语句。而获取的两个User对象也是同一个对象。 （5）重新编写测试类1234567891011121314151617 @Test public void testFirstLevelCache()&#123; User user1 = userDao.findById(41);/*//清除缓存 sqlSession.close(); //再次获取SqlSession对象 sqlSession = factory.openSession();*/ sqlSession.clearCache();//此方法也可以清空缓存区的内容 userDao = sqlSession.getMapper(IUserDao.class); User user2 = userDao.findById(41); System.out.println(&quot;------------------------&quot;); System.out.println(user1 == user2); System.out.println(&quot;------------------------&quot;); &#125; 此时的运行结果为 由上图可知两个对象不一致，并且查询了两次。证明了缓存的存在 6、一级缓存的同步（1）在用户表的Dao接口中新添加一个方法12345/** * 修改用户信息 * @param user 修改用户信息 */void updataUser(User user); （2）编写Dao接口的映射文件1234&lt;!-- 修改用户信息 --&gt; &lt;update id=&quot;updataUser&quot; parameterType=&quot;user&quot;&gt; update user set username = #&#123;username&#125; , address = #&#123;address&#125; where id = #&#123;id&#125; &lt;/update&gt; （3）再次修改之前的测试类这一次此时缓存区的同步信息能力 123456789101112131415161718/** * 测试缓存同步 */@Testpublic void testClearlCache()&#123; //根据id查询用户 User user1 = userDao.findById(41); //更新用户信息 user1.setUsername(&quot;updata user clear cache&quot;); user1.setAddress(&quot;陕西汉中&quot;); userDao.updataUser(user1); //再次查询id为41的对象 User user2 = userDao.findById(41); System.out.println(user1 == user2);&#125; 运行结果 由上面的结果得知这一次并没有从缓存区获取原来的对象，而是在修改完后重新查找了一次第41号对象的结果。 7、一级缓存的分析一级缓存是SqlSession范围的缓存，当调用SqlSession的修改、添加、删除、commit()、close()方法时会清空一级缓存区。 当第一次发起查询用户id为41的用户信息时，先去缓存区中查找缓存区中是否存在id为41的用户信息，如果没有再从数据库中进行查询。 当得到用户信息，将用户信息存储到一级缓存中。 当SqlSession区执行commit操作（增删改），会清空SqlSession中的一级缓存，这样做的目的是为了让SqlSession中的数据始终是最新的信息，避免脏读。 当第二次发起查询id为41的用户信息时，先去缓存区中查找id为41的用户信息是否存在，若存在则直接从缓存区中获取用户信息。 二、二级缓存1、二级缓存二级缓存指的是MyBatis中SqlSessionFactroy对象的缓存。由同一个SqlSessionFactroy对象创建的SqlSession对象。 2、结构图 在开启MyBatis的二级缓存之后 SqlSession1去查询用户信息，将查询到的用户数据存储到二级缓存中。 此时若SqlSession3去执行相同mapper映射下sql，执行commit提交，将会清空该mapper映射下的二级缓存区域数据。 SqlSessiion2查询与SqlSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中读取数据。 3、二级缓存的开启与关闭（1）第一步：在SqlMapConfig.xml开启二级缓存1234&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 （2）第二步：配置相关的Mapper映射文件标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; （3）第三步：配置statement上面的useCache属性1234&lt;!-- 根据 id 查询 --&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 将 UserDao.xml 映射文件中的标签中设置 useCache&#x3D;”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache&#x3D;false，禁用二级缓存。 4、二级缓存测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class SecondLevelCacheTest &#123; private InputStream in = null; private SqlSessionFactory factory; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） factory = new SqlSessionFactoryBuilder().build(in); &#125; @After public void destroy() throws Exception &#123; in.close(); &#125; /** * 测试一级缓存的存在 */ @Test public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao userDao1 = sqlSession1.getMapper(IUserDao.class); User user1 = userDao1.findById(41); sqlSession1.close(); SqlSession sqlSession2 = factory.openSession(); IUserDao userDao2 = sqlSession2.getMapper(IUserDao.class); User user2 = userDao2.findById(41); sqlSession2.close(); System.out.println(&quot;------------------------&quot;); System.out.println(user1 == user2); System.out.println(&quot;------------------------&quot;); &#125;&#125; 运行结果 由上面的图可知只执行了一次，第二次执行是从缓存区中读取的。 这里的false是因为存入SqlSessionFactroy区的是数据而不是对象，所以是两个对象。 5、二级缓存的注意事项在使用二级缓存时，所缓存的类必须要实现 java.io.Serializable 接口这种就可以使用序列化方式来保存对象。 MyBatis注解开发 一、MyBatis注解开发的环境搭建1、常用注解说明 注解 注解说明 @Insert 实现新增 @Updata 实现更新 @Delete 实现删除 @Select 实现查询 @Result 实现结果集封装 @Results 可以与@Result一起使用，封装多个结果集 @ResultMap 实现引用@Results定义的封装 @One 实现一对一结果集封装 @Many 实现一对多结果集封装 @SelectProvider 实现动态SQL映射 @CacheNamespace 实现注解二级缓存的使用 2、配置POM.xml文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;eesy_zhujiekaifa&lt;/groupId&gt; &lt;artifactId&gt;eesy_zhujiekaifa&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、导入数据库信息文件——jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy_mybatisjdbc.username=rootjdbc.password=root 4、导入配置文件解析文件——log4j.properties 5、配置SqlMapConfig.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 引入外部配置 --&gt; &lt;properties resource=&quot;jdbcConfig.properties&quot;/&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定带有注解的dao接口的位置 --&gt; &lt;mappers&gt; &lt;package name=&quot;com.itheima.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 这样注解开放的环境就配置好了，其实和非注解开发的环境搭建是一样的。 二、单表的CRUD操作1、配置实体类对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.itheima.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private String sex; private String address; private Date birthday; public User() &#123; &#125; public User(Integer id, String username, String sex, String address, Date birthday) &#123; this.id = id; this.username = username; this.sex = sex; this.address = address; this.birthday = birthday; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &#x27;&#125;&#x27;; &#125;&#125; 值得注意的是实体类需要实现序列化接口（Serializable） 2、编写实体类的Dao接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.dao;import com.itheima.domain.User;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;import java.util.List;/** * 在mybatis中针对CRUD总共由四个注解 * @Select @Insert @Update @Delete */public interface IUserDao &#123; /** * 查询所有 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); /** * 修改用户信息 * @param user 要修改的用户信息 */ @Update(&quot;update user set username = #&#123;username&#125;,sex = #&#123;sex&#125;,address = #&#123;address&#125;,birthday = #&#123;birthday&#125; where id = #&#123;id&#125;&quot;) int updataUser(User user); /** * 添加用户 * @param user 要添加的用户实体对象 */ @Insert(&quot;insert into user(username,sex,address,birthday) values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;address&#125;,#&#123;birthday&#125;)&quot;) int insertUser(User user); /** * 根据id删除用户信息 * @param id */ @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;) int deleteUser(int id); /** * 根据id查询用户的信息 * @param id 要查询的用户id * @return */ @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User findById(Integer id); /** * 根据用户名字进行模糊查询 * 第一种查询方式需要在传入的名字参数前后添加上&quot;%&quot;才能进行查询 * 第二种方式却不需要 * @param username 要进行模糊查询的用户名字 * @return */// @Select(&quot;select * from user where username like #&#123;username&#125;&quot;) @Select(&quot;select * from user where username like &#x27;%$&#123;value&#125;%&#x27;&quot;) List&lt;User&gt; findByName(String username); /** * 查询所有的记录总条数 * @return 返回总的条数 */ @Select(&quot;select count(*) from user&quot;) Integer findTotal();&#125; 3、编写测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;public class AnnoCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession sqlSession; private IUserDao userDao; @Before public void init() throws Exception&#123; //使用输入流加载配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //根据输入流创建SqlSessionFactroy对象 factory = new SqlSessionFactoryBuilder().build(in); //根据SqlSessionFactroy对象构建SqlSession对象 sqlSession = factory.openSession(true); //使用SqlSession对象代理增强Dao接口的方法 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception&#123; //释放资源 sqlSession.close(); in.close(); &#125; /** * 查询所有用户信息 */ @Test public void findAllTest()&#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 新增用户 */ @Test public void insertUserTest()&#123; System.out.println(userDao.insertUser(new User(null,&quot;mybatis insert&quot;,&quot;男&quot;,&quot;西安&quot;,new Date()))); &#125; /** * 修改用户信息 */ @Test public void updataUserTest()&#123; System.out.println(userDao.updataUser(new User(54,&quot;mybatis updata&quot;,&quot;女&quot;,&quot;成都&quot;,new Date()))); &#125; /** * 根据用户的id查询用户信息 */ @Test public void findByIdTest()&#123; System.out.println(userDao.findById(54)); &#125; /** * 模糊查询 */ @Test public void findByNameTest()&#123;// List&lt;User&gt; users = userDao.findByName(&quot;%王%&quot;); List&lt;User&gt; users = userDao.findByName(&quot;王&quot;); for (User user: users) &#123; System.out.println(user); &#125; &#125; /** * 查询总记录数 */ @Test public void findTotalTest()&#123; System.out.println(userDao.findTotal()); &#125; /** * 根据用户id删除用户信息 */ @Test public void deletdUserTest()&#123; System.out.println(userDao.deleteUser(54)); &#125;&#125; 三、建立实体类属性和数据库表列的对应关系1、修改实体类表的属性12345private Integer userId; private String username; private String userSex; private String userAddress; private Date userBirthday; 数据库列的名称 2、重新编写Dao接口内容12345678910111213141516171819202122232425262728293031323334353637383940414243package com.itheima.dao;import com.itheima.domain.User;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.ResultMap;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import java.util.List;public interface IUserDao &#123; /** * 查询所有 * @return */ @Select(&quot;select * from user&quot;) @Results(id = &quot;userMap&quot;,value = &#123; @Result(id = true,column = &quot;id&quot;,property = &quot;userId&quot;), @Result(column = &quot;username&quot;,property = &quot;username&quot;), @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;), @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;), @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;), &#125;) List&lt;User&gt; findAll(); /** * 根据用户的id查询用户信息 * @param id 要查询的用户id * @return */ @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) @ResultMap(value = &#123;&quot;userMap&quot;&#125;) User findById(Integer id); /** * 根据用户的姓名模糊查询 * @param username 要进行模糊查询的用户的名字 * @return */ @Select(&quot;select * from user where username like #&#123;username&#125;&quot;) @ResultMap(&quot;userMap&quot;) List&lt;User&gt; findByName(String username);&#125; @Results注解 id属性和非注解时的resultMap一样，是该对应关系的唯一标识。 value属性用于配置实体类和数据库表列的对应关系。 @ResultMap注解：用于调用配置好的对应关系。 3、编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class AnnotationCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession sqlSession; private IUserDao userDao; @Before public void init() throws Exception&#123; //使用输入流读取用户的配置 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //根据配置文件构造SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用SqlSessionFactory生产SqlSession sqlSession = factory.openSession(true); //使用SqlSession代理增强Dao接口的方法 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After public void destory() throws Exception&#123; //释放资源 sqlSession.close(); in.close(); &#125; /** * 查询所有用户信息 */ @Test public void findAllTest()&#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 根据用户的id查询用户信息 */ @Test public void findByIdTest()&#123; System.out.println(userDao.findById(42)); &#125; /** * 模糊查询 */ @Test public void findByNameTest()&#123;// List&lt;User&gt; users = userDao.findByName(&quot;%王%&quot;); List&lt;User&gt; users = userDao.findByName(&quot;%王%&quot;); for (User user: users) &#123; System.out.println(user); &#125; &#125;&#125; 四、一对一注解查询配置1、新添加一个Account实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.itheima.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money;// 一对一的关系映射：一个账户只能对应一个用户 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, uid=&quot; + uid + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 2、配置Account实体类的Dao接口1234567891011121314151617181920212223242526272829303132333435package com.itheima.dao;import com.itheima.domain.Account;import org.apache.ibatis.annotations.One;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.mapping.FetchType;import java.util.List;public interface IAccountDao &#123; /** * 查询所有 * @return */ @Select(&quot;select * from account&quot;) @Results(id = &quot;accountMap&quot;,value = &#123; @Result(id = true,column = &quot;id&quot; ,property = &quot;id&quot;), @Result(column = &quot;uid&quot;,property = &quot;uid&quot;), @Result(column = &quot;money&quot;,property = &quot;money&quot;), @Result(property = &quot;user&quot;,column = &quot;uid&quot;,one = @One( select = &quot;com.itheima.dao.IUserDao.findById&quot;,fetchType = FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll();// FetchType.EAGER:立即加载 FetchType.LAZY:延迟加载 FetchType.DEFAULT:前两种选择其中一种 /** * 根据用户账户表中的uid查询 * @param uid * @return */ @Select(&quot;select * from account where uid = #&#123;uid&#125;&quot;) Account findByUid(Integer uid);&#125; 此时使用的依然是**@Result注解**，select属性是关联表的实体类的dao接口的方法，fetchType属性是延迟与立即加载的设置。 3、编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.itheima.test;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class AccountTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession sqlSession; private IAccountDao accountDao; @Before public void init() throws Exception&#123; in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); factory = new SqlSessionFactoryBuilder().build(in); sqlSession = factory.openSession(); accountDao = sqlSession.getMapper(IAccountDao.class); &#125; @After public void destory() throws Exception&#123; sqlSession.commit(); sqlSession.close(); in.close(); &#125; /** * 查询所有 */ @Test public void findAll()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account: accounts) &#123; System.out.println(&quot;------------------------------&quot;); System.out.println(account); System.out.println(account.getUser()); &#125; &#125;&#125; 五、一对多注解查询配置1、修改User实体类像原先的User实体类中添加一个Account实体类的List集合 12345678910// 一对多的关系映射 private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; 2、修改User实体类的Dao接口注解1234567891011121314/** * 查询所有 * @return */@Select(&quot;select * from user&quot;)@Results(id = &quot;userMap&quot;,value = &#123; @Result(id = true,column = &quot;id&quot;,property = &quot;userId&quot;), @Result(column = &quot;username&quot;,property = &quot;username&quot;), @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;), @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;), @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;), @Result(property = &quot;accounts&quot;,column = &quot;id&quot;,many = @Many(select = &quot;com.itheima.dao.IAccountDao.findByUid&quot;,fetchType = FetchType.LAZY))&#125;)List&lt;User&gt; findAll(); 3、编写测试方法123456789101112/** * 查询所有用户信息 */@Testpublic void findAllTest()&#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(&quot;--------------------------&quot;); System.out.println(user); System.out.println(user.getAccounts()); &#125;&#125; 总结：一对多和一对一的配置方式相同。 六、注解开发的二级缓存1、开启方法（1）在SqlMapConfig.xml添加配置文件1234&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 但是这个配置可以不添加，因为在MyBatis的官方文档中默认值是”true“，即默认开启。 （2）在需要开启二级缓存的Dao接口上添加注解12//在需要开启二级缓存的Dao接口上添加注解@CacheNamespace(blocking = true) 如此二级缓存就开启完成了。 参考资料 传智黑马MyBatis [https://www.bilibili.com/video/BV1SJ411679L]:","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.yemaojun.top/categories/Mybatis/"}],"tags":[]},{"title":"hexo博客部署到coding","slug":"hexo博客使用过程中的问题汇总/hexo博客部署到coding","date":"2020-08-06T09:08:09.000Z","updated":"2020-08-08T11:12:55.646Z","comments":true,"path":"2020/08/06/hexo博客使用过程中的问题汇总/hexo博客部署到coding/","link":"","permalink":"https://www.yemaojun.top/2020/08/06/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0coding/","excerpt":"之前是把hexo博客搭建在github上的，但是由于github在日常访问方面存在问题，所以这次将博客也部署到coding。当然虽然是部署到coding上但并不是说就不能再次访问之前github上的博客了。","text":"之前是把hexo博客搭建在github上的，但是由于github在日常访问方面存在问题，所以这次将博客也部署到coding。当然虽然是部署到coding上但并不是说就不能再次访问之前github上的博客了。 部署hexo博客到coding上 1、注册Coding账号先进入Coding的官方网站注册一个账号，注册账号时需要创建一个团队名字（虽然没有必要要求，但建议注册成非中文名称的）。 2、准备创建项目在创建项目之前先注册一个SSH密钥到自己的账号。 （1）点击自己的头像点击自己右上角的头像，在弹出的下拉列表中选择个人账户设置。 然后在左侧导航栏选择SSH公钥 （2）打开自己的Git Bash打开Git Bash输入 cd ~&#x2F;.ssh 如果出现如下图所示的信息则说明没有创建密钥 但若是出现如下所示的信息则可直接跳到第三步 出现第一张图片所示的原因是因为这台设备并没有配置SSH公钥。 先配置自己Git的name和邮箱 **git config –global user.name “xxx” git config –global user.email “your e-mail” ** 此处的”your e-mail”指的是当初注册Github的邮箱或是Coding时登录的邮箱。 输入如下指令即可配置 ssh-keygen -t rsa -C “your e-mail” 此处的”your e-mail”同上 （3）配置SSH密钥在上面输入cd ~&#x2F;.ssh没有问题的情况下进入如下路径 C:&#x2F;用户&#x2F;XXX&#x2F;.ssh 文件目录下用记事本打开 “id_rsa.pub” 文件复制里面的内容 此时再点击自己的头像（右上角）选择个人账户设置进入到如下界面 选择红圈圈中的左侧导航栏选项进入下面的界面，再选中圈中的按钮 开始添加SSH公钥 添加成功之后会在密钥SSH密钥的界面看到如下内容 这样便说明SSH公钥添加成功了！ （4）检测能否连接到Coding打开Git Bash输入下面的指令 ssh -T &#103;&#105;&#x74;&#64;&#99;&#111;&#100;&#x69;&#110;&#x67;&#46;&#110;&#x65;&#116; 若出现下面的情况 说明防火墙完全屏蔽了端口 22 ，这时候不要慌张，直接输入如下命令使用 Coding 提供的 443 端口 SSH 服务即可解决： ssh -T -p 443 &#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#45;&#115;&#115;&#x68;&#46;&#99;&#x6f;&#100;&#105;&#x6e;&#x67;&#x2e;&#x6e;&#101;&#x74; 接着会显示是否继续，选择 yes 继续，如果提示下列内容成功，即 SSH 公钥配置成功： 3、开始创建项目（1）开始创建项目注册完成上面的配置之后点击如图所示的地方进入项目界面创建项目 （2）选择模板这里选择第三个项目模板 （3）填写创建项目的必要信息 之后会弹出一个添加成员的选项如下，直接关闭即可。 （4）接着在左侧导航栏创建静态页面如图圈中的内容，之后按照图片提示进行部署 来到接下来的页面 （5）部署静态页面身份认证完成之后来到如下页面 来到如下页面就说明页面部署完成了 （6）配置SSH公钥在左侧导航栏选择圈中的内容 4、配置本地的项目（1）配置博客主文件打开自己hexo博客根目录下的 _config.yml 文件，在之前部署Github时填写SSH的位置修改为如下内容 （2）Coding 静态文件部署打开 Hexo 主目录下的 source 文件，新建文件 Staticfile ，这个文件是 Coding 静态文件部署的标志，注意文件名字必须为 Staticfile，否则 Coding 上无法完成静态文件的部署，如下图所示: 5、上传本地的文件到Coding接下来在自己的本地博客文件中打开Git Bash输入下面的指令即可完成部署 12hexo g #生成静态网页hexo d #开始部署上传本地代码到github和coding 这个时候可以在刚刚的显示访问地址的页面看见自己的代码上传了 再访问访问地址即可查看自己的博客。 参考资料： Hexo部署博客到Github和Coding,看这一篇就够了 将hexo部署到Coding","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://www.yemaojun.top/categories/hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[]},{"title":"MyBatis框架学习（三）","slug":"MyBatis框架/MyBatis框架学习（三）","date":"2020-08-05T02:13:46.000Z","updated":"2020-08-07T01:36:40.191Z","comments":true,"path":"2020/08/05/MyBatis框架/MyBatis框架学习（三）/","link":"","permalink":"https://www.yemaojun.top/2020/08/05/MyBatis%E6%A1%86%E6%9E%B6/MyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"本章学习MyBatis中的连接池技术与事务深入。MyBatis基于xml配置动态sql语句的使用。MyBatyis中的多表操作。","text":"本章学习MyBatis中的连接池技术与事务深入。MyBatis基于xml配置动态sql语句的使用。MyBatyis中的多表操作。 MyBatis中的连接池 一、连接池的基本介绍1、优点使用连接池技术可以使我们的开发效率提高，可以减少获取连接数据库的所消耗的时间减少。 2、作用 连接池就是用于存储连接的一个容器； 容器其实本质是一个集合对象，而且该集合对象必须是线程安全的，不能让两个线程拿到同一个连接； 该集合还必须实现队列的特性（先进先出）。 3、MyBatis连接池的分类MyBatis中的数据源dataSource分为以下几类 由上图可以看出MyBatis的数据源分为三类： UNPOOLED 不使用连接池的数据源 POOLED 使用连接池的数据源 JBDI 使用JDNI实现的数据源 MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource、PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。 PooledDataSource和UnpooledDataSource都实现了java.lang.DataSource接口。并且PooledDataSource持有一个UnpooledDataSource的引用。当PooledDataSource需要创建java.lang.Connection实例对象时，还是通过UnpooledDataSource来创建的，PooledDataSource只是提供一种缓存连接池机制。 4、MyBatis中数据源的配置数据源的配置在SqlMapConfig.xml文件中，具体配置如下 12345678&lt;!-- 配置数据源（也叫连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; MyBatis在初始化时，根据的type属性来创建相应类型的数据源DataSource，即： type&#x3D;“POOLED”：MyBatis会创建PooledDataSource实例 **type&#x3D;”UNPOOLED”**：MyBatis会创建UnpooledDataSource实例 **type&#x3D;”JNDI”**：MyBatis会从JNDI服务上查找DataSource实例，然后返回使用。 5、MyBatis中DataSource的存取MyBatis是通过工厂模式来创建数据源DataSource对象的，MyBatis定义了抽象的工厂接口org.apache.ibatis.datasource.DataSourceFactory，通过其getDataSource（）方法返回数据源DataSource。 MyBatis 创建了 DataSource 实例后，会将其放到 Configuration 对象内的 Environment 对象中， 供以后使用。 6、MyBatis中连接的获取过程分析当我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建java.lang.Connection对象。也就是说java.lang.Connection对象的创建会一直延迟到SQL语句执行的时候才创建。 12345678@Testpublic void testSql() throws Exception &#123; InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = factory.openSession(); List&lt;User&gt; list = sqlSession.selectList(&quot;findUserById&quot;,41); System.out.println(list.size());&#125; 由上面的代码可知，只有知道第四条语句（sqlSession.selectList(“findUserById”,41)）的时候，才会触发MyBatis在底层执行下面的方法来创建java.lang.Connection对象。 下面时获取连接的源码 总结：真正打开连接的时间点，只是在执行SQL语句的时候才会进行。这样做的原因是因为数据库连接是十分宝贵的资源，只有在要用到的时候才去获取并打开连接，当我们使用完毕之后再立即将数据库连接归还到连接池中。 二、MyBatis中的事务控制1、MyBatis中的事务提交方式MyBatis中的事务提交方式本质就是调用JDBC的setAutoCommit（）来实现事务控制的。 1234567891011121314151617181920212223242526272829@Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交 session.commit(); //释放资源 session.close(); in.close(); &#125;@Testpublic void testSaveUser() throws Exception &#123; User user = new User(); user.setUsername(&quot;mybatis user09&quot;); int res = userDao.saveUser(user); System.out.println(res); System.out.println(user.getId());&#125; 在控制台的输出结果为： 由上面可知我们每次进行CUD操作时都要手动的进行事务提交。原因是因为setAutoCommit（）方法在执行的时候的值被设置为false，所以在CUD操作时都需调用sqlSession（）方法手动的提交操作。 2、MyBatis中自动提交事务CUD过程中之所以必须使用sqlSession.commit（）提交事务，主要原因是在连接池中取出的连接 都会调用connection.setAutoCommit（false）方法提交事务。这样就必须使用sqlSession.commit（）方法手动提交，相当于使用了JDBC中的connection.commit（）方法实现事务提交。 自动提交事务的修改代码如下： 1234567891011121314151617181920@Beforepublic void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //创建SqlSession工厂对象 factory = builder.build(in); //使用工厂生产SqlSession对象 session = factory.openSession(true);//此处传入一个布尔类型的参数 //使用SqlSession创建Dao接口的代理对象（增强其中的方法） userDao = session.getMapper(IUserDao.class);&#125;@Afterpublic void destroy() throws Exception &#123; //释放资源 session.close(); in.close();&#125; 此时事务便会被设置为自动提交，同样可以实现CUD操作时记录的保存。但就编程而言，设置为自动提交方式为false更为常用。 三、MyBatis的动态SQL语句在刚开始入门的时候我们所学习的SQL都是比较简单的，但当我们的业务逻辑变得复杂时，我们的SQL是动态变化的。 1、动态SQL语句之标签在根据实体类的不同取值，使用不同的SQL语句来进行查询。比如id不为空时可以根据id查询，如果username不为空时还需要加入username作为查询的约束条件。 （1）持久层Dao接口12345/** * 修改用户信息 * @param user */int updateUser(User user); （2）持久层Dao映射配置12345678910111213141516171819&lt;!-- 修改用户信息 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test=&quot;birthday != birthday&quot;&gt; birthday = #&#123;birthday&#125;, &lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt; address = #&#123;address&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; 注意事项：标签的test属性写的是对象的属性名，如果是包装类的对象要使用OGNL表达式的写法 （3）测试12345678/** * 修改数据库中一条信息 */@Testpublic void updateUserTest()&#123; User user = new User(53,&quot;wangwu&quot;,null,&quot;男&quot;,null); System.out.println(userDao.updateUser(user));//输出结果为1，说明数据库中有一条语句因为这条语句发生了改变&#125; 2、动态SQL语句之标签where也可以使用动态的标签来简化开发 （1）持久层Dao的映射配置123456789101112&lt;!-- 根据用户信息查询 --&gt; &lt;select id=&quot;findByUser&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;username!=null and username != &#x27;&#x27; &quot;&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3、动态SQL语句之标签（1）需求当传入多个id查询用户信息，可以使用下面的sql语句实现： SELECT * FROM USER WHERE username LIKE ‘%张%’ AND (id &#x3D; 10 OR id &#x3D; 98 OR id &#x3D; 16); SELECT * FROM USER WHERE username LIKE ‘%张%’ AND id IN (10,98,16); 在进行范围查询时就需要将一个集合中的值作为动态添加进来。 （2）实现方式——在QueryVo中加入一个List集合用于封装参数12345678public class QueryVo implements Serializable &#123; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123;return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123;this.ids = ids; &#125; &#125; （3）持久层Dao接口123456/*** 根据 id 集合查询用户* @param vo* @return*/List&lt;User&gt; findInIds(QueryVo vo); （4）持久层Dao映射配置12345678910111213&lt;!-- 查询所有用户在 id 的集合之中 --&gt; &lt;select id=&quot;findInIds&quot; resultType=&quot;user&quot; parameterType=&quot;queryvo&quot;&gt;&lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;!-- 简化编写的sql语句，具体操作在第四个知识点 --&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot;id in ( &quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 标签的属性： collection：代表要遍历的集合元素，注意编写时不要写#{}； open：代表语句要开始的部分； close：代表结束部分； item：代表遍历集合的每个元素，生成的变量名； sperator：代表分隔符。 （5）编写测试用例123456789101112131415@Testpublic void testFindInIds() &#123; QueryVo vo = new QueryVo(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(41); ids.add(42); ids.add(43); ids.add(46); ids.add(57); vo.setIds(ids); List&lt;User&gt; users = userDao.findInIds(vo); for(User user : users) &#123; System.out.println(user); &#125; &#125; 四、MyBatis中简化编写的SQL片段1、定义重复出现的sql语句片段1234&lt;!-- 抽取重复的语句代码片段 --&gt;&lt;sql id=&quot;defaultSql&quot;&gt; select * from user&lt;/sql&gt; 2、引用代码片段12345678910&lt;!-- 根据上面配置的sql语句配置查询所有的操作 --&gt;&lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;&lt;/select&gt;&lt;!-- 根据id查询 --&gt;&lt;select id=&quot;findById&quot; resultType=&quot;User&quot; parameterType=&quot;int&quot;&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt; where id = #&#123;id&#125;&lt;/select&gt; 五、MyBatis多表查询之一对一通过Account查询对应的User信息 1、环境搭建（1）数据库搭建1234567891011121314--在之前的数据库中再次建一个account表和三条账户信息--DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT &#x27;编号&#x27;, `UID` int(11) default NULL COMMENT &#x27;用户编号&#x27;, `MONEY` double default NULL COMMENT &#x27;金额&#x27;, PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `account`(`ID`,`UID`,`MONEY`) values (1,46,1000),(2,45,1000),(3,46,2000); 数据库中数据详情 user表 account表 （2）创建maven工程 2、创建account表的实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money;// 从表关系映射应该包含主表的实体对象（一对一关系映射） private User user; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, uid=&quot; + uid + &quot;, money=&quot; + money + &quot;, user=&quot; + user + &#x27;&#125;&#x27;; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; 创建账户表与用户表的另一实体类，用于封装数据 数据格式（account[id,uid,money] accountUser[username,address]） 123456789101112131415161718192021222324252627282930package com.itheima.domain;public class AccountUser extends Account &#123; private String username; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return super.toString() + &quot; AccountUser&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 3、创建account表的持久层接口12345678910111213141516171819package com.itheima.dao;import com.itheima.domain.Account;import com.itheima.domain.AccountUser;import java.util.List;public interface IAccountDao &#123; /** * 查询所有账户信息 * @return */ List&lt;Account&gt; findAll(); /** * 查询所有的AccountUser信息 * @return */ List&lt;AccountUser&gt; findAllAccount();&#125; 4、编写持久层Dao接口的映射配置12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IAccountDao&quot;&gt; &lt;!-- 定义封装了Account和User的resultMap --&gt; &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射：配置封装user的内容 --&gt; &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt; select a.*,u.username,u.address from account a , user u where u.id = a.uid &lt;/select&gt; &lt;!-- 查询所有账户信息和用户名以及地址信息 --&gt; &lt;select id=&quot;findAllAccount&quot; resultType=&quot;com.itheima.domain.AccountUser&quot;&gt; select a.*,u.username,u.address from account a , user u where u.id = a.uid &lt;/select&gt;&lt;/mapper&gt; association标签：当实体类中包含另一个实体类对象作为成员变量时，封装结果集时使用该标签。 总结：封装的结果集中包含另外一张表的信息，且另外一张表的实体类作为查询表的成员变量时使用该标签封装另一张表的数据。 标签内部的标签与resultMap标签一致，id标签为另外一张表的主键信息，result标签为其余封装的列的信息。 5、编写测试用例用于结果测试1234567891011121314151617181920212223242526272829303132333435363738394041/** * 查询所有 */ @Test public void findByAllTest()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account: accounts) &#123; System.out.println(&quot;---------------------------&quot;); System.out.println(account); System.out.println(account.getUser()); &#125; &#125;/*运行结果：---------------------------Account&#123;id=null, uid=46, money=1000.0, user=User&#123;id=1, username=&#x27;老王&#x27;, birthday=null, sex=&#x27;null&#x27;, address=&#x27;北京&#x27;&#125;&#125;User&#123;id=1, username=&#x27;老王&#x27;, birthday=null, sex=&#x27;null&#x27;, address=&#x27;北京&#x27;&#125;--------------------------- Account&#123;id=null, uid=45, money=1000.0, user=User&#123;id=2, username=&#x27;传智播客&#x27;, birthday=null, sex=&#x27;null&#x27;, address=&#x27;北京金燕龙&#x27;&#125;&#125; User&#123;id=2, username=&#x27;传智播客&#x27;, birthday=null, sex=&#x27;null&#x27;, address=&#x27;北京金燕龙&#x27;&#125; --------------------------- Account&#123;id=null, uid=46, money=2000.0, user=User&#123;id=3, username=&#x27;老王&#x27;, birthday=null, sex=&#x27;null&#x27;, address=&#x27;北京&#x27;&#125;&#125; User&#123;id=3, username=&#x27;老王&#x27;, birthday=null, sex=&#x27;null&#x27;, address=&#x27;北京&#x27;&#125;*/ /** * 查询所有账户和用户名与地址 */ @Test public void findByAccountTest()&#123; List&lt;AccountUser&gt; accountUsers = accountDao.findAllAccount(); for (AccountUser accountUser: accountUsers) &#123; System.out.println(accountUser); &#125; &#125;/*运行结果Account&#123;id=1, uid=46, money=1000.0, user=null&#125; AccountUser&#123;username=&#x27;老王&#x27;, address=&#x27;北京&#x27;&#125;Account&#123;id=2, uid=45, money=1000.0, user=null&#125; AccountUser&#123;username=&#x27;传智播客&#x27;, address=&#x27;北京金 燕龙&#x27;&#125;Account&#123;id=3, uid=46, money=2000.0, user=null&#125; AccountUser&#123;username=&#x27;老王&#x27;, address=&#x27;北京&#x27;&#125;*/ 六、MyBatis多表查询之一对多查询通过User查询Account的信息 1、User实体类的修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itheima.domain;import java.util.Date;import java.util.List;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; //一对多关系映射：主表的关系映射应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; public User() &#123; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2、编写持久层Dao接口12345678910111213141516171819package com.itheima.dao;import com.itheima.domain.User;import java.util.List;public interface IUserDao &#123; /** * 查询所有用户，同时获取到用户下的所有账户信息 * @return */ List&lt;User&gt; findByAll(); /** * 根据id查询用户 * @return */ User findById(int id);&#125; 3、编写持久层Dao接口的映射配置123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 定义User的resultMap --&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findByAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user u left outer join account a on u.id = a.uid &lt;/select&gt; &lt;!-- 根据id查询User对象 --&gt; &lt;select id=&quot;findById&quot; resultType=&quot;com.itheima.domain.User&quot; parameterType=&quot;int&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; collection标签：与上面的association标签大致一样，不过该标签使用的对象是集合对象而不是实体类对象。 4、编写接口Dao的测试用例123456789101112/** * 查询所有 */@Testpublic void findByAll()&#123; List&lt;User&gt; users = userDao.findByAll(); for (User user: users) &#123; System.out.println(&quot;----------------------&quot;); System.out.println(user); System.out.println(user.getAccounts()); &#125;&#125; 运行的结果为 七、MyBatis多表查询之多对多通过角色表Role查询User信息多对多 1、环境搭建123456789101112131415161718192021222324DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `ID` int(11) NOT NULL COMMENT &#x27;编号&#x27;, `ROLE_NAME` varchar(30) default NULL COMMENT &#x27;角色名称&#x27;, `ROLE_DESC` varchar(60) default NULL COMMENT &#x27;角色描述&#x27;, PRIMARY KEY (`ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,&#x27;院长&#x27;,&#x27;管理整个学院&#x27;),(2,&#x27;总裁&#x27;,&#x27;管理整个公司&#x27;),(3,&#x27;校长&#x27;,&#x27;管理整个学校&#x27;);DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `UID` int(11) NOT NULL COMMENT &#x27;用户编号&#x27;, `RID` int(11) NOT NULL COMMENT &#x27;角色编号&#x27;, PRIMARY KEY (`UID`,`RID`), KEY `FK_Reference_10` (`RID`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user_role`(`UID`,`RID`) values (41,1),(45,1),(41,2); 数据库中数据详情 role表 role_user中间表 （2）创建maven工程 2、编写角色表的实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.itheima.domain;import java.io.Serializable;import java.util.List;public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户（所以多对多可以简化成一对多去查询） private List&lt;User&gt; users; public Integer getRoleId() &#123; return roleId; &#125; public void setRoleId(Integer roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleDesc() &#123; return roleDesc; &#125; public void setRoleDesc(String roleDesc) &#123; this.roleDesc = roleDesc; &#125; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return &quot;Role&#123;&quot; + &quot;roleId=&quot; + roleId + &quot;, roleName=&#x27;&quot; + roleName + &#x27;\\&#x27;&#x27; + &quot;, roleDesc=&#x27;&quot; + roleDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 3、编写角色表的持久层Dao接口12345678910111213package com.itheima.dao;import com.itheima.domain.Role;import java.util.List;public interface IRoleDao &#123; /** * 查询所有 * @return */ List&lt;Role&gt; findAll();&#125; 4、编写持久层Dao接口的配置文件123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IRoleDao&quot;&gt; &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt; &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;/&gt; &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt; &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;/&gt; &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt; &lt;!-- 此处的r.id的别名rid是为了和上面的rid相匹配，若不起此别名数据查询会出现问题 --&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt;&lt;/mapper&gt; 5、编写测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.itheima.test;import com.itheima.dao.IRoleDao;import com.itheima.domain.Role;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class IRoleDaoTest &#123; private InputStream in = null; private SqlSession session = null; private IRoleDao iRoleDao; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(true); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） iRoleDao = session.getMapper(IRoleDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交// session.commit(); //释放资源 session.close(); in.close(); &#125; @Test public void findAllTest()&#123; List&lt;Role&gt; roles = iRoleDao.findAll(); for (Role role : roles) &#123; System.out.println(&quot;-----------------------&quot;); System.out.println(role); System.out.println(role.getUsers()); &#125; &#125;&#125; 运行结果为; 通过User表进行多对多查询Account表信息 1、编写用户表的实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itheima.domain;import java.util.Date;import java.util.List;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address； //多对多关系映射：主表的关系映射应该包含从表的集合引用 private List&lt;Role&gt; roles; public User() &#123; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public List&lt;Role&gt; getRoles() &#123; return roles; &#125; public void setRoles(List&lt;Role&gt; roles) &#123; this.roles = roles; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2、编写角色表的持久层Dao接口12345/** * 查询用户表中对应的角色表中的所有信息 * @return */ List&lt;User&gt; findAll(); 3、编写持久层Dao接口的配置12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;resultMap id=&quot;userRoleMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;collection property=&quot;roles&quot; ofType=&quot;role&quot;&gt; &lt;id property=&quot;roleId&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt; &lt;result property=&quot;roleDesc&quot; column=&quot;role_Desc&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询用户表中的所有角色信息 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userRoleMap&quot;&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on ur.uid = u.id left outer join role r on r.id = ur.rid &lt;/select&gt;&lt;/mapper&gt; 4、编写测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class IUserDaoTest &#123; private InputStream in = null; private SqlSession session = null; private IUserDao userDao; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(true); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交// session.commit(); //释放资源 session.close(); in.close(); &#125; @Test public void findAllTest()&#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(&quot;---------------------&quot;); System.out.println(user); System.out.println(user.getRoles()); &#125; &#125;&#125; 运行结果： 八、JNDI搭建maven的war工程1、JNDI的基本概念JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。 目录服务是命名服务的一种自然扩展。两者之间的关键差别是目录服务中对象不但可以有名称还可以有属性（例如，用户有email地址），而命名服务中对象没有属性。 2、创建一个war工程（1）create new modules创建maven下的webapp工程 （2）填写坐标信息 （3）在创建好的项目的main目录下创建文件夹在main目录下新建java和resoures，并将两个文件设置为source root和resoures root源码文件 在test目录下新建一个java文件夹，设置为test source root文件夹 （4）导入依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;day03_eesy_jndi&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;day03_eesy_jndi Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;day03_eesy_jndi&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; （5）修改SqlMapConfig.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置实体类的别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- 配置mysql环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置事务类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（也叫连接池） --&gt; &lt;dataSource type=&quot;JNDI&quot;&gt; &lt;property name=&quot;data_source&quot; value=&quot;java:comp/env/jdbc/eesy_mybatis&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名 &lt;mapper class=&quot;com.itheima.dao.IUserDao&quot;/&gt; --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/dao/IAccountDao.xml&quot;/&gt; &lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; （6）在webapp目录下新建配置文件在webapp目录下新建META-INF文件，并在文件夹中导入数据库配置文件context.xml 以下是context.xml文件配置的数据库文件 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context&gt;&lt;!-- &lt;Resource name=&quot;jdbc/eesy_mybatis&quot; 数据源的名称type=&quot;javax.sql.DataSource&quot; 数据源类型auth=&quot;Container&quot; 数据源提供者maxActive=&quot;20&quot; 最大活动数maxWait=&quot;10000&quot; 最大等待时间maxIdle=&quot;5&quot; 最大空闲数username=&quot;root&quot; 用户名password=&quot;1234&quot; 密码driverClassName=&quot;com.mysql.jdbc.Driver&quot; 驱动类url=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot; 连接url字符串/&gt; --&gt;&lt;Resource name=&quot;jdbc/eesy_mybatis&quot;type=&quot;javax.sql.DataSource&quot;auth=&quot;Container&quot;maxActive=&quot;20&quot;maxWait=&quot;10000&quot;maxIdle=&quot;5&quot;username=&quot;root&quot;password=&quot;root&quot;driverClassName=&quot;com.mysql.jdbc.Driver&quot;url=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt;&lt;/Context&gt; （7）修改index.jsp文件12345678910111213141516171819202122232425262728293031323334&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;org.apache.ibatis.io.Resources&quot; %&gt;&lt;%@ page import=&quot;org.apache.ibatis.session.SqlSessionFactoryBuilder&quot; %&gt;&lt;%@ page import=&quot;org.apache.ibatis.session.SqlSessionFactory&quot; %&gt;&lt;%@ page import=&quot;org.apache.ibatis.session.SqlSession&quot; %&gt;&lt;%@ page import=&quot;com.itheima.dao.IUserDao&quot; %&gt;&lt;%@ page import=&quot;com.itheima.domain.User&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;% //此处的代码是之前测试的main方法中的代码 //1.读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.根据配置文件构建SqlSessionFactory SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用SqlSessionFactory创建SqlSession对象 SqlSession sqlSession = factory.openSession(); //4.使用SqlSession构建Dao的代理对象 IUserDao userDao = sqlSession.getMapper(IUserDao.class); //5.执行dao中的findAll方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users)&#123; System.out.println(user); &#125; //6.释放资源 sqlSession.close(); in.close();%&gt;&lt;/body&gt;&lt;/html&gt; （8）配置Tomcat项目![JDNI Tomcat](MyBatis框架学习（三）&#x2F;JDNI Tomcat.JPG) 启动服务器打开浏览器即可在控制台看到如下内容 参考资料 传智黑马MyBatis [https://www.bilibili.com/video/BV1SJ411679L]:","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.yemaojun.top/categories/Mybatis/"}],"tags":[]},{"title":"MyBatis框架学习（二）","slug":"MyBatis框架/MyBatis框架学习（二）","date":"2020-07-31T09:25:45.000Z","updated":"2020-08-05T02:12:57.332Z","comments":true,"path":"2020/07/31/MyBatis框架/MyBatis框架学习（二）/","link":"","permalink":"https://www.yemaojun.top/2020/07/31/MyBatis%E6%A1%86%E6%9E%B6/MyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"本章学习使用MyBatis框架进行CRUD操作（基于代理dao模式），使用Dao实现类的方式CRUD操作、MyBatis中参数深入及结果集的深入、MyBatis中主配置的标签使用、实体类的别名等。","text":"本章学习使用MyBatis框架进行CRUD操作（基于代理dao模式），使用Dao实现类的方式CRUD操作、MyBatis中参数深入及结果集的深入、MyBatis中主配置的标签使用、实体类的别名等。 MyBatis框架中的CRUD操作 一、前期准备1、常见项目导入坐标12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;002&lt;/groupId&gt; &lt;artifactId&gt;002&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、创建SqlMapConfig.xml的主配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- 配置mysql环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置事务类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（也叫连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot;/&gt; &lt;!--&lt;mapper class=&quot;com.itheima.dao.IUserDao&quot;/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3、常见实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.itheima.domain;import java.util.Date;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public User() &#123; &#125; public User(Integer id, String username, Date birthday, String sex, String address) &#123; this.id = id; this.username = username; this.birthday = birthday; this.sex = sex; this.address = address; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 4、常见接口在内部定义CRUD的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.itheima.dao;import com.itheima.domain.User;import java.util.List;public interface IUserDao &#123; /** * 查询所有 * @return */ List&lt;User&gt; findByAll(); /** * 查询一个 * @param id 要查询的用户id * @return */ User findByOne(int id); /** * 根据用户姓名进行模糊查询 * @param name 模糊查询的条件 * @return */ List&lt;User&gt; findByLike(String name); /** * 保存用户 * @param user * @return */ int addUser(User user); /** * 修改用户信息 * @param user */ int updateUser(User user); /** * 删除用户信息 * @param id */ void deleteUser(int id);&#125; 二、编写映射文件并测试运行1、创建映射文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findByAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 查询一个用户对象 --&gt; &lt;select id=&quot;findByOne&quot; resultType=&quot;com.itheima.domain.User&quot; parameterType=&quot;int&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 模糊查询用户 --&gt; &lt;select id=&quot;findByLike&quot; parameterType=&quot;string&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; &lt;!-- 使用这种方式不需要在传入参数时还加“%” --&gt; select * from user where username like &#x27;%$&#123;value&#125;%&#x27; &lt;/select&gt; &lt;!-- 保存一个用户 --&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; &lt;!-- 返回插入的数据的id属性 --&gt; &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; &lt;!-- 修改用户信息 --&gt; &lt;!-- parameterType属性：代表参数的类型，由于传入的是一个类对象，所以类型就写类的全名称 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test=&quot;birthday != birthday&quot;&gt; birthday = #&#123;birthday&#125;, &lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt; address = #&#123;address&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除一个用户信息 --&gt; &lt;!-- 由于此时传入的参数类型是int类型的，所以写的是int（也可以是java.lang.Integer或INT） --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 该映射文件中的**#{}字符可以理解为和原来sql部分学习的“？**”一样，都是占位符。 parameterType的参数是一个简单类型（基本类型8种+String）的时候,#{}中的值可以任意写，如果是一个对象（例如User）,则必须使用属性名称。 ognl 表达式： ​ 它是 apache 提供的一种表达式语言，全称是： ​ Object Graphic Navigation Language 对象图导航语言 ​ 它是按照一定的语法格式来获取数据的。 ​ 语法格式就是使用 #{对象.对象}的方式 #{}和${}的区别： #{}表示一个占位符 通过#{}可以实现perparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。#{}可以接收简单类型值或pojo属性值 ${}表示拼接sql串 通过${}可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 2、编写测试类进行测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class IUserDaoTest &#123; private InputStream in = null; private SqlSession session = null; private IUserDao userDao; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交 session.commit(); //释放资源 session.close(); in.close(); &#125; /** * 查询所有 */ @Test public void findByUserTest()&#123; List&lt;User&gt; users = userDao.findByAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 查询一个用户对象 */ @Test public void findByOneTest()&#123; User user = userDao.findByOne(43); System.out.println(user); &#125; @Test public void findByLikeTest()&#123; List&lt;User&gt; users = userDao.findByLike(&quot;王&quot;); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 向数据库中添加一条数据 */ @Test public void addUserTest()&#123; User user = new User(null,&quot;wangwu&quot;,new Date(),&quot;男&quot;,&quot;西安&quot;); System.out.println(userDao.addUser(user)); System.out.println(user); &#125; /** * 修改数据库中一条信息 */ @Test public void updateUserTest()&#123; User user = new User(53,&quot;wangwu&quot;,null,&quot;男&quot;,null); System.out.println(userDao.updateUser(user)); &#125; /** * 删除用户信息 */ @Test public void deleteUserTest()&#123; userDao.deleteUser(49); &#125;&#125; 三、MyBatis参数深入在上一章节中已经介绍了 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类，本章节将介绍如何使用实体类的包装类作为参数传递。 1、MyBatis中的基本数据类型别名基本数据类型即可以直接写类型名称，也可以使用包名，类名的方式。 例如String既可以写成类型名称（String）也可以写成全限定类名（java.lang.String）。 官方文档给出了基本数据类型的别名说明文档 2、传递POJO包装对象开发过程中可以通过POJO传递查询条件，查询条件是综合的查询条件，不仅包括用户查询条件还包括其他的查询条件（例如将用户的购买商品也作为查询条件），这时可以使用包装对象传递参数。 （1）实例——编写QueryVo类123456789101112131415161718public class QueryVo &#123; private User user; public QueryVo() &#123; &#125; public QueryVo(User user) &#123; this.user = user; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; （2）实例——编写持久层接口12345678910111213import com.itheima.domain.QueryVo;import com.itheima.domain.User;import java.util.List;public interface IUserDao &#123; /** * 根据QueryVo中的条件查询用户 * @param queryVo POJO类 * @return */ List&lt;User&gt; findByVo(QueryVo queryVo);&#125; （3）实例——测试包装类查询123456789101112@Testpublic void findByVoTest()&#123; QueryVo queryVo = new QueryVo(); User user1 = new User(); user1.setUsername(&quot;%王%&quot;); queryVo.setUser(user1); List&lt;User&gt; users = userDao.findByVo(queryVo); for (User user: users) &#123; System.out.println(user); &#125;&#125; 四、MyBatis的输出结果的封装1、resultType配置结果类型resultType属性可以指定封装结果集的类型，它支持基本类型和实体类型。 resultType和parameterType一样，如果注册过类型别名的可以直接使用别名。没有注册过的必须使用全限定类名。 同时还有一个要求实体类中的属性名称必须和查询语句中的列明保持一致，否则无法实现封装。 2、resultMap结果类型resultMap标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在select标签中使用resultMap属性指定引用即可。同时resultMap可以实现将查询结果映射为复杂类型的POJO，例如在查询结果映射对象中包括POJO和List实现一对一和一对多查询。 （1）定义resultMap12345678910111213141516171819&lt;!-- 建立User实体和数据库表的对应关系 属性说明 type属性：指定实体类的全限定类名 id属性：给定一个唯一标识，是给查询select标签引用的--&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;com.itheima.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;userid&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;userBirthday&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;userAddress&quot;/&gt; &lt;/resultMap&gt;&lt;!-- 标签说明 id标签：用于指定主键字段 result标签：用于指定非主键字段 column属性：用于指定数据库列名 property属性：用于指定实体类属性名称--&gt; （2）映射配置1234&lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findByAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; （3）测试及相应结果12345678910/** * 查询所有 */ @Test public void findByUserTest()&#123; List&lt;User&gt; users = userDao.findByAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; 五、SqlMapConfig.xml配置文件1、配置的内容与顺序1234567891011121314151617-properties(属性) --property-setting(全局配置参数) --setting-typeAliases(类型别名) --typeAliase --packge-typeHandlers(类型处理器)-objectFactory(对象工厂)-plugins(插件)-environments(环境集合属性对象) --environment(环境集合子属性对象) --transactionManager(事务管理) --dataSource(数据源)-mappers(映射器) --marpper --package 2、properties标签配置配置连接数据库的信息 resource 属性：用于指定 properties 配置文件的位置，要求配置文件必须在类路径下resource&#x3D;”jdbcConfig.properties” url 属性： ​ URL： Uniform Resource Locator 统一资源定位符 ​ http://localhost:8080/mystroe/CategoryServlet URL ​ 协议 主机 端口 URI ​ URI：Uniform Resource Identifier 统一资源标识符 ​ &#x2F;mystroe&#x2F;CategoryServlet ​ 它是可以在 web 应用中唯一定位一个资源的路径 六、类型别名1、自定义别名在SqlMapConfig.xml中配置： 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=&quot;user&quot; type=&quot;com.itheima.domain.User&quot;/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（字母大小写均可） --&gt; &lt;package name=&quot;com.itheima.domain&quot;/&gt; &lt;package name=&quot;其他包&quot;/&gt;&lt;/typeAliases&gt; alias属性：被定义的别名名称。 type属性：被定义别名的类的全限定类名。 七、mappers（映射器）1、使用相对类路径的资源 2、使用mapper接口类路径 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 3、注册指定包下的所有 mapper 接口 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 参考资料： 传智黑马MyBatis阶段视频：","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.yemaojun.top/categories/Mybatis/"}],"tags":[]},{"title":"Mybatis框架学习（一）","slug":"MyBatis框架/Mybatis框架学习（一）","date":"2020-07-31T05:47:57.000Z","updated":"2020-07-31T09:19:59.856Z","comments":true,"path":"2020/07/31/MyBatis框架/Mybatis框架学习（一）/","link":"","permalink":"https://www.yemaojun.top/2020/07/31/MyBatis%E6%A1%86%E6%9E%B6/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Mybatis学习总结，本次为框架的一些基本概念与入门的案例编写。","text":"Mybatis学习总结，本次为框架的一些基本概念与入门的案例编写。 框架的基本概念学习 一、框架的基本概念1、什么是框架框架是整个或部分系统的可重用设计，表现为一组抽象构件及构建实例之间交互的方法；另一种定义认为，框架是可被应用开发者定制的骨架。前者是从应用方面后者是从目的方面给出的定义。 简而言之，框架其实就是某种应用的半成品，选择一组组组件来完成自己的项目。 2、框架要解决的问题框架要解决的最重要的一个问题是技术整合的问题，在 J2EE 的 框架中，有着各种各样的技术，不同的软件企业需要从 J2EE 中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技术的风险性将会直接对应用造成冲击。而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响。 框架一般处在低层应用平台（如 J2EE）和高层业务逻辑之间的中间层。 3、软件开发分层的重要性框架的重要性在于它实现了部分功能，并且能很好的将底层应用平台和高层业务逻辑进行了缓和。为了实现软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。我们常见的MVC软件设计思想就是很好的分层思想。 4、分层开发下的常见框架（1）MyBatisMyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） （2）String MVCSpring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts 2(一般老项目使用)等等。 （3）String框架Spring框架是一个开放源代码的J2EE应用程序框架，由[Rod Johnson](https://baike.baidu.com/item/Rod Johnson&#x2F;1423612)发起，是针对bean的生命周期进行管理的轻量级容器（lightweight container）。 Spring解决了开发者在J2EE开发中遇到的许多常见的问题，提供了功能强大IOC、AOP及Web MVC等功能。Spring可以单独应用于构筑应用程序，也可以和Struts、Webwork、Tapestry等众多Web框架组合使用，并且可以与 Swing等桌面应用程序AP组合。 二、MyBatis框架快速入门1、搭建MyBatis框架的开发环境（1）创建Maven工程添加数据库数据 1234567891011CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT &#x27;用户名称&#x27;, `birthday` datetime default NULL COMMENT &#x27;生日&#x27;, `sex` char(1) default NULL COMMENT &#x27;性别&#x27;, `address` varchar(256) default NULL COMMENT &#x27;地址&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;--添加的数据--insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,&#x27;老王&#x27;,&#x27;2018-02-27 17:47:08&#x27;,&#x27;男&#x27;,&#x27;北京&#x27;),(42,&#x27;小二王&#x27;,&#x27;2018-03-02 15:09:37&#x27;,&#x27;女&#x27;,&#x27;北京金燕龙&#x27;),(43,&#x27;小二王&#x27;,&#x27;2018-03-04 11:34:34&#x27;,&#x27;女&#x27;,&#x27;北京金燕龙&#x27;),(45,&#x27;传智播客&#x27;,&#x27;2018-03-04 12:04:06&#x27;,&#x27;男&#x27;,&#x27;北京金燕龙&#x27;),(46,&#x27;老王&#x27;,&#x27;2018-03-07 17:37:26&#x27;,&#x27;男&#x27;,&#x27;北京&#x27;),(48,&#x27;小马宝莉&#x27;,&#x27;2018-03-08 11:44:00&#x27;,&#x27;女&#x27;,&#x27;北京修正&#x27;); （2）添加MyBatis3.4.5的坐标123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; （3）编写User实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Date;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public User() &#123; &#125; public User(Integer id, String username, Date birthday, String sex, String address) &#123; this.id = id; this.username = username; this.birthday = birthday; this.sex = sex; this.address = address; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; （4）编写持久层接口IUserDao1234567891011import com.itheima.domain.User;import java.util.List;public interface IUserDao &#123; /** * 查询所有 * @return */ List&lt;User&gt; findByAll();&#125; （5）编写持久层接口的映射文件IUserDao.xml注意事项： 创建位置：必须和持久层接口在相同的包； 名称：必须以持久层接口名称命名文件，扩展名是.xml。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 查询所有并封装到一个List集合 --&gt; &lt;select id=&quot;findByAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; （6）编写SqlMapConfig.xml配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- 配置mysql环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置事务类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（也叫连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot;/&gt; &lt;!--&lt;mapper class=&quot;com.itheima.dao.IUserDao&quot;/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; （7）编写测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.test;import com.itheima.dao.IUserDao;import com.itheima.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class IUserDaoTest &#123; private InputStream in = null; private SqlSession session = null; private IUserDao userDao; @Before public void init() throws Exception &#123; //读取配置文件,使用输入输出流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂（用于创建数据库连接对象） SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(); //使用SqlSession创建Dao接口的代理对象（增强其中的方法） userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; //手动提交 session.commit(); //释放资源 session.close(); in.close(); &#125; /** * 查询所有 */ @Test public void findByUserTest()&#123; List&lt;User&gt; users = userDao.findByAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125; 2、MyBatis框架入门总结通过以上的案例，发现MyBatis框架想要和数据库进行交互只需要编写Dao接口和两个配置文件就可以实现功能。 3、MyBatis框架基于注解的开发（1）在持久层接口中添加注解开发1234567891011121314import com.itheima.domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface IUserDao &#123; /** * 查询所有 * @return */ @Select(&quot;select * from user&quot;) public List&lt;User&gt; findAll();&#125; （2）修改SqlMapConfig.xml1234567 &lt;!-- 用注解来配置，此处应该使用class属性指定被注解的dao全限定类名 --&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.itheima.dao.IUserDao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; （3）注意事项在基于注解开发的时候需要移除xml的配置文件（IUserDao.xml） 三、自定义MyBatis框架1、涉及知识点 工厂模式（Factory工厂模式）； 构造者模式（Builder模式）； 代理模式； 反射； 自定义注解； 注解反射； xml解析； 数据库元数据； 元数据的反射。 未完待续…","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.yemaojun.top/categories/Mybatis/"}],"tags":[]},{"title":"hexo迁移方法","slug":"hexo博客使用过程中的问题汇总/hexo博客使用问题","date":"2020-07-30T10:29:10.000Z","updated":"2023-06-21T08:32:51.657Z","comments":true,"path":"2020/07/30/hexo博客使用过程中的问题汇总/hexo博客使用问题/","link":"","permalink":"https://www.yemaojun.top/2020/07/30/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"最近换了一台设备，为了能继续使用hexo博客所以对原先设备上的hexo博客进行了迁移，但在迁移过程中出现了很多问题，所以为了防止以后再出现类似的问题，我在这里总结下正确的迁移步骤。等真的做下来才发现是真的简单","text":"最近换了一台设备，为了能继续使用hexo博客所以对原先设备上的hexo博客进行了迁移，但在迁移过程中出现了很多问题，所以为了防止以后再出现类似的问题，我在这里总结下正确的迁移步骤。等真的做下来才发现是真的简单 hexo博客迁移设备 一、配置hexo博客所需要的配置环境1、下载GIt 首先先从Git的官网下载安装Git 或者从百度网盘下载（提取码：） 以下Git安装步骤参考来源：来源查看 2、Git安装 双击开始安装 进入如下页面，点击next 选择安装的文件路径默认在c盘下安装 选择要安装的组件信息。 红色圈起来的为添加桌面快捷方式。 黑色圈起来的为默认勾选的，不需要改动。 黄色圈起来是在所有窗口使用TrueType字体以及检查Git forWindows更新，根据个人选择勾选 到这一步是创建启动文件夹，默认即可，直接next 接着这一步依然无需更改，直接next。 三个选项的意思如下 选项一是“仅从Git Bash使用Git”。这是最安全的选择，因为您的PATH根本不会被修改。您只能使用 Git Bash 的 Git 命令行工具。但是这将不能通过第三方软件使用。 选项二是“从命令行以及第三方软件进行Git”。该选项被认为是安全的，因为它仅向PATH添加了一些最小的Git包装器，以避免使用可选的Unix工具造成环境混乱。您将能够从Git Bash，命令提示符和Windows PowerShell以及在PATH中寻找Git的任何第三方软件中使用Git。这也是推荐的选项。 选项三，会将git相关程序以及一些其他的Unix工具加入系统环境变量，使得Windows系统cmd命令行中可以使用git以及Unix工具。要注意的是，这将覆盖Windows工具，如 “ find 和 sort ”。只有在了解其含义后才使用此选项。 选项的意思为： 选项一 “使用 OpenSSL 库”。服务器证书将使用ca-bundle.crt文件进行验证。这也是我们常用的选项。 选项二 “使用本地 Windows 安全通道库”。服务器证书将使用Windows证书存储验证。此选项还允许您使用公司的内部根CA证书，例如通过Active Directory Domain Services 。默认选择第一项，直接next即可 三个选项的意思为 选项一 选项让Git能够自动转换文件中的换行符；签出到本地时转换为Windows下的换行符，提交到服务器时转换为Unix下的换行符 选项二 选项让Git在签出到本地时不做转换，保留原始文件的换行符；提交到服务器时转换为Unix下的换行符 选项三 让Git在签出到本地时和提交到服务器时都不做转换 默认选择第一项，然后next 两个选项的意思为： 选项一 “使用MinTTY（MSYS2的默认终端）”。Git Bash将使用MinTTY作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选择和Unicode字体。Windows控制台程序（例如交互式Python）必须通过“ winpty”启动才能在MinTTY中运行。 选项二 “使用Windows的默认控制台窗口”。Git将使用Windows的默认控制台窗口（“cmd.exe”），该窗口可以与Win32控制台程序（如交互式Python或node.js）一起使用，但默认的回滚非常有限，需要配置为使用unicode 字体以正确显示非ASCII字符，并且在Windows 10之前，其窗口不能自由调整大小，并且只允许矩形文本选择。默认第一项，next 选项的意思为 选项一 启用文件系统缓存 选项二 启用Git凭证管理器 选项三 启用符号链接默认选项无需更改，直接点击install即可进行安装 如此便只能装好了 接下来对安装的Git进行检测 按住window键 + R，输入cmd打开DOS窗口； 输入git –version查看git版本号 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;出现上面的样子则只能装成功 3、Git设置一些基本信息 设置一个用户名：git config –global user.name “在github上注册的用户名” 设置一个用户邮箱：git config –global user.email “在github上注册的邮箱” ps：当该配置完成之后，会在github主页上显示有谁提交了文件 配置完成之后输入该命令查看配置是否成功 git config –list 4、下载nodejs 先下载nodejs文件 或者从百度网盘下载（提取码：） 以下Git安装步骤参考来源：来源查看 5、安装nodejs 双击图标开始安装 点击next 选择接受协议，点击next 选择安装路径 安装需要的模块 开始安装 安装完成、 和上面安装完Git一样，按住window键 + R，输入cmd打开DOS窗口。然后输入node -v 查看有没有版本号 ​ 出现如上的画面则说明安装成功 6、配置nodejs的环境变量NodeJS和NPM安装好了以后并不能直接使用，默认情况下，NPM安装的模块并不会安装到NodeJS的程序目录，比如我们安装的时候设置的D盘，“D:\\Program Files\\nodejs”，而我们使用npm安装一个cluster模块他会出现在C盘默认的路径下面，所以，如果我们不修改npm的模块安装目录，那么它默认情况下都会安装到这里，随着你测试开发各种不同的项目，安装的模块越来越多，这个文件夹的体积就会越来越大，直到占满你的C盘。所以我们要修改npm的配置。摘要来源 （1）在nodejs的安装文件目录下新建两个文件夹为：node_global node_cecal这两个文件夹的作用是放安装过程的缓存文件以及最终的模块配置位置 （2）使用如下命令将npm的全局模块目录和缓存目录配置到我们刚才创建的那两个目录123npm config set prefix &quot;node_global文件的路径&quot;npm config set cache &quot;node_cache的文件路径&quot;//例如：npm config set prefix “D:\\Program Files\\nodejs\\node_global” （3）配置系统环境变量新增系统变量如下图 然后在Path变量名中修改nodejs默认路径 7、nodejs配置淘宝镜像打开Git Bash Here 输入下列命令更改npm的config的registry 为淘宝镜像 1**npm config set registry &quot; https://registry.npm.taobao.org &quot;** ​ 此外，在更新node-sass中，有时候也会出现资源下载不了的问题，通常是git上的资源下载不了，这时候，可以更改node-sass的 资源路径为淘宝的 1npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ **phantomjs的源** 1npm config set phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/ electron源 1npm config set electron_mirror=https://npm.taobao.org/mirrors/electron/ 查看nodejs的默认配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#npm config ls -l; cli configslong = trueuser-agent = &quot;npm/2.14.12 node/v4.2.4 win32 x64&quot; ; builtin config undefinedprefix = &quot;C:\\\\Users\\\\zgr\\\\AppData\\\\Roaming\\\\npm&quot;registry = &quot;https://registry.npm.taobao.org/&quot; ; default valuesaccess = nullalways-auth = falsebin-links = truebrowser = nullca = nullcache = &quot;C:\\\\Users\\\\zgr\\\\AppData\\\\Roaming\\\\npm-cache&quot;cache-lock-retries = 10cache-lock-stale = 60000cache-lock-wait = 10000cache-max = nullcache-min = 10cafile = undefinedcert = nullcolor = truedepth = nulldescription = truedev = falseeditor = &quot;notepad.exe&quot;engine-strict = falsefetch-retries = 2fetch-retry-factor = 10fetch-retry-maxtimeout = 60000fetch-retry-mintimeout = 10000force = falsegit = &quot;git&quot;git-tag-version = trueglobal = falseglobalconfig = &quot;C:\\\\Users\\\\zgr\\\\AppData\\\\Roaming\\\\npm\\\\etc\\\\npmrc&quot;globalignorefile = &quot;C:\\\\Users\\\\zgr\\\\AppData\\\\Roaming\\\\npm\\\\etc\\\\npmignore&quot;group = 0heading = &quot;npm&quot;https-proxy = nullif-present = falseignore-scripts = falseinit-author-email = &quot;&quot;init-author-name = &quot;&quot;init-author-url = &quot;&quot;init-license = &quot;ISC&quot;init-module = &quot;C:\\\\Users\\\\zgr\\\\.npm-init.js&quot;init-version = &quot;1.0.0&quot;json = falsekey = nulllink = falselocal-address = undefinedloglevel = &quot;warn&quot;; long = false (overridden)message = &quot;%s&quot;node-version = &quot;4.2.4&quot;npat = falseonload-script = nulloptional = trueparseable = false; prefix = &quot;C:\\\\Program Files\\\\nodejs&quot; (overridden)production = falseproprietary-attribs = trueproxy = nullrebuild-bundle = true; registry = &quot;https://registry.npmjs.org/&quot; (overridden)rollback = truesave = falsesave-bundle = falsesave-dev = falsesave-exact = falsesave-optional = falsesave-prefix = &quot;^&quot;scope = &quot;&quot;searchexclude = nullsearchopts = &quot;&quot;searchsort = &quot;name&quot;shell = &quot;C:\\\\Windows\\\\system32\\\\cmd.exe&quot;shrinkwrap = truesign-git-tag = falsespin = truestrict-ssl = truetag = &quot;latest&quot;tag-version-prefix = &quot;v&quot;tmp = &quot;C:\\\\Users\\\\zgr\\\\AppData\\\\Local\\\\Temp&quot;umask = 0unicode = trueunsafe-perm = trueusage = falseuser = 0; user-agent = &quot;npm/&#123;npm-version&#125; node/&#123;node-version&#125; &#123;platform&#125; &#123;arch&#125;&quot; (overridden)userconfig = &quot;C:\\\\Users\\\\zgr\\\\.npmrc&quot;version = falseversions = falseviewer = &quot;browser&quot; 8、hexo配置完成以上的操作之后使用如下命令完成hexo的安装 1cnpm install -g hexo-cli 对hexo进行检测 1hexo -v 出现如下信息即为安装成功 迁移博客的所有环境都已经安装完毕，接下就是迁移文件的过程了，相对来说也很简单！ 二、迁移博客文件 打开原设备上的博客文件夹（我的是blog），复制以下文件到U盘 将以上文件全部放入新设备的博客文件夹，然后在新博客文件的路径下安装第三方依赖 12npm install npm install hexo-deployer-git --save // 文章部署到 git 的模块 此时可以执行hexo s查看原先的添加的文章了 在GITHUB 添加 SSH KEYS 在本地输入 1234$ ssh-keygen -t rsa -C “xxxx@qq.com“//你注册的github的邮箱#这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如&#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;github_rsa 接着，根据提示，你需要输入密码和确认密码 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 输入完成之后会得到以下提示信息 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 在GitHub中添加公钥 进入github官网登录之后点击右上角头像； 在下拉列表中选择Settings； 点击下图圈中的列表 再点击右侧的图示按钮 访问此路径“C:&#x2F;Users&#x2F;you&#x2F;.ssh”打开id_rsa.pub文件（使用记事本）复制文本内容到key的文本框中再点击“Add SHH key” 这样公钥就添加成功了，之后输入如下的代码进行检测 1$ssh -T git@github.com 你可能会看到告警信息，如下： 123The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不用担心，直接输入yes。 如果看到下面信息，就说明一切完美！ Hi username! You’ve successfully authenticated, but GitHub does not provide shell access. 这样博客就迁移成功了！ 三、Hexo博客的常用指令1234hexo clean//清除本地数据库中的数据 hexo g//生成本地文件 hexo d//上传到github hexo s//运行本地文件 四 、Hexo 图片加载问题很久不使用Hexo博客了，这段时间上传积累的笔记时，遇到了图片在本地可以浏览，但是上传之后始终找不到图片的现象，即图片无法加载。 ![1.Hexo 图片无法加载样例1](&#x2F;..&#x2F;hexo博客使用问题&#x2F;1.Hexo 图片无法加载样例1.png) ![2.Hexo 图片无法加载样例2](&#x2F;..&#x2F;hexo博客使用问题&#x2F;2.Hexo 图片无法加载样例2.png) 诸如上图所示的现象。先上结论： md文件的名称与存放图片的文件夹名称不一致 ![3.Hexo 图片加载注意事项一，文件名称不一致](&#x2F;..&#x2F;hexo博客使用问题&#x2F;3.Hexo 图片加载注意事项一，文件名称不一致.png) 文件的名称之间有空格存在 ![4.Hexo 图片加载注意事项二，文件名称中间有空格](&#x2F;..&#x2F;hexo博客使用问题&#x2F;4.Hexo 图片加载注意事项二，文件名称中间有空格.png) 存在这两种现象的话，在本地浏览md文件没有什么问题，但是如果上传到服务器后，在加载时会无法显示图片。将上面的文件修改为以下内容时图片就会正常显示了。 ![5.Hexo 图片加载注意事项二，正确格式](&#x2F;..&#x2F;hexo博客使用问题&#x2F;5.Hexo 图片加载注意事项二，正确格式.png) 参考资料： hexo博客中插入图片失败——解决思路及个人最终解决办法 解决Hexo无法显示图片的几种方案 五、Hexo使用网址收集Hexo版本升级指南 六、总结 搭建好hexo博客所需要的运行时环境Git、nodeJs、hexo； 复制备份核心文件（scaffolds、source、themes 、.gitignore、_config.yml、package-lock.json、package.json）； 将核心文件放入新的设备，然后添加第三方依赖； 重新生成SSH密钥并在Github上添加（原先的密钥不要删除）。 参考文献 文献1：hexo个人博客：换了电脑怎么办 文献2：如何在另一台电脑上继续hexo写博客 文献3：使用SSH密钥连接Github【图文教程】 文献4：Git安装和使用 文献5：NodeJs安装与配置淘宝镜像 文献6：NodeJS安装及npm使用淘宝镜像","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://www.yemaojun.top/categories/hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-07-30T10:21:31.448Z","updated":"2021-03-16T16:28:13.465Z","comments":true,"path":"2020/07/30/hello-world/","link":"","permalink":"https://www.yemaojun.top/2020/07/30/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速入门新建文章1$ hexo n/new &quot;My New Post&quot; More info: Writing 开始本地预览服务1$ hexo s/server More info: Server 生成静态文件1$ hexo g/generate More info: Generating 部署到远程站点1$ hexo d/deploy More info: Deployment 新建页面1$ hexo new page &quot;pageName&quot; 组合生成发布命令1$ hexo clean&amp;&amp;hexo g&amp;&amp;hexo d 清除缓存和public中网站静态文件1hexo clean 在blog&#x2F;source下创建文件夹1hexo new page &quot;文件名” 查看帮助1$ hexo help 查看hexo版本1hexo version","categories":[{"name":"杂文","slug":"杂文","permalink":"https://www.yemaojun.top/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.yemaojun.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"字符串值传递问题","slug":"问题收集/字符串值传递问题","date":"2020-07-29T02:01:30.000Z","updated":"2020-07-29T05:56:00.000Z","comments":true,"path":"2020/07/29/问题收集/字符串值传递问题/","link":"","permalink":"https://www.yemaojun.top/2020/07/29/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98/","excerpt":"同一个坑掉进去两次的问题，对于String类型的字符串时不能修改的问题还是没有记住！","text":"同一个坑掉进去两次的问题，对于String类型的字符串时不能修改的问题还是没有记住！ 首先明确一个问题，在java中数据类型分为基本数据类型和引用数据类型。其中基本数据类型是值传递的，即在调用方法时是对原先传入的值无影响的，而引用数据类型在传递的却是在堆内存中的地址值。所以在调用方法的时候可以对堆内存的值进行操作。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public class App&#123; public static void main(String[] ages)&#123; int a = 10; String str = &quot;tom&quot;; int[] arr = new int[3]; System.out.println(Arrays.toString(arr));//[0,0,0] //调用字符串方法 String result = char(str);//tom //调用数组方法 arr(arr); System.out.println(Arrays.toString(arr));//[1,2,3] //调用基本类型变量 int value = variable(a); System.out.println(a);//10 System.out.println(value);//20 &#125; //传入字符串（引用数据类型） public static String char(String str)&#123; str.replace(&quot;t&quot;,&quot;j&quot;);//由于String类型的变量在初始化之后就不可以再更改内容了，所以此方法是有返回值的 return str; &#125; //传入数组（引用数据类型） public static void arr(int[] arr)&#123; for(int i = 1;i &lt;= arr.length;i++)&#123; arr[i] = i;//会修改堆内存中的数据 &#125; &#125; //传入变量a（基本数据类型） public static int variable(int a)&#123; a = 20; return a; &#125; &#125;","categories":[{"name":"问题收集","slug":"问题收集","permalink":"https://www.yemaojun.top/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/"}],"tags":[]},{"title":"数据结构（三）栈","slug":"数据结构/数据结构（三）","date":"2020-07-27T11:29:18.000Z","updated":"2020-08-26T14:42:06.584Z","comments":true,"path":"2020/07/27/数据结构/数据结构（三）/","link":"","permalink":"https://www.yemaojun.top/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"本章学习栈","text":"本章学习栈 栈 一、栈（stack）的基本概念1、栈是一个先入后出（FILO - First In Last Out）的有序列表； 2、栈（stack）是限制线性表中元素的插入和删除只能在线性表的一端进行的一种特殊的线性表。允许插入和删除的一端为变化的一端，称为栈顶（Top），另一端为固定的一端，称为栈底； 3、根据栈的定义可知，最先放入的元素在栈底，最后放入的元素在栈顶。而删除刚好相反，先放入的元素后删除，后放入的元素先删除。 入栈的逻辑图 出栈的逻辑图 二、栈的代码实现1、数组模拟栈的思路分析（1）使用数组来模拟栈； （2）定义一个top来表示栈顶，初始化为-1； （3）入栈的操作，当有数据加入到栈时，先判断栈是否已满，若不满则top++；stack[top] &#x3D; number； （4）出栈的操作，当有数据要出栈时，先判断栈是否为空，若不为空则int value &#x3D; stack[top]；top–；return value； 2、栈类的私有属性与构造方法123456789101112131415public class ArrayStack &#123; private int maxSize;//栈内能存放的最多的元素个数 private int[] stack;//栈 private int top;//栈顶 /** * 构造方法 * @param maxSize 栈内存储的最大元素个数 */ public ArrayStack(int maxSize) &#123; this.maxSize = maxSize; stack = new int[maxSize]; this.top = -1; &#125;&#125; 3、栈类的非空与已满123456789101112131415/** * 判断栈是否已满 * @return */ public boolean isFull()&#123; return top == maxSize - 1; &#125; /** * 判断栈是否为空 * @return */ public boolean isEmpty()&#123; return top == -1; &#125; 4、栈的出栈、入栈、获取栈顶内容与遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 入栈 * @param number 入栈的数据 */public void push(int number)&#123; if (isFull()) &#123; throw new RuntimeException(&quot;栈已满！&quot;); &#125; top++; stack[top] = number;&#125;/** * 出栈 * @return 返回栈顶的元素 */public int pop()&#123; if (isEmpty())&#123; throw new RuntimeException(&quot;栈为空！&quot;); &#125; int value = stack[top]; top--; return value;&#125;/** * 获取栈顶的内容 * @return */public int getTop()&#123; if (isEmpty())&#123; throw new RuntimeException(&quot;栈为空！&quot;); &#125; return stack[top];&#125;/** * 遍历栈内的元素 */public void list()&#123; if (isEmpty()) &#123; throw new RuntimeException(&quot;栈为空！&quot;); &#125; for (int i = top; i &gt;= 0; i--) &#123; System.out.println(stack[i]); &#125;&#125; 5、栈的检测12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ArrayStackDemo &#123; public static void main(String[] args) &#123; ArrayStack stack = new ArrayStack(10); stack.push(15); stack.push(25); stack.push(35); stack.push(45); stack.push(55); stack.push(65); stack.push(75); System.out.println(&quot;插入元素之后&quot;); stack.list(); System.out.println(&quot;-----------------------&quot;); System.out.println(stack.pop()); System.out.println(stack.pop()); System.out.println(stack.pop()); System.out.println(stack.pop()); System.out.println(&quot;-----------------------&quot;); System.out.println(&quot;出栈之后&quot;); stack.list(); &#125;&#125;/*运行结果：插入元素之后75655545352515-----------------------75655545-----------------------出栈之后352515*/ 三、使用栈对一个表达式进行运算1、使用栈完成表达式的计算思路（1）通过一个index值（索引），来遍历我们的表达式； （2）如果我们发现是一个数字就直接入数栈； （3）如果发现扫描到的是一个符号，就分情况进行处理： 如果当前的符号栈为空就直接入栈。 如果当前的符号栈有操作符，就进行比较。如果当前的操作符优先级小于或等于栈中的操作符，就从数栈中pop出两个数，再从符号栈中pop出一个符号进行运算。将得到的结果再存入数栈，再将当前的符号入栈。如果当前的操作符优先级大于栈中的操作符就将当前的操作符直接入栈。 （4）当扫描完表达式后就顺序的从数栈和符号栈中pop出相应的数个符号并运行。 （5）最后在数栈只有一个数字，就是表达式的结果。 2、编写计算类——Calculator123456789101112public class Calculator &#123; //表达式字符串 private String str; private ArrayStack numberStack;//数栈 private ArrayStack symbolStack;//符号栈 public Calculator(String str) &#123; this.str = str; numberStack = new ArrayStack(str.length()); symbolStack = new ArrayStack(str.length()); &#125;&#125; 3、运算符之间的优先级判断方法1234567891011121314/** * 返回符号的优先级 * @param oper 传入的符号 * @return */public int priority(int oper)&#123; if (oper == &#x27;(&#x27; || oper == &#x27;)&#x27;)&#123; return 2; &#125;else if (oper == &#x27;*&#x27; || oper == &#x27;/&#x27;)&#123; return 1; &#125;else if (oper == &#x27;+&#x27; || oper == &#x27;-&#x27;)&#123; return 0; &#125;else return -1;&#125; 4、字符判断与运算方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 字符判断 * @param ch * @return */ public boolean isOper(char ch)&#123; return ch == &#x27;*&#x27; || ch == &#x27;/&#x27; || ch == &#x27;+&#x27; || ch == &#x27;-&#x27; || ch == &#x27;(&#x27; || ch == &#x27;)&#x27;; &#125; /** * 运算方法 * @param num1 运算的数1 * @param num2 运算的数2 * @param ch 运算符 * @return */ public Integer operation(int num1,int num2,char ch)&#123; Integer sum = null; switch (ch)&#123; case &#x27;+&#x27;: sum = num1 + num2; break; case &#x27;-&#x27;: sum = num1 - num2; break; case &#x27;*&#x27;: sum = num1 * num2; break; case &#x27;/&#x27;: sum = num1 / num2; break; case &#x27;(&#x27;: numberStack.push(num1); symbolStack.push(ch); sum = num2; break; case &#x27;)&#x27;: //取出“）”左边的所有数和符号进行运算，直到符号变为“（”将运算的结果返回 while (true)&#123; char pop = (char) symbolStack.pop(); if (pop == &#x27;(&#x27;) &#123; break; &#125; sum = operation(num1,num2,pop); &#125; &#125; return sum; &#125; 5、运算方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int sunber()&#123; //对字符串进行处理 for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if (isOper(c)) &#123; //判断符号栈是否为空，若为空则直接将符号入栈 if (symbolStack.isEmpty())&#123; symbolStack.push(c); &#125;else &#123; //符号栈不为空则判断当前符号的优先级是否小于等于栈顶的符号优先级 if (priority(symbolStack.getTop()) &gt;= priority(c)) &#123; //小于或等于则从数栈中pop出两个数进行运算 char pop = (char) symbolStack.pop(); int num2 = numberStack.pop(); int num1 = numberStack.pop(); Integer sum = operation(num1, num2, pop); //对结果进行检验 if (sum == null)&#123; System.out.println(&quot;结果计算有误！&quot;); return 0; &#125; //再将当前的符号入符号栈 symbolStack.push(c); //再将计算结果入数栈 numberStack.push(sum); &#125;else &#123; //若大于栈顶的符号优先级则将符号入栈 symbolStack.push(c); &#125; &#125; &#125;else &#123; //不为字符则为数字，将数字存入栈 numberStack.push(c - 48); &#125; &#125; //到这一步则字符串表达式已经全部扫描完了，将所有结果取出进行运算 while (true)&#123; if (symbolStack.isEmpty()) &#123; return numberStack.pop(); &#125; char pop = (char) symbolStack.pop(); int num2 = numberStack.pop(); int num1 = numberStack.pop(); numberStack.push(operation(num1, num2, pop)); &#125; &#125; 6、测试方法123456789101112public class CalculatorDemo &#123; public static void main(String[] args) &#123;// String str1 = &quot;3+5+4&quot;;//12// String str2 = &quot;3*4+5&quot;;//17// String str3 = &quot;3*5+5*2-6/2&quot;;//22// String str4 = &quot;3*5+(1+2)&quot;;//18 String str5 = &quot;3*5+(1+2)*2+2&quot;;//23 Calculator calculator = new Calculator(str5); int sunber = calculator.sunber(); System.out.println(sunber); &#125;&#125; 参考资料： 尚硅谷Java数据结构与java算法（Java数据结构与算法）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.yemaojun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"java复习笔记（二）","slug":"java复习笔记/java复习笔记（二）","date":"2020-07-27T09:12:52.000Z","updated":"2020-07-27T11:13:12.000Z","comments":true,"path":"2020/07/27/java复习笔记/java复习笔记（二）/","link":"","permalink":"https://www.yemaojun.top/2020/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"本节主要复习了java中的顺序结构、循环语句、跳转控制语句以及数组和方法的基本知识","text":"本节主要复习了java中的顺序结构、循环语句、跳转控制语句以及数组和方法的基本知识 一、顺序结构1、流程控制（1）分类 顺序结构； 分支结构（if , switch）； 循环结构（for , while , do…while）。 （2）顺序结构 概述：顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行。 （3）分支结构 格式：if(关系表达式){ 语句体;} switch语句： 123456789101112switch(表达式)&#123; case 值1: 语句体1; break； case 值2: 语句体2; break； .... defoult: 语句体n + 1; [break;]&#125; 说明： 表达式：取值为byte 、short、int、char。JDK5以后可以是枚举类型，JDK7以后可以时String case：后面跟的时和表达式进行比较的值 break：用来中断，结束switch语句 defoult：表示所有情况都不匹配的时候就执行该处的内容和if语句的else 二、循环语句1、循环结构的组成 初始化语句：用于表示循环开启时的起始状态，简单说就是循环开始的时候的语句（①）； 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去（②）； 循环体语句：用于表示循环反复执行的内容，简单来说就是反复执行的意思（③）； 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去（④）。 1、for循环语句（1）格式：1234for(初始化语句;条件判断语句;条件控制语句)&#123; 循环体语句; &#125;//执行流程：初始化语句 -&gt; 条件判断语句 -&gt; 循环体语句 -&gt; 条件控制语句//之后回到 条件判断语句 -&gt; 循环体语句 -&gt; 条件控制语句 简单概括为：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; … 2、while循环语句（1）格式：123456初始化语句;while(条件判断语句)&#123; 循环体语句; 条件控制语句; &#125;//执行流程：初始化语句 -&gt; 条件判断语句 -&gt; 循环体语句 -&gt; 条件控制语句//之后回到 条件判断语句 -&gt; 循环体语句 -&gt; 条件控制语句 简单概括为：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; … 3、do…while循环（1）格式：1234567初始化语句;do&#123; 循环体语句; 条件控制语句; &#125;while(条件判断语句);//执行流程：初始化语句 -&gt; 循环体语句 -&gt; 条件控制语句 -&gt; 条件判断语句//之后回到 循环体语句 -&gt; 条件控制语句 -&gt; 条件判断语句 简单概括为：① -&gt; ③ -&gt; ② -&gt; ④ -&gt; ③ -&gt; ② -&gt; ④ -&gt; … 4、三种循环的区别： do…while先执行后判断，最少执行一次； for循环的初始化变量仅能在for循环内部使用，不能带到for循环以外使用； while循环的初始化变量不归属在其语句内，因此在while循环结束之后还可以使用其初始化变量。 三、跳转控制语句 跳过某次循环（continue） 终止循环（break） 数组 一、数组1、概述 一次性声明大量的用于存储数据的变量，要存储的数据通常都是同类型数据。 2、定义 数组（array）是一种用于存储多个相同类型数据的存储模型。 二、数组的动态初始化1、数组初始化的概述 java中的数组必须要先初始化，然后才能使用； 所谓初始化就是为数组中的元素分配内存空间，并未每个数组元素赋值。 2、初始化方式（1）动态初始化 定义：初始化时只指定数组长度，由系统为数组分配初始化值。 格式：数据类型[] 变量名 &#x3D; new 数据类型[数组长度] 例：int[] arr &#x3D; new int[3]; （2）静态初始化 定义：初始化时指定每个数组元素的初始化值，由系统决定数组长度； 格式：数据类型[] 变量名 &#x3D; new int[] {数据1,数据2,…}； 例：int[] arr &#x3D; new int[] {1,2,3}; 简化格式：数据类型[] 变量名 &#x3D; {数据1,数据2,…}； 例：int[] arr &#x3D; {1,2,3}; 三、数组元素访问 数组变量访问：数组名 数组内部保存的数据的访问方式：数组名[索引] 四、内存分配数组在初始化时，会为存储空间添加默认值 数据类型 初始化值 数据类型 初始化值 整数 0 浮点数 0.0 布尔值 false 字符 ‘’ 引用数据类型 null String null 五、数组报错1、索引越界：ArrayIndexOutOfBoundsException 2、空指针异常：NullPointerException 方法 一、方法 定义：是将具有独立功能的代码块组织成一个整体，使其具有特殊功能的代码集。 注意事项： 方法必须先创建才可以使用，该过程被称为方法定义； 方法创建后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用。 二、方法的定义和调用 定义格式：public static void 方法名(){ 方法体;} 方法调用：方法名() 三、带参数方法定义 格式：public static void 方法名（数据类型 参数1，数据类型 参数2，…）{…}&#x2F;&#x2F;此时定义的变量为形参 调用格式：方法名（参数1,参数2）；此时传入的参数时实参 四、形参和实参 形参：方法定义中的参数，有数据类型域参数名组成 实参：方法调用中的参数 五、带返回值的方法 定义：public static 数据类型 方法名（参数）{return 数据;} 注意事项：方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错。 六、方法的注意事项 方法不能嵌套定义 void表示无返回值，可以省略return，也可以单独书写return，后面不加数据，但加入return后代表方法结束了不能再向下执行了。 七、方法重载1、定义方法重载指同一个类中定义的多个方法间的关系，满足以下条件的方法互相构成重载。 多个方法在同一个类中； 多个方法具有相同的方法名； 多个方法的参数不相同，类型不同或数量不同。 2、特点 重载仅对应方法的定义与方法的调用无关； 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，不能通过返回值来判定两个方法是否相互工程重载 例：public static void fn(int a){} public static int fn(int a){} 非方法重载 八、方法的参数传递（基本类型）123456789101112public class ArgsDemo&#123;//对于基本数据类型的参数，形式参数的改变不影响实际参数的值（值传递） public static void main(String[] ages)&#123; int number = 100; System.out.println(&quot;调用方法之前&quot; + number);//100 change(number); System.out.println(&quot;调用方法之后&quot; + number);//100 &#125; public static void change(int number)&#123; number = 200; &#125; &#125; 在栈内存中的情况如下 步骤 栈内存 步骤 栈内存 ① main方法进入栈内存，number &#x3D; 100； ④ change方法调用结束，change与其内容消失 ② 调用change方法，此时main方法中的number依然等于100； ⑤ 此时main方法中的number的值仍然为100 ③ 修改change方法中定义的形参的number的值为200 ⑥ 结束 基本数据类型的变量在传递时传递的并不是变量本身，而是变量的数值。 九、方法的参数传递（引用类型）123456789101112public class ArgsDemo&#123;//对于引用数据类型的参数，形式参数的改变影响实际参数的值（非值传递） public static void main(String[] ages)&#123; int[] arr = &#123;100,200,300&#125;; System.out.println(&quot;调用方法之前&quot; + Arrays.toString(arr));//100,200,300 change(number); System.out.println(&quot;调用方法之后&quot; + Arrays.toString(arr));//200,200,300 &#125; public static void change(int[] arr)&#123; arr[1] = 200; &#125; &#125; 在堆内存和栈内存中的情况如下 引用数据类型在方法调用中传递的就不再是内部存储的值了，而是存储在堆内存中的对象实体。在方法中修改引用数据类型的数值后，方法调用结束堆内存的值也会发生改变。 但值得注意的是String类型的变量也是引用数据类型，但其在方法的参数传递过程中却和基本数据类型的变量一样是值传递的。","categories":[{"name":"java基础笔记","slug":"java基础笔记","permalink":"https://www.yemaojun.top/categories/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构（二）链表、双向循环链表","slug":"数据结构/数据结构（二）","date":"2020-07-24T09:30:48.000Z","updated":"2020-07-27T09:10:04.000Z","comments":true,"path":"2020/07/24/数据结构/数据结构（二）/","link":"","permalink":"https://www.yemaojun.top/2020/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"今日复习数据结构的单链表和双向循环链表的知识。","text":"今日复习数据结构的单链表和双向循环链表的知识。 单链表 一、链表的基本信息1、链表是以结点的方式存储的； 2、每个结点都包含一个data域（数据域）与一个next域（data域存储数据 next域指向下一个结点的位置）； 3、链表中每个结点的存储不一定是连续存储的； 4、链表分为带头结点的与不带头结点的。 单链表的逻辑结构图 二、头节点的作用1、不存放具体的数据； 2、作用就是表示单链表头，此外next域指向第一个结点。 三、单链表的创建1、步骤：（1）创建一个单链表的结点对象类，内部至少要有一个数值变量与指向下一个结点的单链表结点对象（其实是结点对象的引用，作用是替代c语言中的指针）； （2）创建一个对单链表进行遍历、添加、修改和删除等操作的工具类，用于对单链表进行操作； （3）创建一个对单链表进行测试和运行的类。 单链表的结点对象 12345678910111213141516171819202122232425package 链表.单链表.链表的实现;/** * 该类的作用是链表中的节点对象 */public class LinkedNode &#123; int number; Object data; LinkedNode next; public LinkedNode() &#123; &#125; public LinkedNode(int number, Object data) &#123; this.number = number; this.data = data; &#125; @Override public String toString() &#123; return &quot;LinkedNode&#123;&quot; + &quot;number=&quot; + number + &quot;, data=&quot; + data + &#x27;&#125;&#x27;; &#125;&#125; 工具类属性 12345678910111213public class SingleLinkedNode &#123; LinkedNode headNode = null;//头节点 int size;//单链表中有效结点的个数 /** * 初始化头节点 * @param headNode */ public SingleLinkedNode(LinkedNode headNode) &#123; this.headNode = headNode; this.size = 0; &#125;&#125; 四、单链表的工具类1、单链表的非空判断（1）思路 当一个单链表为空时，单链表中只有一个头结点，所以单链表为空否的判断条件为 head.next &#x3D;&#x3D; null。 （2）代码实现1234567/** * 判断单链表是否为空 * @return */public boolean isEmpty() &#123; return headNode.next == null ? true : false;&#125; 2、单链表的遍历（1）思路 判断链表是否为空（判断头节点的next域是否为空 head.next &#x3D;&#x3D; null）； 非空创建一个临时结点对象引用（充当指针）； 使用while循环，输出结点对象（需要重写结点类中的toString（）方法），使用temp &#x3D; temp.next移动单链表索引，相当于移动c语言中的指针。 （2）代码实现1234567891011121314/** * 遍历单链表 */public void traversal() &#123; //判断单链表是否为空 if (isEmpty()) System.out.println(&quot;该单链表为空！&quot;); //定义一个临时节点索引用于代替指针 LinkedNode tempNode = headNode.next; for (int i = 0; i &lt; size; i++) &#123; System.out.println(tempNode); tempNode = tempNode.next; &#125;&#125; 3、按照单链表的index查找结点（1）思路 先判断该单链表是否非空，若非空则无需查找直接返回null； 检验要查询的index的值是否正确； 根据index的值使用for循环找到要相应位置处的结点对象然后返回。 （2）代码实现12345678910111213141516171819202122232425262728293031/** * 根据位置查找节点是否存在，返回该位置的节点对象 * @param index * @return */public LinkedNode findByIndex(int index) &#123; //判断单链表是否为空 if (isEmpty()) &#123; System.out.println(&quot;单链表为空！&quot;); return null; &#125; else if (index == size) &#123; //此时是单链表的最后一个元素,创建一个临时节点索引用于遍历单链表 LinkedNode tempNode = headNode.next; for (int i = 0; i &lt; index - 1; i++) &#123; tempNode = tempNode.next; &#125; return tempNode; &#125; else if (index &lt; 0 || index &gt; size) &#123; System.out.println(&quot;您输入的index有误！&quot; + index); return null; &#125; else if (index == 0)&#123; return headNode; &#125; else &#123; LinkedNode temp = headNode.next; for (int i = 0; i &lt; index - 1; i++) &#123; temp = temp.next; &#125; //此时的temp指向的就是index处的节点对象 return temp; &#125;&#125; 4、单链表的添加(尾部)（1）思路 创建一个结点对象引用,将头结点对象赋值给临时变量对象引用； 使用while循环找到单链表的最后一个结点（此处也可以使用findByIndex()方法找到最后结点对象）； 设置最后一个结点的next指向要加入的结点。 （2）代码实现12345678910111213141516171819202122232425262728 /** * 向一个节点的末尾追加元素 * @param number * @param obj */ public void add(int number, Object obj) &#123; //创建一个要加入的节点对象 LinkedNode addNode = new LinkedNode(number, obj); //判断单链表是否为空,为空则直接将节点添加在头节点后方 if (isEmpty()) &#123; headNode.next = addNode; size++; return; &#125;/*//也可以使用该方法得到单链表的最后一个结点对象LinkedNode tempNode = findByIndex(size);*/ //创建一个临时节点变量，用于找到最后一个节点 LinkedNode tempNode = headNode.next; while (tempNode.next != null) &#123; tempNode = tempNode.next; &#125; //此时已经找到了最后一个节点元素 tempNode.next = addNode; //单链表中实际元素的个数加一 size++; &#125; 5、向单链表的头部添加结点对象（1）思路 使用头结点即可完成； 先将头结点的next的值赋值给新加入结点的next值（addNode.next &#x3D; head.next）; 再将新加入的结点赋值给头结点的next。 （2）代码实现123456789101112131415/** * 向单链表的头添加元素 * @param number * @param obj */public void addFirst(int number, Object obj) &#123; //创建一个要加入的节点对象 LinkedNode addNode = new LinkedNode(number, obj); //将头节点的next赋值给要加入的新节点的next addNode.next = headNode.next; //再将头节点的next指向新加入的节点 headNode.next = addNode; //单链表中实际元素的个数加一 size++;&#125; 6、向单链表的指定位置插入结点（1）思路 先对 index 要插入的位置进行检测； 创建一个临时变量引用指向头结点，使用for循环循环遍历移动索引指向index位置的前一个结点对象； 之后的步骤和向链表头部添加结点对象一样，将新结点赋值给 index 的前一个结点的next，再将前一个结点的next指向新加入的结点即可。 （2）代码实现1234567891011121314151617181920212223242526272829/** * 在单链表的指定位置插入节点 * @param index * @param number * @param obj */ public boolean addByIndex(int index, int number, Object obj) &#123; //创建一个要加入的节点对象 LinkedNode addNode = new LinkedNode(number, obj); //判断插入的位置是否超过单链表实际长度 if (index &gt; size) &#123; System.out.println(&quot;插入的位置有误！无法插入！&quot;); return false; &#125; //先创建一个临时节点索引指向头节点的下一个节点 LinkedNode tempNode = headNode.next; //使用for循环遍历单链表，找到要插入的位置的前一个节点 for (int i = 0; i &lt; index - 1; i++) &#123; tempNode = tempNode.next; &#125; //此时已经找到了要插入位置的前一个节点元素 //让插入的节点指向原先在index位置的节点 addNode.next = tempNode.next; //让擦汗如位置前的节点指向新加入的节点 tempNode.next = addNode; size++; return true; &#125; 7、删除指定位置的结点（1）思路 先判断当前要删除的节点是否存在，即对index进行检测； 若存在则找到要删除结点的前一个结点； 让前一个结点的next指向要删除结点所指向的next即可。 （2）代码实现12345678910111213141516171819202122232425262728293031/** * 根据节点的位置删除节点 * @param index * @return */public LinkedNode removerNodeByIndex(int index) &#123; //判断单链表是否为空 if (isEmpty()) &#123; System.out.println(&quot;该单链表为空！无法删除！&quot;); return null; &#125; //单链表是否存在要删除的元素 LinkedNode delNode = findByIndex(index); if (delNode == null) &#123; System.out.println(&quot;您要删除的元素不存在！&quot;); return null; &#125; //循环单链表找到要删除元素的前一个节点 LinkedNode tempNode; if (index == 1)&#123; tempNode = headNode; &#125;else &#123; tempNode = findByIndex(index - 1); &#125; tempNode.next = tempNode.next.next; size--; return delNode;&#125; 8、修改指定位置的结点（1）思路 同样是先判断要修改的结点是否存在； 若存在则找到当前要修改的节点，然后有两种做法，一种是直接根据传进来的参数修改当前结点的数据即可，另外一种则是根据传入的数据新创建一个结点对其进行交换即可，本次采用第二种方式进行修改； 第二种的修改方法，要新加入结点，先找到要修改的前一个结点。 将要修改结点的next的值赋值给要修改结点的next； 将修改结点的前一个结点的next指向新的结点即可。其实这几步的操作可以简单概括为先删除index位置的结点，再在index位置新加入一个结点即可。 （2）代码实现1234567891011121314151617181920212223242526/** * 根据位置信息修改节点 * @param index * @param newNumber * @param obj * @return */public LinkedNode updByIndex(int index, int newNumber, Object obj) &#123; //先判断该元素是否存在 LinkedNode oldUpdNode = findByIndex(index); if (oldUpdNode == null) &#123; System.out.println(&quot;您要修改的元素不存在&quot;); return null; &#125; //创建好要修改的节点对象 LinkedNode updNode = new LinkedNode(newNumber, obj); //创建一个临时节点变量索引 LinkedNode tempNode = headNode.next; //根据位置信息找到要修改元素的前一个元素 for (int i = 0; i &lt; index - 2; i++) &#123; tempNode = tempNode.next; &#125; updNode.next = tempNode.next.next; tempNode.next = updNode; return oldUpdNode;//返回修改前的结点信息&#125; 9、根据结点的编号对其进行排序（1）思路 本次采用冒泡排序的方式对插入的结点进行排序； 先检测数组不为空则开始排序； 从第一个结点开始比较，当第一个结点的number值比后一个大时交换两个结点的位置。 （2）代码实现12345678910111213141516171819202122//排序，根据number的值进行排序 public boolean sort()&#123; //判断链表是否为空！ if (isEmpty()) &#123; System.out.println(&quot;单链表为空！无法排序&quot;); return false; &#125; //根据编号进行排序,考虑冒泡排序 for (int i = 1; i &lt;= size - 1; i++) &#123; for (int j = 1; j &lt;= size - i; j++) &#123; LinkedNode temp0 = findByIndex(j - 1);//当index的值为0时，返回头结点 LinkedNode temp1 = findByIndex(j); LinkedNode temp2 = findByIndex(j + 1); if (temp1.number &gt; temp2.number) &#123; temp1.next = temp2.next; temp2.next = temp1; temp0.next = temp2; &#125; &#125; &#125; return true; &#125; 五、单链表总结单链表在结构上十分简单，但在实际操作中却十分的繁琐，像是删除添加等情况时总是需要找到要操作结点的前一个结点才能操作。但是单链表在增删等方面却要比数组的效率高，数组在指定位置增加删除时需要前后移动剩余的元素，效率相对较低。但数组在查询和修改方面的效率要比链表的效率高，因为数组不需要遍历即可对索引位置的数据进行操作。但单链表却要每次遍历找到相应的结点。 而且在HashMap集合的底层实现中是数组加链表的形式实现的，为了解决HashMap中的Hash冲突所以在数组中存放的便是链表。 双向循环链表 一、双向循环链表的基本信息1、双向循环链表相比于单链表，在结点对象的属性里又多了一个pre引用，该引用的作用与next引用的作用刚好相反，pre是指向当前节点的前一个结点的引用； 2、双向循环链表相比于单链表还是在逻辑上成一个环状的结构，双向循环链表的尾结点的nextt域不是null，而是指向头结点，头结点的pre指向的是尾结点。之后只要在头结点和尾结点之间进行对节点的增删改查操作即可，如此可不用担心会破坏双向循环链表的逻辑环状结构。 双向循环链表的结构图 二、双向循环链表的结点1、结点的私有属性123456public class DoubleLinkedNode &#123; int number;//编号 Object object;//数据域 DoubleLinkedNode next;//下一个对象 DoubleLinkedNode pre;//上一个对象&#125; 2、结点的初始化12345678//无参构造器public DoubleLinkedNode() &#123;&#125;//带参构造器public DoubleLinkedNode(int number, Object object) &#123; this.number = number; this.object = object;&#125; 三、双向循环链表的工具类1、工具类的私有属性与构造器123456789101112131415161718public class SingleLinkedNode &#123; private DoubleLinkedNode headNode;//头节点 private DoubleLinkedNode endNode;//尾结点 private int size = 0;//链表中有效的结点个数 /** * 成环，环形双向队列 * @param headNode 头节点 */ public SingleLinkedNode(DoubleLinkedNode headNode) &#123; this.headNode = headNode; endNode = new DoubleLinkedNode(); this.headNode.next = endNode; endNode.pre = this.headNode; this.headNode.pre = endNode; endNode.next = this.headNode; &#125;&#125; 2、双向循环链表的非空判断（1）思路 由于该链表是循环的链表，所以head.next永远不可能为null； 需要借助size工具类的私有属性来判断，当 size &#x3D;&#x3D; 0 时链表为null。 （2）代码实现123456789101112/** * 判断链表非空 * 如果为空则返回true * @return 布尔类型 */public boolean isEmpty() &#123; if (size == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125; 3、双向循环链表的遍历（1）思路 由于循环链表的特性，所以使用for循环取遍历链表较为合适； 先判断链表非空； 创建一个临时引用指向第一个实际元素结点，循环遍历size次，输出结点信息。 （2）代码实现1234567891011121314/** * 对双向链表进行遍历 */public void traversal() &#123; if (isEmpty()) &#123; System.out.println(&quot;单链表为空！&quot;); return; &#125; DoubleLinkedNode temp = headNode.next; for (int i = 0; i &lt; size; i++) &#123; System.out.println(temp); temp = temp.next; &#125;&#125; 4、根据位置索引查询结点信息（1）思路 判断链表是否为空，为空则无需查找； 对index的数值进行校验； 当index &#x3D;&#x3D; 0时返回头节点； 判断index的方位是在链表的前半部分还是后半部分，若是前半部分则从头结点开始遍历查找，反之则从尾结点开始查找。 （2）代码实现1234567891011121314151617181920212223242526272829/** * 根据index找相应的节点对象 * @param index 查询的位置 * @return 查询的结点 */ public DoubleLinkedNode findByIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123;// System.out.println(&quot;您输入的位置索引有误！&quot;); return null; &#125; if (index == 0) &#123;// return headNode; &#125; //如果要查找的位置在链表的前半部分则从头开始遍历 //反之从尾部开始遍历 if (index &lt;= (size / 2)) &#123; DoubleLinkedNode temp1 = headNode.next; for (int i = 1; i &lt; index; i++) &#123; temp1 = temp1.next; &#125; return temp1; &#125;else &#123; DoubleLinkedNode temp2 = endNode.pre; for (int i = 1; i &lt;= (size - index); i++) &#123; temp2 = temp2.pre; &#125; return temp2; &#125; &#125; 5、向双向循环链表的尾部添加结点（1）思路 根据传入的参数创建一个新的结点对象； 创建一个临时变量引用，调用findByIndex()方法，让临时变量引用指向最后一个结点； 找到最后一个节点，让最后一个结点的next指向新加入的结点，让尾结点的pre也指向新加入的结点； 让新结点的pre指向原最后一个结点，让新结点的next指向尾结点。 （2）代码实现1234567891011121314151617181920212223/** * 向双向链表的末尾添加元素 * @param number 新加入节点的编号 * @param object 新加入结点存储的数据 */public void add(int number, Object object) &#123; DoubleLinkedNode addNode = new DoubleLinkedNode(number, object); DoubleLinkedNode temp; temp = findByIndex(size); temp.next = addNode; addNode.next = endNode; addNode.pre = temp; endNode.pre = addNode; size++;&#125;/** * 添加元素的方法重载 * @param addNode 要加入的结点对象 */public void add(DoubleLinkedNode addNode) &#123; add(addNode.number, addNode.object);&#125; 6、向双向循环链表的指定位置添加结点（1）思路 先对要插入的index进行数值检测； 根据传入的参数创建要插入的结点； 创建一个临时结点变量引用； 找到要index位置处的结点对象让临时变量的引用指向该节点； 让新加入的结点的next指向index位置处的结点对象，； 使新加入结点的pre指向index位置处的结点对象的前一个结点。 （2）代码实现12345678910111213141516171819202122232425262728293031/** * 在指定位置添加结点对象 * @param index 要插入的位置 * @param number 插入的编号 * @param object 插入的数据域 */public void addByIndex(int index, int number, Object object) &#123; if (size &lt; index || index &lt;= 0) &#123;//对要插入的位置进行检查 System.out.println(&quot;您插入的位置有误！&quot;); return; &#125; DoubleLinkedNode addNode = new DoubleLinkedNode(number, object); DoubleLinkedNode temp = headNode.next; for (int i = 1; i &lt; index; i++) &#123; temp = temp.next;//找到要插入处的结点 &#125; addNode.pre = temp.pre; temp.pre.next = addNode; temp.pre = addNode; addNode.next = temp; size++;&#125;/** * 在指定位置插入结点对象的方法重载 * @param index * @param addNode */public void addByIndex(int index,DoubleLinkedNode addNode)&#123; addByIndex(index,addNode.number,addNode.object);&#125; 7、向双向循环链表的头部添加结点（1）思路 根据传入的参数创建一个新加入节点对象； 将头结点的next赋值给新加入结点的next，将第一个结点的pre指向新加入的结点； 将新加入的结点赋值给头结点的next，修改新加入的结点的pre为头结点。 （2）代码实现123456789101112131415161718192021/** * 在双向链表的开头添加元素 * @param number * @param object */public void addFirst(int number,Object object)&#123; DoubleLinkedNode addNode = new DoubleLinkedNode(number,object); addNode.next = headNode.next; headNode.next.pre = addNode; headNode.next = addNode; addNode.pre = headNode; size++;&#125;/** * 向双向循环链表的开头添加元素的方法重载 * @param addNode */public void addFirst(DoubleLinkedNode addNode)&#123; addFirst(addNode.number,addNode.object);&#125; 8、删除指定位置的结点对象（1）思路 先判断链表是否为空，若为空则结束运行； 调用findByIndex()方法找到要删除的结点对象，此时是对index进行了校验的，所以无需校验； 将要删除结点后一个结点赋值给删除节点的前一个结点的next，修改要删除结点后一个结点的pre为要删除结点的前一个结点。 （2）代码实现1234567891011121314151617/** * 根据位置信息删除结点，并将删除的结点对象返回 * @param index * @return */public DoubleLinkedNode removerByIndex(int index)&#123; if (isEmpty()) &#123; System.out.println(&quot;双向链表为空！无法删除！&quot;); return null; &#125; DoubleLinkedNode delNode = findByIndex(index);//找到要删除的结点 delNode.next.pre = delNode.pre; delNode.pre.next = delNode.next; size--; return delNode;&#125; 9、删除双线链表的头结点（1）思路 先判断链表非空，若为空则无法删除； 创建一个临时结点引用指向要删除的结点对象； 修改头结点与要删除节点的后一个结点的next与pre指向对象即可； （2）代码实现123456789101112131415/** * 删除双向循环链表的开头结点 * @return */public DoubleLinkedNode removerFirst()&#123; if (isEmpty()) &#123; System.out.println(&quot;链表为空！无法删除&quot;); return null; &#125; DoubleLinkedNode delNode = headNode.next; headNode.next.next.pre = headNode; headNode.next = headNode.next.next; size--; return delNode;&#125; 10、根据索引修改指定位置的结点对象（1）思路 使用findByIndex()方法找到要修改的那个结点对象，findByIndex（）方法已经对index进行校验了所以无需再次校验； 对找到的结点进行判断，若为null则说明要删除的结点对象不存在； 若存在则修改找到的结点的number与object。 （2）代码实现123456789101112131415161718192021222324252627/** * 修改指定位置的结点内容 * @param index * @param number * @param object * @return */public DoubleLinkedNode updByIndex(int index,int number,Object object)&#123; DoubleLinkedNode updNode = findByIndex(index);//获取到要修改的那个结点 if (updNode == null) &#123; return null; &#125; DoubleLinkedNode temp = updNode; updNode.number = number; updNode.object = object; return temp;&#125;/** * 修改方法的方法重载 * @param index * @param newNode * @return */public DoubleLinkedNode updByIndex(int index,DoubleLinkedNode newNode)&#123; return updByIndex(index,newNode.number,newNode.object);&#125; 11、对双向循环链表进行排序（1）思路 先对链表判断是非空，若链表为空则无法排序； 本次选择使用快速选择排序的算法进行排序； 该算法的排序思路是每次遍历找到最小的那个节点的索引放在链表的前端和次前端。 （2）代码实现1234567891011121314151617181920212223242526272829//练习测试排序public boolean sort()&#123; if (isEmpty()) &#123; System.out.println(&quot;链表为空，无法排序！&quot;); return false; &#125; //本次选择快速选择排序 int minIndex;//每次循环遍历找到的最小结点编号的索引值 DoubleLinkedNode temp = null;//主要用于后移结点指针 DoubleLinkedNode minNode = null;//用于指向每次遍历找到的编号值最小的结点对象 DoubleLinkedNode temp1 = null;//与每次找到的最小的结点对象交换的结点对象 for (int i = 1; i &lt;= size; i++) &#123; temp1 = minNode = findByIndex(i);//初始化赋值 minIndex = i;//初始化赋值 for (int j = i + 1; j &lt;= size; j++) &#123;//先从第i个节点的后一个结点开始与minNode进行比较 temp = findByIndex(j); if (minNode.number &gt; temp.number) &#123;//如果找到了满足条件的结点对象则修改变量的值 minIndex = j; minNode = temp; &#125; temp = temp.next;//后移指针 &#125; int number = temp1.number;//用于存储其中一个交换节点的编号值 Object object = temp1.object;//用于存储其中一个交换节点的数据域值 updByIndex(i,minNode);//调用修改指定位置结点的方法 updByIndex(minIndex,number,object);//同样调用修改指定位置结点的方法 &#125; return true;&#125; 四、双向循环链表的总结双向循环链表的结构虽然比单链表要复杂一些，但在实际的操作中却要比单链表方便很多。因为双向链表不需要再像单链表一样始终要去寻找前一个结点，双向链表只需要找到相应要操作的结点即可完成对应的操作。 在LinkedList集合底层实现时，所使用的就是双向循环链表。 约瑟夫问题（josephu） 一、约瑟夫环基本介绍1、简介设编号为1，2，….n的n个人围成一个环坐在一起，约定编号为k的人（1 &lt;&#x3D; k &lt;&#x3D; n）的人从1开始报数，数到m的那个人出列，他的下一个位又从1开始报数，数到m的人再次出列，一次类推，直到所有人出列为止，由此产生一个出队的编号序列。 2、示意图（1）初始状态 （2）出队列结束后的示意图 二、实现方式1、实现技术方式采用双向循环链表的方式实现约瑟夫问题 2、实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 约瑟夫问题实现 * @param n 链表中结点的总数 * @param k 从第几号结点开始 * @param m 数几个结点 * @return */ public String josephu(int n,int k,int m) &#123; //对传入的参数进行检查 if (n &lt;= 0 || k &lt;= 0 || m &lt;= 0) &#123; System.out.println(&quot;您输入的参数有误！&quot;); return null; &#125; //清除链表中的数据,需保证链表中无其他数据 for (int i = 0; i &lt; size; i++) &#123; removerFirst(); &#125; //根据传入的参数创建双向循环链表 //传入参数 for (int i = 1; i &lt;= n; i++) &#123; add(i,null); &#125; //创建一个辅助引用 DoubleLinkedNode temp = headNode.next;//从第一个结点开始 //从k号位置开始 for (int i = 0; i &lt; k -1; i++) &#123; temp = temp.next; &#125; StringBuilder str = new StringBuilder(); //每过m个结点弹出一个结点对象 while (size &gt; 0)&#123; for (int i = 0; i &lt; m - 1; i++) &#123; temp = temp.next; &#125;//此时temp所指的结点就是要出队列的结点 //但此时需要判断，去掉头尾结点 while (temp.number == 0)&#123;//头尾结点的number的值为0，当number的值不为0时则不循环 temp = temp.next;//移动第一个实际结点 &#125;//此处只要判断到temp.number == 0，就可以调用findByIndex方法直接赋值给temp = findByIndex(1) if (size != 1) &#123; str.append(temp.number + &quot; -&gt; &quot;); &#125;else &#123; str.append(temp.number); &#125; //出队列 temp.pre.next = temp.next; temp.next.pre = temp.pre; temp = temp.next;//此时没有引用再指向出队列的结点对象，过后会被垃圾回收车回收 size--; &#125; return str.toString(); &#125; 3、测试代码123456public static void main(String[] args) &#123; DoubleLinkedNode headNode = new DoubleLinkedNode();//创建一个头结点 SingleLinkedNode node = new SingleLinkedNode(headNode);//传入双向循环链表的工具类 String josephu = node.josephu(5, 1, 2);//传入参数 System.out.println(josephu);//运行结果为：2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 3 &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.yemaojun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构（一）基本概念、稀疏数组、队列","slug":"数据结构/数据结构（一）","date":"2020-07-23T00:57:18.000Z","updated":"2020-11-21T12:07:09.263Z","comments":true,"path":"2020/07/23/数据结构/数据结构（一）/","link":"","permalink":"https://www.yemaojun.top/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"今日开始总结数据结构相关的知识，本章复习了数据结构的基本知识点、稀疏数组和队列相关的知识。","text":"今日开始总结数据结构相关的知识，本章复习了数据结构的基本知识点、稀疏数组和队列相关的知识。 数据结构 一、数据结构与算法的关系1、数据结构是一门研究组织数据方式的学科，有了编程语言也就有了数据结构； 2、程序 &#x3D; 数据结构 + 算法； 3、数据结构是算法的基础。 二、线性结构与非线性结构1、数据结构的结构数据结构的存储结构分为线性结构和非线性结构。 2、线性结构（1）线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系； （2）线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的； （3）链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素结点中存放数据元素以及相邻元素的地址信息； （4）线性结构常见的有：数组、队列、链表和栈。 3、非线性结构（1）包括：二维数组、多维数组、广义表、树结构、图结构。 稀疏数组 一、基本介绍当一个数组中大部分元素为0（初始值），或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 1、处理方法：（1）记录一个数组一共有几行几列，有多少个不同的值； （2）把具有不同的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。 ​ 设有一个 6 x 7 的数组，其中记录了5个非原始数据 上面的数组转换为稀疏数组之后 稀疏数组的第1行（[0]号位置）记录的是原始数组的行数（6行）和列数（7列）和非零元素的个数（5个） 稀疏数组的第二行开始（[1]及以后的行），行列存放的是非零元素在原始数组中的行的位置，列列存放的是同一个非零元素的列的位置，值的位置存放的是非零元素的实际值。 二、实现思路（1）二维数组转稀疏数组 遍历原始的二维数组，得到有效数据的个数sum; 根据sum就可以创建稀疏数组sparseArr int【sum + 1】【3】; 将二维数组的有效数据存入稀疏数组。 （2）稀疏数组转原始数组 先读取稀疏数组的第一行，根据第一行的数据创建二维数组； 再读取稀疏数组的后几行数据，并赋值给原始的数组即可。 三、代码实现 创建一个原始二维数组并赋值 12345678910//二维数组转稀疏数组//定义一个二维数组int arr[][] = new int[6][7];//向二维数组赋值arr[0][3] = 22;arr[0][6] = 15;arr[1][1] = 11;arr[1][5] = 17;arr[3][3] = 8; (1) 二维数组转稀疏数组实现 遍历原始二维数组，获取有效的数据个数 123456789101112// 稀疏数组// 获取非初始化数据的个数 int r = arr.length;//二维数组的行 int l = arr[0].length;//二维数组的列 int sum = 0;//非0元素的个数 for (int[] row : arr) &#123; for (int data : row) &#123; if (data != 0) &#123; sum++; &#125; &#125; &#125; 根据二维数组的非零元素的个数sum创建稀疏数组 123456// 创建稀疏数组 int sparseArr[][] = new int[sum + 1][3];// 对稀疏数组的第一行进行赋值，二维数组的信息 sparseArr[0][0] = arr.length; sparseArr[0][1] = arr[0].length; sparseArr[0][2] = sum; 将二维数组的有效个数存入稀疏数组 123456789101112// 获取非0数据并赋值 int count = 0; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[0].length; j++) &#123; if (arr[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = arr[i][j]; &#125; &#125; &#125; 遍历稀疏数组查看结果 （2）稀疏数组转二维数组实现 先读取稀疏数组的第一行，根据第一行的数据，创建原始二位数组 123//稀疏数组转二维数组//创建一个二维数组int arr1[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; 在读取稀疏数组的后几行数据，并赋值给二维数组 12345678// 将稀疏数组中的值赋值给二维数组 for (int i = 1; i &lt; sparseArr.length; i++) &#123; int rows = sparseArr[i][0]; int c = sparseArr[i][1]; int data = sparseArr[i][2]; arr1[rows][c] = data; &#125; 运行结果 队列 一、基本介绍1、队列是一个有序列表，可以使用链表和数组实现； 2、遵循先进先出的原则。即：先存入队列的数据先取出，后存入的数据后取出。 数组队列逻辑结构图 当插入一个数据后，逻辑结构图变为如下的样子。 ![数组队列逻辑结构图 (一)](数据结构（一）&#x2F;数组队列逻辑结构图 (一).JPG) 当数组队列已满时rear == maxSize - 1或 rear + 1 == maxSize 二、数组队列思路1、队列本身是一个有序列表，若使用数组存储数据则需声明maxSize（数组的最大容量）； 2、因数组需要输出，所以需要两个变量分别指向队列的头元素和尾元素； 3、front为指向队列的头元素索引。默认值为-1； 4、rear为指向队列的尾元素索引。默认值为-1； 5、当需要向队列中添加数据时需判断队列是否已满，若满则将rear的值加一然后存入元素； 6、队列为空的判断方法：rear &#x3D;&#x3D; front； 7、队列是否已满的判断方法为 rear &#x3D;&#x3D; maxSize - 1或 rear + 1 &#x3D;&#x3D; maxSize; 8、当取元素时将front加一，然后将 queue[front] 的值返回。 三、代码实现1、创建一个队列类1234567891011121314151617class ArraysQueue &#123; private int maxSize;//数组（队列）的最大值 private int front;//队列的头元素 private int rear;//队列的尾元素 private int[] queue;//定义一个数组（队列） private int size;//有效元素个数 //创建数组（队列）初始化——构造方法 public ArraysQueue(int arrmaxSize) &#123; maxSize = arrmaxSize; queue = new int[maxSize]; front = -1; rear = -1; size = arrmaxSize; &#125;&#125; 2、判断队列是否为空与是否已满123456789//判断队列是否为空——isEmptypublic boolean isEmpty() &#123; return front == rear;&#125;//判断队列是否满——isFullpublic boolean isFull() &#123; return rear == (maxSize - 1);&#125; 3、向队列中添加元素判断非空后，先将指向队列尾部的索引后移一位指向一个空的位置，然后将数据存入数组。 12345678910111213141516 //添加元素——addQueue public void addQueue(int n) &#123; //判断队列是否已满 if (isFull()) &#123; //自定义异常// throw new RuntimeException(&quot;队列已满，无法添加！&quot;); System.out.println(&quot;队列已满，无法添加！&quot;); return; &#125; else &#123; //队列没满可以添加 rear++; queue[rear] = n; System.out.println(&quot;添加成功！&quot;); size--; &#125; &#125; 4、取队头元素待判断结束之后，将队头索引先向后移动一位，只想队头元素，然后取出元素，此时取出的数据不需要再将其删除，因为下次会直接跳过该元素。 12345678910111213 //取队头元素getQueue public int getQueue() &#123; //判断是否非空 if (isEmpty()) &#123;// throw new RuntimeException(&quot;队列已空！&quot;); System.out.println(&quot;队列为空！&quot;); return 0; &#125; else &#123; front++; size++; return queue[front]; &#125; &#125; 5、输出队列使用for循环输出队列，使 i 的值等于(front + 1)，使队列从头元素开始遍历，当 i 的值等于队尾的索引值时停止循环。 1234567891011121314151617181920212223 //输出队列show public void showQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123;// throw new RuntimeException(&quot;队列为空！&quot;); System.out.println(&quot;队列为空！&quot;); return; &#125; else &#123; System.out.print(&quot;数组内的内容为:&quot;); System.out.print(&quot;[&quot;); int count = front; for (int i = front + 1; i &lt;= rear; i++) &#123; count++; if (count != rear) &#123; System.out.print(queue[i] + &quot;,&quot;); &#125; else &#123; System.out.print(queue[i]); &#125; &#125; System.out.println(&quot;]&quot;); &#125; 6、输出获取头元素123456789//输出获取头元素——headQueuepublic int headQueue() &#123; //判断是否非空 if (isEmpty()) &#123; throw new RuntimeException(&quot;队列为空！&quot;); &#125; else &#123; return queue[front + 1]; &#125;&#125; 环形数组队列 一、基本介绍1、环形数组队列修复了数组队列不能一致存放数据的缺点，但还是和数组队列一样需要设置maxSize； 2、环形数组只是再逻辑上时环形的，但其实在物理存储结构上依然是和数组队列一样的。 环形数组队列的逻辑结构图 二、环形数组队列实现思路1、front指向数组（队列）的第一个元素queue[0] ，front的初始值设为0； 2、rear指向数组（队列）的最后一个元素的后一个位置，因为空出来一个空间用来做约定，rear的初始值为0； 3、当队列满的判断条件为（rear + 1）% maxSize &#x3D;&#x3D; front时； 4、当队列为空的判断条件为 rear &#x3D;&#x3D; front; 5、队列中有效数据的个数为（ rear + maxSize - front）% maxSize。 环形数组队列为满的逻辑机构图如下 三、环形数组队列的代码实现1、创建一个环形队列类123456789101112public class CircleArraryQueueDemo &#123; private int maxSize;//数组（队列）的最大值 private int front;//队列的头元素 private int rear;//队列的尾元素 private int[] queue;//定义一个数组（队列） //创建数组（队列）初始化——构造方法 public CircleArraryQueueDemo(int arrmaxSize) &#123; maxSize = arrmaxSize; queue = new int[maxSize]; &#125;&#125; 2、判断队列是否为空与已满123456789//判断队列是否为空——isEmptypublic boolean isEmpty() &#123; return rear == front;&#125;//判断队列是否满——isFullpublic boolean isFull() &#123; return (rear + 1) % maxSize == front;&#125; 3、向队列添加元素12345678910111213141516 //添加元素——addQueue public void addQueue(int n) &#123; //判断队列是否已满 if (isFull()) &#123; //自定义异常// throw new RuntimeException(&quot;队列已满，无法添加！&quot;); System.out.println(&quot;队列已满，无法添加！&quot;); return; &#125; else &#123; //队列没满可以添加 queue[rear] = n; //对rear进行取模,防止数组索引越界异常 rear = (rear + 1) % maxSize; System.out.println(&quot;添加成功！&quot;); &#125; &#125; 4、获取队列中有效元素的个数12345678910111213141516171819202122 //获取队列中有效元素的个数 public int getLength() &#123; return (rear + maxSize - front) % maxSize; &#125; //取队头元素getQueue public int getQueue() &#123; //判断是否非空 if (isEmpty()) &#123;// throw new RuntimeException(&quot;队列已空！&quot;); System.out.println(&quot;队列为空！&quot;); return 0; &#125; else &#123; //front是指向队列的第一个元素 //1.用临时变量存储头元素 //2.将front后移 //3.将临时变量用做返回值 int value = queue[front]; front = (front + 1) % maxSize; return value; &#125; &#125; 5、输出队列1234567891011121314151617181920212223242526272829303132 //输出队列show public void showQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123;// throw new RuntimeException(&quot;队列为空！&quot;); System.out.println(&quot;队列为空！&quot;); return; &#125; else &#123; System.out.print(&quot;数组内的内容为:&quot;); System.out.print(&quot;[&quot;); int count = 0; for (int a : queue) &#123; if (count == getLength()) &#123; continue; &#125; count++; if (count != maxSize) &#123; System.out.print(a + &quot;,&quot;); &#125; else &#123; System.out.print(a); &#125; &#125; /*for (int i = front; i &lt; front + getLength(); i++) &#123; if (queue[i % maxSize] != maxSize) &#123; System.out.println(queue[i % maxSize] + &quot;,&quot;); &#125;else &#123; System.out.print(queue[i % maxSize]); &#125; &#125;*/ System.out.println(&quot;]&quot;); &#125; &#125; 6、获取头元素1234567891011121314151617 //取队头元素getQueue public int getQueue() &#123; //判断是否非空 if (isEmpty()) &#123;// throw new RuntimeException(&quot;队列已空！&quot;); System.out.println(&quot;队列为空！&quot;); return 0; &#125; else &#123; //front是指向队列的第一个元素 //1.用临时变量存储头元素 //2.将front后移 //3.将临时变量用做返回值 int value = queue[front]; front = (front + 1) % maxSize; return value; &#125; &#125; 7、输出头元素123456789//输出获取头元素——headQueuepublic int headQueue() &#123; //判断是否非空 if (isEmpty()) &#123; throw new RuntimeException(&quot;队列为空！&quot;); &#125; else &#123; return queue[front]; &#125;&#125; 参考资料： [https://www.bilibili.com/video/BV1E4411H73v]:","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.yemaojun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"集合底层原理（ArrayList和LinkedList）","slug":"集合底层原理总结/集合底层原理","date":"2020-07-22T01:18:59.000Z","updated":"2020-07-23T01:36:08.000Z","comments":true,"path":"2020/07/22/集合底层原理总结/集合底层原理/","link":"","permalink":"https://www.yemaojun.top/2020/07/22/%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"本次的笔记主要记录了集合的底层实现原理的基本概念。先总结了List集合中的ArrayList集合和LinkedList集合的底层数据结构实现和源码分析。","text":"本次的笔记主要记录了集合的底层实现原理的基本概念。先总结了List集合中的ArrayList集合和LinkedList集合的底层数据结构实现和源码分析。 一、集合的分类 二、集合的基本概念1、Collection单列集合概述（1）是单列集合的顶层接口，他表示 一组对象，这些对象也成为Collection的元素。 （2）JDK不提供此接口的任何直接实现，他提供更具体的子接口（如set和list）实现。 2、Map双列集合概述（1）将键映射到值的对象，不包含重复的键，每个键可以映射到最多一个值。 三、集合底层详解1、ArrayList集合详解1.1 基本概念​ ArrayList是List接口的可变数组非同步实现，底层使用数组保存所有元素。其操作基本上是对数组的操作。 1private transient Object[] elementData; ​ 该集合是可变长度的数组，数组扩容时，会将老数组中的元素拷贝一份到新数组中！每次数组扩容的大小是原容量的1.5倍。 12345678910private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // 旧容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 新容量为旧容量的1.5倍 if (newCapacity - minCapacity &lt; 0) // 新容量小于参数指定容量，修改新容量 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 新容量大于最大容量 newCapacity = hugeCapacity(minCapacity); // 指定新容量 // 拷贝扩容 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 1.2 源码分析1.2.1 类的继承关系​ ArrayList继承AbstractList抽象父类。实现了List接口。RandomAccess（可随机访问）、Cloneable（可拷贝）、Serializable （可序列化）。 123456789101112131415161718public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 版本号 private static final long serialVersionUID = 8683452581122892189L; // 缺省容量 private static final int DEFAULT_CAPACITY = 10; // 空对象数组（核心属性，被标记为transient，序列化的时候此字段不会被序列化） private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; // 缺省空对象数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; // 元素数组 transient Object[] elementData; // 实际元素大小，默认为0 private int size; // 最大数组容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;&#125; 1.2.2 ArrayList类的构造器1.2.2.1 ArrayList（int）型构造函数123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 初始容量大于0 this.elementData = new Object[initialCapacity]; // 初始化元素数组 &#125; else if (initialCapacity == 0) &#123; // 初始容量为0 this.elementData = EMPTY_ELEMENTDATA; // 为空对象数组 &#125; else &#123; // 初始容量小于0，抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; 1.2.2.2 ArrayList()型构造函数1234public ArrayList() &#123; // 无参构造函数，设置元素数组为空 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 1.2.2.3 ArrayList(Collection&lt;? extends E&gt;)型构造函数123456789public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 集合参数构造函数 elementData = c.toArray(); // 转化为数组 if ((size = elementData.length) != 0) &#123; // 参数为非空集合 if (elementData.getClass() != Object[].class) // 是否成功转化为Object类型数组 elementData = Arrays.copyOf(elementData, size, Object[].class); // 不为Object数组的话就进行复制 &#125; else &#123; // 集合大小为空，则设置元素数组为空 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 1.2.3 常用核心方法分析1.2.3.1 add函数：向数组中添加元素12345public boolean add(E e) &#123; // 添加元素 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; ​ ensureCapacityInternal此函数可以理解为确保elementData数组有合适的大小。 ​ ensureCapacityInternal方法的实现方法如下。 1234567private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 判断元素数组是否为空数组 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 取较大值 &#125; ensureExplicitCapacity(minCapacity); &#125; ​ ensureExplicitCapacity函数也是为了确保elemenData数组有合适的大小。ensureExplicitCapacity的具体函数如下 123456private void ensureExplicitCapacity(int minCapacity) &#123; // 结构性修改加1 modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; ​ 最后又调用了grow（）方法，该方法才是真正扩容数组的方法，正常情况下会扩容1.5倍。特殊情况下（新的数组大小已经达到最大值）则只取最大值。 1.2.3.2 set函数：通过下标索引设置相应位置处的值12345678910public E set(int index, E element) &#123; // 检验索引是否合法 rangeCheck(index); // 旧值 E oldValue = elementData(index); // 赋新值 elementData[index] = element; // 返回旧值 return oldValue;&#125; 1.2.3.3 indexOf函数：从首开始查找数组里面是否存在指定元素1234567891011121314// 从首开始查找数组里面是否存在指定元素 public int indexOf(Object o) &#123; if (o == null) &#123; // 查找的元素为空 for (int i = 0; i &lt; size; i++) // 遍历数组，找到第一个为空的元素，返回下标 if (elementData[i]==null) return i; &#125; else &#123; // 查找的元素不为空 for (int i = 0; i &lt; size; i++) // 遍历数组，找到第一个和指定元素相等的元素，返回下标 if (o.equals(elementData[i])) return i; &#125; // 没有找到，返回空 return -1; &#125; ​ 从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。 1.2.3.4 get函数：通过下标索引获取相应位置处的值123456public E get(int index) &#123; // 检验索引是否合法 rangeCheck(index); return elementData(index);&#125; get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0），值得注意的是，在get函数中存在element函数，element函数用于返回具体的元素，具体函数如下 123E elementData(int index) &#123; return (E) elementData[index];&#125; 返回的值都经过了向下转型（Object -&gt; E），这些是对我们应用程序屏蔽的小细节。 1.2.3.5 remove函数：通过下表索引删除数组中相应位置的值12345678910111213141516public E remove(int index) &#123; // 检查索引是否合法 rangeCheck(index); modCount++; E oldValue = elementData(index); // 需要移动的元素的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 赋值为空，有利于进行GC elementData[--size] = null; // 返回旧值 return oldValue;&#125; 1.3 ArrayList总结ArrayList由于底层是数组实现的，所以相较于LinkedList，ArrayList集合查询、修改速度快，但是在指定位置删除和添加元素时由于需要移动指定位置之后的元素所以速度相比较慢。 2、LinkedList集合详解2.1 基本概念LinkedList底层的数据结构是双向循环链表，头结点不存放元素 2.2 源码分析2.2.1 类的继承关系12public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 2.2.2 内部类（结点类）123456789101112private static class Node&lt;E&gt; &#123; E item; // 数据域 Node&lt;E&gt; next; // 后继 Node&lt;E&gt; prev; // 前驱 // 构造函数，赋值前驱后继 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 用于构建链表的组成对象（结点） 2.2.3 LinkedList的属性1234567891011public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 实际元素个数 transient int size = 0; // 头结点 transient Node&lt;E&gt; first; // 尾结点 transient Node&lt;E&gt; last;&#125; 2.2.4 LinkedList的构造器2.2.4.1 LinkedList()型构造函数12public LinkedList() &#123;&#125; 创建一个空的头结点。 2.2.4.2 LinkedList(Collection&lt;? extends E&gt;)型构造函数123456public LinkedList(Collection&lt;? extends E&gt; c) &#123; // 调用无参构造函数 this(); // 添加集合中所有的元素 addAll(c);&#125; 这个构造方法的参数是一个集合，可以将这个集合中的所有元素信息存入双向链表。 2.2.5 常用核心方法分析2.2.5.1 add函数：向链表的末尾添加进一个结点对象12345public boolean add(E e) &#123; // 添加到末尾 linkLast(e); return true;&#125; 该方法添加到末尾的具体逻辑是由linkLast函数完成，linkLast方法的具体实现如下： 12345678910111213141516void linkLast(E e) &#123; // 保存尾结点，l为final类型，不可更改 final Node&lt;E&gt; l = last; // 新生成结点的前驱为l,后继为null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 重新赋值尾结点 last = newNode; if (l == null) // 尾结点为空 first = newNode; // 给头节点赋值 else // 尾结点不为空 l.next = newNode; // 尾结点的后继为新生成的结点（尾结点） // 大小加1 size++; // 结构性修改加1 modCount++;&#125; 2.2.5.2 addAll函数addAll有两个重载函数，addAll(Collection&lt;? extends E&gt;)型和addAll(int, Collection&lt;? extends E&gt;)型，我们平时习惯调用的addAll(Collection&lt;? extends E&gt;)型会转化为addAll(int, Collection&lt;? extends E&gt;)型，所以着重分析此函数即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 添加一个集合 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查插入的的位置是否合法 checkPositionIndex(index); // 将集合转化为数组 Object[] a = c.toArray(); // 保存集合大小 int numNew = a.length; if (numNew == 0) // 集合为空，直接返回 return false; Node&lt;E&gt; pred, succ; // 前驱，后继 if (index == size) &#123; // 如果插入位置为链表末尾，则后继为null，前驱为尾结点 succ = null; pred = last; &#125; else &#123; // 插入位置为其他某个位置 succ = node(index); // 寻找到该结点 pred = succ.prev; // 保存该结点的前驱 &#125; for (Object o : a) &#123; // 遍历数组 @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; // 向下转型 // 生成新结点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) // 表示在第一个元素之前插入(索引为0的结点) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; // 表示在最后一个元素之后插入 last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; // 修改实际元素个数 size += numNew; // 结构性修改加1 modCount++; return true; &#125; 参数中的index表示在索引下标为index的结点（实际上是第index + 1个结点）的前面插入。在addAll函数中，addAll函数中还会调用到node函数，get函数也会调用到node函数，此函数是根据索引下标找到该结点并返回，具体代码如下 1234567891011121314Node&lt;E&gt; node(int index) &#123; // 判断插入的位置在链表前半段或者是后半段 if (index &lt; (size &gt;&gt; 1)) &#123; // 插入位置在前半段 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) // 从头结点开始正向遍历 x = x.next; return x; // 返回该结点 &#125; else &#123; // 插入位置在后半段 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) // 从尾结点开始反向遍历 x = x.prev; return x; // 返回该结点 &#125; &#125; 2.2.5.3 unlink函数在调用remove移除结点时，会调用到unlink函数（将指定的结点从链表中断开，不再累赘），unlink函数具体如下： 123456789101112131415161718192021222324252627282930E unlink(Node&lt;E&gt; x) &#123; // 保存结点的元素 final E element = x.item; // 保存x的后继 final Node&lt;E&gt; next = x.next; // 保存x的前驱 final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; // 前驱为空，表示删除的结点为头结点 first = next; // 重新赋值头结点 &#125; else &#123; // 删除的结点不为头结点 prev.next = next; // 赋值前驱结点的后继 x.prev = null; // 结点的前驱为空，切断结点的前驱指针 &#125; if (next == null) &#123; // 后继为空，表示删除的结点为尾结点 last = prev; // 重新赋值尾结点 &#125; else &#123; // 删除的结点不为尾结点 next.prev = prev; // 赋值后继结点的前驱 x.next = null; // 结点的后继为空，切断结点的后继指针 &#125; x.item = null; // 结点元素赋值为空 // 减少元素实际个数 size--; // 结构性修改加1 modCount++; // 返回结点的旧元素 return element; &#125; 2.3 LinkedList总结LinkedList的底层数据结构是循环双向链表，但由于实现了多个接口所以当需要使用栈、队列等操作时，可以考虑该结构。 ArrayList参考文献： [https://www.cnblogs.com/leesf456/p/5308358.html]: LinkedList参考文献： [[](https://www.cnblogs.com/leesf456/p/5308843.html)]:[[](https://www.cnblogs.com/ITtangtang/p/3948610.html#a4)]:","categories":[{"name":"集合底层原理","slug":"集合底层原理","permalink":"https://www.yemaojun.top/categories/%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"java复习笔记（一）","slug":"java复习笔记/java复习笔记（一）","date":"2020-07-08T11:21:36.000Z","updated":"2023-02-23T13:28:34.614Z","comments":true,"path":"2020/07/08/java复习笔记/java复习笔记（一）/","link":"","permalink":"https://www.yemaojun.top/2020/07/08/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Java的复习从现在开始，这一片主要复习了java的基础信息。JRE与JDK的基本概念、常用的DOS命令、关键字、数据类型、变量、常量、标识符、类型转换和运算符等。","text":"Java的复习从现在开始，这一片主要复习了java的基础信息。JRE与JDK的基本概念、常用的DOS命令、关键字、数据类型、变量、常量、标识符、类型转换和运算符等。 一、JRE和JDK1、JRE（Java Runtime Environment）（1）概念：是Java程序的运行时环境，包括JVM和运行时所需要的核心类库。 2、JDK（Java Development Kit）（1）概念：是Java程序开发工具包，包含JRE和开发人员使用的工具。其中的开发工具：编译工具（javac.exe）和运行工具（java.exe）。 二、常用的DOS命令 操作 说明 盘符命令 盘符切换。E：回车，标识切换到E盘 dir 查看当前路径下的内容 cd 目录 进入单级目录 cd ..&#x2F; 回退到上一级目录 cd 目录1\\目录2... 进入多级目录 cd\\ 回退到盘符目录 cls 清屏 exit 退出命令提示符窗口 三、关键字1、关键字概述（1）概念：就是被java语言赋予了特定含义的单词。 2、关键词的特点（1）关键字全都是小写； （2）常用的代码编辑器，针对关键字有特殊的颜色标记。 四、常量1、概念（1）常量：在程序运行过程中，其值不可以发生改变的量。 2、分类 常量类型 说明 举例 字符串常量 用双引号括起来的内容 “Hello Word” 整数常量 不带小数的数字 666，-88 小数常量 带小数点的数字 13.14，-5.21 字符常量 用单引号括起来的内容 ‘A’，‘o’ 布尔常量 布尔值，表示真假 true、false 空常量 一个特殊的值，空值 值是：null 空常量不可以输出 五、数据类型1、概述​ Java语言是强类型语言，对于每一种数据都给出了明确的数据类型，不同的数据类型也分配了不同的内存空间。所以他们表示的数据大小也是不一样的。 2、分类 数据类型 存储大小（位） 取值范围 初始值 包装类 byte 8（一个字节） -2^7 ~~ 2^7 - 1 0 Byte short 16（两个字节） -2^15 ~~ 2^15 - 1 0 Short int 32（四个字节） -2^31 ~~ 2^31 - 1 0 Integer long 64（八个字节） -2^63 ~~ 2^63 - 1 0 Long float 32（四个字节） 0.0 Float double 64（八个字节） 0.0 Double char 16（两个字节） 0 ~~ 65535 ‘’ Character float取值范围：[-3.40282346638528860e+38 , -1.40129846432481707e-45] ∪ [1.40129846432481707e-45 ~ 3.40282346638528860e+38] double取值范围：[-1.79769313486231570e+308,-4.94065645841246544e-324] ∪ [4.94065645841246544e-324,1.79769313486231570e+308] 六、变量1、概述​ 在程序运行过程中，其值可以发生改变的量。从本质上讲变量是内存的一块区域。 2、定义（1）格式：数据类型 变量名 &#x3D; 变量值； （2）范例：int a &#x3D; 10； 3、变量的注意事项（1）变量名不可以重复； （2）变量未赋值不能使用； （3）long类型的变量定义的时候，为防止整数过大，后面要加L； （4）float类型的变量定义的时候，为防止类型不兼容，后面要加F。 七、标识符1、概述​ 给类、方法、变量等起名字的符合。 2、标识符定义规则（1）由数字、字母、下划线（_）和美元符（$）组成； （2）不能以数字开头； （3）不能是关键字； （4）区分大小写。 3、标识符命名约定小驼峰命名法（1）标识符是一个单词的时候，首字母小写； （2）标识符由多个单词组成的时候，第一个单词的首字母小写，其他单词首字母大写。 （3）小驼峰命名法用于给方法和变量命名。 大驼峰命名法（1）标识符是一个单词的时候，首字母大写； （2）标识符由多个单词组成的时候，第一个单词的首字母大写，其他单词首字母大写。 （3）小驼峰命名法用于给类命名。 八、类型转换1、分类​ 自动类型转换、强制类型转换 2、自动类型转换（1）概念：把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。 ​ 范围依次增大 3、强制类型转换（1）概念：把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。 （2）格式：目标数据类型 变量名 &#x3D; （目标数据类型） 值或变量； 九、运算符1、算数运算符（1）运算符：对常量或者变量进行操作的符号。 （2）表达式：用运算符把常量或者变量连接起来的符合Java语法的式子就可以称为表达式。不同运算符连接的表达式体现的是不同类型 的表达式。 2、字符串的“+”操作（字符串的连接符）​ 当字符串进行“+”运算时，相当于是字符串的拼接。 ​ 输出（“aaa” + 6 + 66） 结果：aaa666 ​ 输出（6 + 94 + “aaa”） 结果：100aaa 3、赋值运算符​ 扩展的赋值运算符隐含了强制类型转换 4、自增自减运算符​ **++**：自增运算符 ​ **–**：自减运算符 123456789101112public static void main(String[] args) &#123; int i = 3; i = i-- + i--;//先带入运算为3，然后--，变为2。再相加得到5 System.out.println(i);//5 int[] arr_1 = new int[]&#123;12,13,14,15,16&#125;; int len = arr_1.length - 2; while (len &gt;= 0)&#123;//此时应该注意，此时传入的len = 3； arr_1[len + 1] = arr_1[len--]; &#125; System.out.println(Arrays.toString(arr_1));//[12, 12, 13, 14, 15]&#125; 5、关系运算符​ &gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; 6、逻辑运算符​ ^：逻辑异或 ​ &amp; ：逻辑与 ​ **|**：逻辑或 7、短路运算符​ **&amp;&amp;**：短路与 ​ **||**：短路或 ​ ​ 逻辑运算符与短路运算符的区别 ​ a &amp; b ：不管a的判断结果如何，b的判断结果都会执行。 ​ a &amp;&amp; b：若a的判断结果为flase，则右端的表达式都将不再执行。 8、三元运算符​ a &gt; b ? a : b ; a是否大于b？若大于则返回a，否则返回b","categories":[{"name":"java基础笔记","slug":"java基础笔记","permalink":"https://www.yemaojun.top/categories/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-07-06T07:38:12.000Z","updated":"2023-02-23T13:44:17.428Z","comments":true,"path":"2020/07/06/我的第一篇博客文章/","link":"","permalink":"https://www.yemaojun.top/2020/07/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"第一篇博文","text":"第一篇博文 今天开始创建自己的博客！ 测试标题2测试表格3 数据类型 内存大小 int 4 float 8 double 16","categories":[{"name":"杂文","slug":"杂文","permalink":"https://www.yemaojun.top/categories/%E6%9D%82%E6%96%87/"}],"tags":[]}],"categories":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/categories/Adobe-Form/"},{"name":"业务","slug":"业务","permalink":"https://www.yemaojun.top/categories/%E4%B8%9A%E5%8A%A1/"},{"name":"CO","slug":"CO","permalink":"https://www.yemaojun.top/categories/CO/"},{"name":"CK13N","slug":"CO/CK13N","permalink":"https://www.yemaojun.top/categories/CO/CK13N/"},{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/categories/ABAP/"},{"name":"Dynamic Create","slug":"ABAP/Dynamic-Create","permalink":"https://www.yemaojun.top/categories/ABAP/Dynamic-Create/"},{"name":"RTTC","slug":"RTTC","permalink":"https://www.yemaojun.top/categories/RTTC/"},{"name":"ABAP工具类","slug":"ABAP工具类","permalink":"https://www.yemaojun.top/categories/ABAP%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Package","slug":"Package","permalink":"https://www.yemaojun.top/categories/Package/"},{"name":"请求号","slug":"请求号","permalink":"https://www.yemaojun.top/categories/%E8%AF%B7%E6%B1%82%E5%8F%B7/"},{"name":"SAP BTP","slug":"SAP-BTP","permalink":"https://www.yemaojun.top/categories/SAP-BTP/"},{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/categories/CPI/"},{"name":"JMS","slug":"JMS","permalink":"https://www.yemaojun.top/categories/JMS/"},{"name":"异步","slug":"异步","permalink":"https://www.yemaojun.top/categories/%E5%BC%82%E6%AD%A5/"},{"name":"CDS View","slug":"ABAP/CDS-View","permalink":"https://www.yemaojun.top/categories/ABAP/CDS-View/"},{"name":"CDS View","slug":"CDS-View","permalink":"https://www.yemaojun.top/categories/CDS-View/"},{"name":"ABAP基础","slug":"ABAP基础","permalink":"https://www.yemaojun.top/categories/ABAP%E5%9F%BA%E7%A1%80/"},{"name":"SAP程序调试","slug":"SAP程序调试","permalink":"https://www.yemaojun.top/categories/SAP%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95/"},{"name":"Rest接口","slug":"ABAP/Rest接口","permalink":"https://www.yemaojun.top/categories/ABAP/Rest%E6%8E%A5%E5%8F%A3/"},{"name":"SAP接口","slug":"SAP接口","permalink":"https://www.yemaojun.top/categories/SAP%E6%8E%A5%E5%8F%A3/"},{"name":"代理类 PO接口","slug":"ABAP/代理类-PO接口","permalink":"https://www.yemaojun.top/categories/ABAP/%E4%BB%A3%E7%90%86%E7%B1%BB-PO%E6%8E%A5%E5%8F%A3/"},{"name":"PO接口","slug":"PO接口","permalink":"https://www.yemaojun.top/categories/PO%E6%8E%A5%E5%8F%A3/"},{"name":"杂项收录","slug":"杂项收录","permalink":"https://www.yemaojun.top/categories/%E6%9D%82%E9%A1%B9%E6%94%B6%E5%BD%95/"},{"name":"RFC PO接口","slug":"ABAP/RFC-PO接口","permalink":"https://www.yemaojun.top/categories/ABAP/RFC-PO%E6%8E%A5%E5%8F%A3/"},{"name":"SAP增强","slug":"ABAP/SAP增强","permalink":"https://www.yemaojun.top/categories/ABAP/SAP%E5%A2%9E%E5%BC%BA/"},{"name":"SAP一代增强","slug":"SAP一代增强","permalink":"https://www.yemaojun.top/categories/SAP%E4%B8%80%E4%BB%A3%E5%A2%9E%E5%BC%BA/"},{"name":"Session日志","slug":"ABAP/Session日志","permalink":"https://www.yemaojun.top/categories/ABAP/Session%E6%97%A5%E5%BF%97/"},{"name":"Session","slug":"Session","permalink":"https://www.yemaojun.top/categories/Session/"},{"name":"BDC录屏","slug":"ABAP/BDC录屏","permalink":"https://www.yemaojun.top/categories/ABAP/BDC%E5%BD%95%E5%B1%8F/"},{"name":"批量导入","slug":"批量导入","permalink":"https://www.yemaojun.top/categories/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5/"},{"name":"Smartforms","slug":"ABAP/Smartforms","permalink":"https://www.yemaojun.top/categories/ABAP/Smartforms/"},{"name":"SAP打印","slug":"SAP打印","permalink":"https://www.yemaojun.top/categories/SAP%E6%89%93%E5%8D%B0/"},{"name":"ABAP 字符串","slug":"ABAP-字符串","permalink":"https://www.yemaojun.top/categories/ABAP-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Web Service","slug":"ABAP/Web-Service","permalink":"https://www.yemaojun.top/categories/ABAP/Web-Service/"},{"name":"Popup Function","slug":"Popup-Function","permalink":"https://www.yemaojun.top/categories/Popup-Function/"},{"name":"搜索帮助","slug":"搜索帮助","permalink":"https://www.yemaojun.top/categories/%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9/"},{"name":"Excel Upload","slug":"ABAP/Excel-Upload","permalink":"https://www.yemaojun.top/categories/ABAP/Excel-Upload/"},{"name":"Excel Donwload","slug":"ABAP/Excel-Donwload","permalink":"https://www.yemaojun.top/categories/ABAP/Excel-Donwload/"},{"name":"Dialog","slug":"Dialog","permalink":"https://www.yemaojun.top/categories/Dialog/"},{"name":"OOALV","slug":"OOALV","permalink":"https://www.yemaojun.top/categories/OOALV/"},{"name":"Fiori基础","slug":"Fiori基础","permalink":"https://www.yemaojun.top/categories/Fiori%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"https://www.yemaojun.top/categories/%E9%9D%A2%E8%AF%95/"},{"name":"OData","slug":"OData","permalink":"https://www.yemaojun.top/categories/OData/"},{"name":"搜索帮助出口增强","slug":"搜索帮助出口增强","permalink":"https://www.yemaojun.top/categories/%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9%E5%87%BA%E5%8F%A3%E5%A2%9E%E5%BC%BA/"},{"name":"SAP增强","slug":"SAP增强","permalink":"https://www.yemaojun.top/categories/SAP%E5%A2%9E%E5%BC%BA/"},{"name":"JVM","slug":"JVM","permalink":"https://www.yemaojun.top/categories/JVM/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.yemaojun.top/categories/MySQL/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://www.yemaojun.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"IDEA快捷键","slug":"IDEA快捷键","permalink":"https://www.yemaojun.top/categories/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"笔试","slug":"笔试","permalink":"https://www.yemaojun.top/categories/%E7%AC%94%E8%AF%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.yemaojun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.yemaojun.top/categories/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"https://www.yemaojun.top/categories/Spring/"},{"name":"问题收集","slug":"问题收集","permalink":"https://www.yemaojun.top/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.yemaojun.top/categories/Mybatis/"},{"name":"hexo博客","slug":"hexo博客","permalink":"https://www.yemaojun.top/categories/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"杂文","slug":"杂文","permalink":"https://www.yemaojun.top/categories/%E6%9D%82%E6%96%87/"},{"name":"java基础笔记","slug":"java基础笔记","permalink":"https://www.yemaojun.top/categories/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"},{"name":"集合底层原理","slug":"集合底层原理","permalink":"https://www.yemaojun.top/categories/%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Adobe Form","slug":"Adobe-Form","permalink":"https://www.yemaojun.top/tags/Adobe-Form/"},{"name":"业务","slug":"业务","permalink":"https://www.yemaojun.top/tags/%E4%B8%9A%E5%8A%A1/"},{"name":"ABAP","slug":"ABAP","permalink":"https://www.yemaojun.top/tags/ABAP/"},{"name":"CPI","slug":"CPI","permalink":"https://www.yemaojun.top/tags/CPI/"},{"name":"Fiori","slug":"Fiori","permalink":"https://www.yemaojun.top/tags/Fiori/"},{"name":"随笔","slug":"随笔","permalink":"https://www.yemaojun.top/tags/%E9%9A%8F%E7%AC%94/"}]}